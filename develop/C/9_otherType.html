<!doctype html>
<html lang="zh-CN" data-theme="light">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <meta name="generator" content="VuePress 2.0.0-rc.18" />
    <meta name="theme" content="VuePress Theme Hope 2.0.0-rc.27" />
    <style>
      html {
        background: var(--bg-color, #fff);
      }

      html[data-theme="dark"] {
        background: var(--bg-color, #1d1e1f);
      }

      body {
        background: var(--bg-color);
      }
    </style>
    <script>
      const userMode = localStorage.getItem("vuepress-theme-hope-scheme");
      const systemDarkMode =
        window.matchMedia &&
        window.matchMedia("(prefers-color-scheme: dark)").matches;

      if (userMode === "dark" || (userMode !== "light" && systemDarkMode)) {
        document.documentElement.setAttribute("data-theme", "dark");
      }
    </script>
    <meta property="og:url" content="https://echo0d.github.io/DailyNotes/develop/C/9_otherType.html"><meta property="og:site_name" content="echo0d-notes"><meta property="og:title" content="09. C语言-其他类型"><meta property="og:description" content="09. C语言-其他类型 1 typedef 命令 1.1 简介 typedef命令用来为某个类型起别名。 上面代码中，type代表类型名，name代表别名。 上面示例中，typedef命令为类型unsign char起别名BYTE，然后就可以使用BYTE声明变量。 typedef 可以一次指定多个别名。 上面示例中，一次性为int类型起了三个别名。 ..."><meta property="og:type" content="article"><meta property="og:locale" content="zh-CN"><meta property="og:updated_time" content="2025-04-11T02:11:10.000Z"><meta property="article:author" content="echo0d"><meta property="article:tag" content="C"><meta property="article:modified_time" content="2025-04-11T02:11:10.000Z"><script type="application/ld+json">{"@context":"https://schema.org","@type":"Article","headline":"09. C语言-其他类型","image":[""],"dateModified":"2025-04-11T02:11:10.000Z","author":[{"@type":"Person","name":"echo0d","url":""}]}</script><link rel="alternate" type="application/atom+xml" href="https://echo0d.github.io/DailyNotes/atom.xml" title="echo0d-notes Atom Feed"><link rel="alternate" type="application/json" href="https://echo0d.github.io/DailyNotes/feed.json" title="echo0d-notes JSON Feed"><link rel="alternate" type="application/rss+xml" href="https://echo0d.github.io/DailyNotes/rss.xml" title="echo0d-notes RSS Feed"><title>09. C语言-其他类型 | echo0d-notes</title><meta name="description" content="09. C语言-其他类型 1 typedef 命令 1.1 简介 typedef命令用来为某个类型起别名。 上面代码中，type代表类型名，name代表别名。 上面示例中，typedef命令为类型unsign char起别名BYTE，然后就可以使用BYTE声明变量。 typedef 可以一次指定多个别名。 上面示例中，一次性为int类型起了三个别名。 ...">
    <link rel="preload" href="/DailyNotes/assets/style-Dv7PuMJl.css" as="style"><link rel="stylesheet" href="/DailyNotes/assets/style-Dv7PuMJl.css">
    <link rel="modulepreload" href="/DailyNotes/assets/app-vU8izl1I.js"><link rel="modulepreload" href="/DailyNotes/assets/9_otherType.html-XZeGNPyb.js"><link rel="modulepreload" href="/DailyNotes/assets/plugin-vue_export-helper-DlAUqK2U.js">
    <link rel="prefetch" href="/DailyNotes/assets/index.html-DxpUmIwo.js" as="script"><link rel="prefetch" href="/DailyNotes/assets/flow-eda功能节点.html-CgPq0VaE.js" as="script"><link rel="prefetch" href="/DailyNotes/assets/index.html-aOjQqXFN.js" as="script"><link rel="prefetch" href="/DailyNotes/assets/DailySkills.html-390gELqN.js" as="script"><link rel="prefetch" href="/DailyNotes/assets/Treasure.html-CxkWStEN.js" as="script"><link rel="prefetch" href="/DailyNotes/assets/1-FileSystem.html-DZw1gsSp.js" as="script"><link rel="prefetch" href="/DailyNotes/assets/2-commandExecute.html-7JrX3_ZT.js" as="script"><link rel="prefetch" href="/DailyNotes/assets/3-Database.html-CNElG8QR.js" as="script"><link rel="prefetch" href="/DailyNotes/assets/4-JNDI.html-CTO8DvFD.js" as="script"><link rel="prefetch" href="/DailyNotes/assets/5-reflection.html-CWKKR-37.js" as="script"><link rel="prefetch" href="/DailyNotes/assets/6-ClassLoader.html--dtuU35r.js" as="script"><link rel="prefetch" href="/DailyNotes/assets/7-DynamicProxy.html-DJUWjF7k.js" as="script"><link rel="prefetch" href="/DailyNotes/assets/1-JavaEE.html-BOV1P2vo.js" as="script"><link rel="prefetch" href="/DailyNotes/assets/2-JavaMVC.html-CeneEdcN.js" as="script"><link rel="prefetch" href="/DailyNotes/assets/3-JavaWeb_Servlet.html-eQsuWbjV.js" as="script"><link rel="prefetch" href="/DailyNotes/assets/4-JavaWeb_filter.html-Bnaa3oyV.js" as="script"><link rel="prefetch" href="/DailyNotes/assets/5-JavaWeb_Listener.html-BRbFj-W7.js" as="script"><link rel="prefetch" href="/DailyNotes/assets/6-CookieAndSession.html--8UoDANF.js" as="script"><link rel="prefetch" href="/DailyNotes/assets/7-JSP.html-BCEztKHV.js" as="script"><link rel="prefetch" href="/DailyNotes/assets/JavaVul.html-DayT_nwA.js" as="script"><link rel="prefetch" href="/DailyNotes/assets/deserialize.html-BIl9lfqY.js" as="script"><link rel="prefetch" href="/DailyNotes/assets/GoVul.html-C_sLF_oZ.js" as="script"><link rel="prefetch" href="/DailyNotes/assets/1-PHPBase.html-DBUGvpJL.js" as="script"><link rel="prefetch" href="/DailyNotes/assets/1-CTF_WEB.html-BfnnfAVv.js" as="script"><link rel="prefetch" href="/DailyNotes/assets/index.html-Cs5_tLfk.js" as="script"><link rel="prefetch" href="/DailyNotes/assets/ExecuteAssembly.html-CeAcXofj.js" as="script"><link rel="prefetch" href="/DailyNotes/assets/ProcessInjection.html-CeQ-HYni.js" as="script"><link rel="prefetch" href="/DailyNotes/assets/RDI.html-BJvsRoN1.js" as="script"><link rel="prefetch" href="/DailyNotes/assets/index.html-D5OtDZto.js" as="script"><link rel="prefetch" href="/DailyNotes/assets/WindowsArchitectureProcess.html-BlGFEpd_.js" as="script"><link rel="prefetch" href="/DailyNotes/assets/index.html-2Zr-0U3a.js" as="script"><link rel="prefetch" href="/DailyNotes/assets/SrcNote.html-DSmSWrtC.js" as="script"><link rel="prefetch" href="/DailyNotes/assets/10_memory.html-pp53Ield.js" as="script"><link rel="prefetch" href="/DailyNotes/assets/11_preprocessor.html-BFIE3plZ.js" as="script"><link rel="prefetch" href="/DailyNotes/assets/12_IO.html-GGso8Fek.js" as="script"><link rel="prefetch" href="/DailyNotes/assets/13_file.html-DN4zrjvV.js" as="script"><link rel="prefetch" href="/DailyNotes/assets/14_specifier.html-BN9P9_SH.js" as="script"><link rel="prefetch" href="/DailyNotes/assets/15_multifile.html-BXaLI-_C.js" as="script"><link rel="prefetch" href="/DailyNotes/assets/16_cli.html-yWH7TFpA.js" as="script"><link rel="prefetch" href="/DailyNotes/assets/17_multibyte.html-Dm3dYnlT.js" as="script"><link rel="prefetch" href="/DailyNotes/assets/1_syntax.html-BrS9XoJw.js" as="script"><link rel="prefetch" href="/DailyNotes/assets/2_VariableTypes.html-CE_257E1.js" as="script"><link rel="prefetch" href="/DailyNotes/assets/3_Operator.html-DH5qZbd9.js" as="script"><link rel="prefetch" href="/DailyNotes/assets/4_flow-control.html-CM4cu7Up.js" as="script"><link rel="prefetch" href="/DailyNotes/assets/5_pointer.html-Do0TPD0W.js" as="script"><link rel="prefetch" href="/DailyNotes/assets/6_function.html-BW78a98Y.js" as="script"><link rel="prefetch" href="/DailyNotes/assets/7_array.html-BQA-vSqh.js" as="script"><link rel="prefetch" href="/DailyNotes/assets/8_string.html-BYQhbjRi.js" as="script"><link rel="prefetch" href="/DailyNotes/assets/index.html-BBHt1i3P.js" as="script"><link rel="prefetch" href="/DailyNotes/assets/1_Externsion.html-DtpzVVWb.js" as="script"><link rel="prefetch" href="/DailyNotes/assets/2_Encapsulation.html-BgiLvzah.js" as="script"><link rel="prefetch" href="/DailyNotes/assets/3_Class_object.html-CA2_LFOT.js" as="script"><link rel="prefetch" href="/DailyNotes/assets/4_Inheritance.html-CYz8-CMx.js" as="script"><link rel="prefetch" href="/DailyNotes/assets/5_overloading.html-CHy2xE3j.js" as="script"><link rel="prefetch" href="/DailyNotes/assets/6_polymorphism.html-DRtsfvnG.js" as="script"><link rel="prefetch" href="/DailyNotes/assets/index.html-BtrQ2Mxj.js" as="script"><link rel="prefetch" href="/DailyNotes/assets/JSModularity.html-BEpKr2fS.js" as="script"><link rel="prefetch" href="/DailyNotes/assets/index.html-DsNQi_FW.js" as="script"><link rel="prefetch" href="/DailyNotes/assets/React_Typescript_antd.html-CqOp5Oka.js" as="script"><link rel="prefetch" href="/DailyNotes/assets/Vue.html-ChZgBe2K.js" as="script"><link rel="prefetch" href="/DailyNotes/assets/1_JavaBase.html-D__-nA23.js" as="script"><link rel="prefetch" href="/DailyNotes/assets/2_ObjectOriented.html-LFxKRmNh.js" as="script"><link rel="prefetch" href="/DailyNotes/assets/3_CoreClass.html-F0zfb6gY.js" as="script"><link rel="prefetch" href="/DailyNotes/assets/4_Exception.html-BIgTQV63.js" as="script"><link rel="prefetch" href="/DailyNotes/assets/5_Reflection.html-BwQ8mVPM.js" as="script"><link rel="prefetch" href="/DailyNotes/assets/6_Annotation.html-ndXY8Yg1.js" as="script"><link rel="prefetch" href="/DailyNotes/assets/7_Genericity.html-DgY9iazb.js" as="script"><link rel="prefetch" href="/DailyNotes/assets/8_Native.html-B_OFojj2.js" as="script"><link rel="prefetch" href="/DailyNotes/assets/index.html-H5jvA7pY.js" as="script"><link rel="prefetch" href="/DailyNotes/assets/test_django.html-DRxiJWax.js" as="script"><link rel="prefetch" href="/DailyNotes/assets/index.html-DfjA8HeH.js" as="script"><link rel="prefetch" href="/DailyNotes/assets/anti-debug.html-DxC7kuCj.js" as="script"><link rel="prefetch" href="/DailyNotes/assets/index.html-CU4el-xa.js" as="script"><link rel="prefetch" href="/DailyNotes/assets/1_InformationGathering.html-DuX0bpuN.js" as="script"><link rel="prefetch" href="/DailyNotes/assets/2_Intranet_windows.html-D_fwJGYp.js" as="script"><link rel="prefetch" href="/DailyNotes/assets/3_CDN.html-BU_cWMko.js" as="script"><link rel="prefetch" href="/DailyNotes/assets/1_LinuxPersistence.html-DbC2SPTX.js" as="script"><link rel="prefetch" href="/DailyNotes/assets/2_WindowsPersistence.html-CB3Pw9dg.js" as="script"><link rel="prefetch" href="/DailyNotes/assets/1_Linux.html-BDEE34Iw.js" as="script"><link rel="prefetch" href="/DailyNotes/assets/2_Windows.html-BXDpa2XI.js" as="script"><link rel="prefetch" href="/DailyNotes/assets/Intranet_tunnel.html-BCOkx7vn.js" as="script"><link rel="prefetch" href="/DailyNotes/assets/Tamper.html-9FnMZkof.js" as="script"><link rel="prefetch" href="/DailyNotes/assets/TracesRemoval.html-BqJGypaa.js" as="script"><link rel="prefetch" href="/DailyNotes/assets/Burpsuite.html-D4aN7QuS.js" as="script"><link rel="prefetch" href="/DailyNotes/assets/SQLmap.html-BmOBtvqG.js" as="script"><link rel="prefetch" href="/DailyNotes/assets/Tunnel.html-BtAZu5oD.js" as="script"><link rel="prefetch" href="/DailyNotes/assets/WebShell.html-BzrPSb3O.js" as="script"><link rel="prefetch" href="/DailyNotes/assets/openwrt.html-Do9MsJ06.js" as="script"><link rel="prefetch" href="/DailyNotes/assets/1_GoFinal.html-Cc4qrc_d.js" as="script"><link rel="prefetch" href="/DailyNotes/assets/2_fscanPro.html-BpnJKRxg.js" as="script"><link rel="prefetch" href="/DailyNotes/assets/index.html-Ddpo_oz3.js" as="script"><link rel="prefetch" href="/DailyNotes/assets/index.html-DKOYUQRW.js" as="script"><link rel="prefetch" href="/DailyNotes/assets/ch1.html-D5fuRwnC.js" as="script"><link rel="prefetch" href="/DailyNotes/assets/ch10.html-Duco8vsj.js" as="script"><link rel="prefetch" href="/DailyNotes/assets/ch11.html-BH9z45jz.js" as="script"><link rel="prefetch" href="/DailyNotes/assets/ch12.html-D2FGBAjx.js" as="script"><link rel="prefetch" href="/DailyNotes/assets/ch2.html-BzdRNJup.js" as="script"><link rel="prefetch" href="/DailyNotes/assets/ch3.html-W2dWuk8b.js" as="script"><link rel="prefetch" href="/DailyNotes/assets/ch4.html-C0-yEfBk.js" as="script"><link rel="prefetch" href="/DailyNotes/assets/ch5.html-UkSdsdc7.js" as="script"><link rel="prefetch" href="/DailyNotes/assets/ch6.html-B1E7mZjj.js" as="script"><link rel="prefetch" href="/DailyNotes/assets/ch7.html-K44pUpjs.js" as="script"><link rel="prefetch" href="/DailyNotes/assets/node_CVE-2017-14849.html-_agkIP_f.js" as="script"><link rel="prefetch" href="/DailyNotes/assets/tomcat_CVE-2017-12615.html-DY8xrr_C.js" as="script"><link rel="prefetch" href="/DailyNotes/assets/tomcat_CVE-2020-1938.html-DPx9wdDP.js" as="script"><link rel="prefetch" href="/DailyNotes/assets/weblogic_CVE-2017-10271.html-DPAesF-T.js" as="script"><link rel="prefetch" href="/DailyNotes/assets/weblogic_CVE-2018-2894.html-BbQ0EGDy.js" as="script"><link rel="prefetch" href="/DailyNotes/assets/weblogic_CVE-2020-14882.html-BhwptPXe.js" as="script"><link rel="prefetch" href="/DailyNotes/assets/FastjsonVul.html-DFhPmkK7.js" as="script"><link rel="prefetch" href="/DailyNotes/assets/log4j2 .html-B7TxYmX-.js" as="script"><link rel="prefetch" href="/DailyNotes/assets/shiro.html-B4hO0n6G.js" as="script"><link rel="prefetch" href="/DailyNotes/assets/shiro_CVE-2019-12422_shiro721.html-B9HBafmc.js" as="script"><link rel="prefetch" href="/DailyNotes/assets/shiro_CVE-2020-11989.html-D_X3tzlA.js" as="script"><link rel="prefetch" href="/DailyNotes/assets/shiro_CVE-2020-13933.html-Bg-K8Et5.js" as="script"><link rel="prefetch" href="/DailyNotes/assets/spring.html-GJPrIPJW.js" as="script"><link rel="prefetch" href="/DailyNotes/assets/spring_CVE-2018-1273_bypass.html-BSiNic5d.js" as="script"><link rel="prefetch" href="/DailyNotes/assets/supervisor_CVE-2017-11610.html-9OYqx6zj.js" as="script"><link rel="prefetch" href="/DailyNotes/assets/xstream_CVE-2021-21351.html-D6agD33-.js" as="script"><link rel="prefetch" href="/DailyNotes/assets/C3.html-9x-oalxY.js" as="script"><link rel="prefetch" href="/DailyNotes/assets/CS.html-Bo2ocSt3.js" as="script"><link rel="prefetch" href="/DailyNotes/assets/MSFUse.html-B9glBPJ4.js" as="script"><link rel="prefetch" href="/DailyNotes/assets/MSF_CS.html-Cs6JBKue.js" as="script"><link rel="prefetch" href="/DailyNotes/assets/404.html-DSwUaFfR.js" as="script"><link rel="prefetch" href="/DailyNotes/assets/index.html-aqKs9mpT.js" as="script"><link rel="prefetch" href="/DailyNotes/assets/index.html-VQGdvoLC.js" as="script"><link rel="prefetch" href="/DailyNotes/assets/index.html-CgbY8s9u.js" as="script"><link rel="prefetch" href="/DailyNotes/assets/index.html-B59U0twF.js" as="script"><link rel="prefetch" href="/DailyNotes/assets/index.html-BMjEHxkd.js" as="script"><link rel="prefetch" href="/DailyNotes/assets/index.html-JxAES8Zc.js" as="script"><link rel="prefetch" href="/DailyNotes/assets/index.html-CKjJoIea.js" as="script"><link rel="prefetch" href="/DailyNotes/assets/index.html-CDOVZJ7y.js" as="script"><link rel="prefetch" href="/DailyNotes/assets/index.html-CIAyxPL0.js" as="script"><link rel="prefetch" href="/DailyNotes/assets/index.html-BiKcqPbF.js" as="script"><link rel="prefetch" href="/DailyNotes/assets/index.html-C0VOaffZ.js" as="script"><link rel="prefetch" href="/DailyNotes/assets/index.html-O2eNDIOD.js" as="script"><link rel="prefetch" href="/DailyNotes/assets/index.html-Bp7rm6P8.js" as="script"><link rel="prefetch" href="/DailyNotes/assets/index.html-BZVk97J5.js" as="script"><link rel="prefetch" href="/DailyNotes/assets/index.html-DwPaAu6a.js" as="script"><link rel="prefetch" href="/DailyNotes/assets/index.html-cn_4SGNP.js" as="script"><link rel="prefetch" href="/DailyNotes/assets/index.html-BZDQLPMM.js" as="script"><link rel="prefetch" href="/DailyNotes/assets/index.html-DeuP-q9E.js" as="script"><link rel="prefetch" href="/DailyNotes/assets/index.html-DtNvF2jW.js" as="script"><link rel="prefetch" href="/DailyNotes/assets/index.html-Bp56rvli.js" as="script"><link rel="prefetch" href="/DailyNotes/assets/index.html-YE4e0XSA.js" as="script"><link rel="prefetch" href="/DailyNotes/assets/index.html-DvbxydV8.js" as="script"><link rel="prefetch" href="/DailyNotes/assets/index.html-C4OLCn7k.js" as="script"><link rel="prefetch" href="/DailyNotes/assets/index.html-DV8GQGH6.js" as="script"><link rel="prefetch" href="/DailyNotes/assets/index.html-DxM03KOn.js" as="script"><link rel="prefetch" href="/DailyNotes/assets/index.html-r4ZuRoH-.js" as="script"><link rel="prefetch" href="/DailyNotes/assets/index.html-CnZ3DHjU.js" as="script"><link rel="prefetch" href="/DailyNotes/assets/index.html-DLhvCi_p.js" as="script"><link rel="prefetch" href="/DailyNotes/assets/index.html-DfPK2Z04.js" as="script"><link rel="prefetch" href="/DailyNotes/assets/index.html-7d25UT4C.js" as="script"><link rel="prefetch" href="/DailyNotes/assets/index.html-CNtlwYDw.js" as="script"><link rel="prefetch" href="/DailyNotes/assets/index.html-BgjeoOyG.js" as="script"><link rel="prefetch" href="/DailyNotes/assets/index.html-duEp4mlT.js" as="script"><link rel="prefetch" href="/DailyNotes/assets/index.html-DWveNfca.js" as="script"><link rel="prefetch" href="/DailyNotes/assets/index.html-B5twebzo.js" as="script"><link rel="prefetch" href="/DailyNotes/assets/index.html-C6hlE8l6.js" as="script"><link rel="prefetch" href="/DailyNotes/assets/index.html-CDAEeQDo.js" as="script"><link rel="prefetch" href="/DailyNotes/assets/index.html-CmPEb5xH.js" as="script"><link rel="prefetch" href="/DailyNotes/assets/index.html-wDGG2QjE.js" as="script"><link rel="prefetch" href="/DailyNotes/assets/index.html-DO-eWmq_.js" as="script"><link rel="prefetch" href="/DailyNotes/assets/index.html-B0cl-JOU.js" as="script"><link rel="prefetch" href="/DailyNotes/assets/index.html-Dz7E5ObP.js" as="script"><link rel="prefetch" href="/DailyNotes/assets/index.html-P_9piXbk.js" as="script"><link rel="prefetch" href="/DailyNotes/assets/index.html-D28MLAGa.js" as="script"><link rel="prefetch" href="/DailyNotes/assets/index.html-DdP8YxBX.js" as="script"><link rel="prefetch" href="/DailyNotes/assets/index.html-kZrGW049.js" as="script"><link rel="prefetch" href="/DailyNotes/assets/index.html-D5H8kB_r.js" as="script"><link rel="prefetch" href="/DailyNotes/assets/index.html-DWfl5jNy.js" as="script"><link rel="prefetch" href="/DailyNotes/assets/index.html-CRkw5WAW.js" as="script"><link rel="prefetch" href="/DailyNotes/assets/index.html-5RDaAIiY.js" as="script"><link rel="prefetch" href="/DailyNotes/assets/index.html-Di4NsAxd.js" as="script"><link rel="prefetch" href="/DailyNotes/assets/index.html-CNi_m2Ng.js" as="script"><link rel="prefetch" href="/DailyNotes/assets/index.html-DtCBOlJq.js" as="script"><link rel="prefetch" href="/DailyNotes/assets/index.html-ZBxGiUXh.js" as="script"><link rel="prefetch" href="/DailyNotes/assets/index.html-DT3Nwp1-.js" as="script"><link rel="prefetch" href="/DailyNotes/assets/index.html-BstrutJ0.js" as="script"><link rel="prefetch" href="/DailyNotes/assets/index.html-CJeN5WaS.js" as="script"><link rel="prefetch" href="/DailyNotes/assets/index.html-CaD3m_E5.js" as="script"><link rel="prefetch" href="/DailyNotes/assets/index.html-DuK9ZtxJ.js" as="script"><link rel="prefetch" href="/DailyNotes/assets/index.html-DuK9ZtxJ.js" as="script"><link rel="prefetch" href="/DailyNotes/assets/index.html-CoX2rLCl.js" as="script"><link rel="prefetch" href="/DailyNotes/assets/index.html-BNqB6keV.js" as="script"><link rel="prefetch" href="/DailyNotes/assets/index.html-CFudfHCb.js" as="script"><link rel="prefetch" href="/DailyNotes/assets/index.html-CTP-wfCs.js" as="script"><link rel="prefetch" href="/DailyNotes/assets/index.html-IQI1Okbu.js" as="script"><link rel="prefetch" href="/DailyNotes/assets/index.html-Dq2ZsBfC.js" as="script"><link rel="prefetch" href="/DailyNotes/assets/index.html-CVnGBYFI.js" as="script"><link rel="prefetch" href="/DailyNotes/assets/index.html-CM322QYM.js" as="script"><link rel="prefetch" href="/DailyNotes/assets/index.html-IcbJsWMi.js" as="script"><link rel="prefetch" href="/DailyNotes/assets/index.html-U-eKHG8c.js" as="script"><link rel="prefetch" href="/DailyNotes/assets/index.html-DT3rbGaH.js" as="script"><link rel="prefetch" href="/DailyNotes/assets/index.html-DkGIIpps.js" as="script"><link rel="prefetch" href="/DailyNotes/assets/index.html-COUb0edA.js" as="script"><link rel="prefetch" href="/DailyNotes/assets/index.html-DriztR0M.js" as="script"><link rel="prefetch" href="/DailyNotes/assets/index.html-CQTfx9Ok.js" as="script"><link rel="prefetch" href="/DailyNotes/assets/index.html-BbFriPta.js" as="script"><link rel="prefetch" href="/DailyNotes/assets/index.html-CFh32Jyg.js" as="script"><link rel="prefetch" href="/DailyNotes/assets/index.html-CEinZGkr.js" as="script"><link rel="prefetch" href="/DailyNotes/assets/index.html-Bo8aa1Yi.js" as="script"><link rel="prefetch" href="/DailyNotes/assets/index.html-DaY7_ngv.js" as="script"><link rel="prefetch" href="/DailyNotes/assets/index.html-BVt2Ajni.js" as="script"><link rel="prefetch" href="/DailyNotes/assets/photoswipe.esm-D2Nf-uDI.js" as="script"><link rel="prefetch" href="/DailyNotes/assets/SearchResult-JBJ8oUgM.js" as="script">
  </head>
  <body>
    <div id="app"><!--[--><!--[--><!--[--><span tabindex="-1"></span><a href="#main-content" class="vp-skip-link sr-only">跳至主要內容</a><!--]--><div class="theme-container has-toc"><!--[--><header id="navbar" class="vp-navbar"><div class="vp-navbar-start"><button type="button" class="vp-toggle-sidebar-button" title="Toggle Sidebar"><span class="icon"></span></button><!--[--><!----><!--]--><!--[--><a class="route-link vp-brand" href="/DailyNotes/"><img class="vp-nav-logo" src="/DailyNotes/logo.jpg" alt><!----><span class="vp-site-name hide-in-pad">echo0d-notes</span></a><!--]--><!--[--><!----><!--]--></div><div class="vp-navbar-center"><!--[--><!----><!--]--><!--[--><nav class="vp-nav-links"><div class="nav-item hide-in-mobile"><a class="route-link nav-link" href="/DailyNotes/CyberSecurity/" aria-label="网络安全"><span class="font-icon icon fa-fw fa-sm fas fa-laptop-code" style=""></span>网络安全<!----></a></div><div class="nav-item hide-in-mobile"><a class="route-link nav-link" href="/DailyNotes/CodeAudittutorial/" aria-label="代码审计"><span class="font-icon icon fa-fw fa-sm fas fa-laptop-code" style=""></span>代码审计<!----></a></div><div class="nav-item hide-in-mobile"><a class="route-link nav-link active" href="/DailyNotes/develop/" aria-label="开发技术"><span class="font-icon icon fa-fw fa-sm fas fa-laptop-code" style=""></span>开发技术<!----></a></div><div class="nav-item hide-in-mobile"><a class="route-link nav-link" href="/DailyNotes/others/" aria-label="其他随笔"><span class="font-icon icon fa-fw fa-sm fas fa-laptop-code" style=""></span>其他随笔<!----></a></div></nav><!--]--><!--[--><!----><!--]--></div><div class="vp-navbar-end"><!--[--><!----><!--]--><!--[--><!----><div class="nav-item vp-repo"><a class="vp-repo-link" href="https://github.com/echo0d/DailyNotes" target="_blank" rel="noopener noreferrer" aria-label="GitHub"><svg xmlns="http://www.w3.org/2000/svg" class="icon github-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="github icon" style="width:1.25rem;height:1.25rem;vertical-align:middle;"><path d="M511.957 21.333C241.024 21.333 21.333 240.981 21.333 512c0 216.832 140.544 400.725 335.574 465.664 24.49 4.395 32.256-10.07 32.256-23.083 0-11.69.256-44.245 0-85.205-136.448 29.61-164.736-64.64-164.736-64.64-22.315-56.704-54.4-71.765-54.4-71.765-44.587-30.464 3.285-29.824 3.285-29.824 49.195 3.413 75.179 50.517 75.179 50.517 43.776 75.008 114.816 53.333 142.762 40.79 4.523-31.66 17.152-53.377 31.19-65.537-108.971-12.458-223.488-54.485-223.488-242.602 0-53.547 19.114-97.323 50.517-131.67-5.035-12.33-21.93-62.293 4.779-129.834 0 0 41.258-13.184 134.912 50.346a469.803 469.803 0 0 1 122.88-16.554c41.642.213 83.626 5.632 122.88 16.554 93.653-63.488 134.784-50.346 134.784-50.346 26.752 67.541 9.898 117.504 4.864 129.834 31.402 34.347 50.474 78.123 50.474 131.67 0 188.586-114.73 230.016-224.042 242.09 17.578 15.232 33.578 44.672 33.578 90.454v135.85c0 13.142 7.936 27.606 32.854 22.87C862.25 912.597 1002.667 728.747 1002.667 512c0-271.019-219.648-490.667-490.71-490.667z"></path></svg></a></div><div class="nav-item hide-in-mobile"><button type="button" class="outlook-button" tabindex="-1" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" class="icon outlook-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="outlook icon"><path d="M224 800c0 9.6 3.2 44.8 6.4 54.4 6.4 48-48 76.8-48 76.8s80 41.6 147.2 0 134.4-134.4 38.4-195.2c-22.4-12.8-41.6-19.2-57.6-19.2C259.2 716.8 227.2 761.6 224 800zM560 675.2l-32 51.2c-51.2 51.2-83.2 32-83.2 32 25.6 67.2 0 112-12.8 128 25.6 6.4 51.2 9.6 80 9.6 54.4 0 102.4-9.6 150.4-32l0 0c3.2 0 3.2-3.2 3.2-3.2 22.4-16 12.8-35.2 6.4-44.8-9.6-12.8-12.8-25.6-12.8-41.6 0-54.4 60.8-99.2 137.6-99.2 6.4 0 12.8 0 22.4 0 12.8 0 38.4 9.6 48-25.6 0-3.2 0-3.2 3.2-6.4 0-3.2 3.2-6.4 3.2-6.4 6.4-16 6.4-16 6.4-19.2 9.6-35.2 16-73.6 16-115.2 0-105.6-41.6-198.4-108.8-268.8C704 396.8 560 675.2 560 675.2zM224 419.2c0-28.8 22.4-51.2 51.2-51.2 28.8 0 51.2 22.4 51.2 51.2 0 28.8-22.4 51.2-51.2 51.2C246.4 470.4 224 448 224 419.2zM320 284.8c0-22.4 19.2-41.6 41.6-41.6 22.4 0 41.6 19.2 41.6 41.6 0 22.4-19.2 41.6-41.6 41.6C339.2 326.4 320 307.2 320 284.8zM457.6 208c0-12.8 12.8-25.6 25.6-25.6 12.8 0 25.6 12.8 25.6 25.6 0 12.8-12.8 25.6-25.6 25.6C470.4 233.6 457.6 220.8 457.6 208zM128 505.6C128 592 153.6 672 201.6 736c28.8-60.8 112-60.8 124.8-60.8-16-51.2 16-99.2 16-99.2l316.8-422.4c-48-19.2-99.2-32-150.4-32C297.6 118.4 128 291.2 128 505.6zM764.8 86.4c-22.4 19.2-390.4 518.4-390.4 518.4-22.4 28.8-12.8 76.8 22.4 99.2l9.6 6.4c35.2 22.4 80 12.8 99.2-25.6 0 0 6.4-12.8 9.6-19.2 54.4-105.6 275.2-524.8 288-553.6 6.4-19.2-3.2-32-19.2-32C777.6 76.8 771.2 80 764.8 86.4z"></path></svg><div class="outlook-dropdown"><!----></div></button></div><!--[--><button type="button" class="search-pro-button" aria-label="搜索"><svg xmlns="http://www.w3.org/2000/svg" class="icon search-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="search icon"><path d="M192 480a256 256 0 1 1 512 0 256 256 0 0 1-512 0m631.776 362.496-143.2-143.168A318.464 318.464 0 0 0 768 480c0-176.736-143.264-320-320-320S128 303.264 128 480s143.264 320 320 320a318.016 318.016 0 0 0 184.16-58.592l146.336 146.368c12.512 12.48 32.768 12.48 45.28 0 12.48-12.512 12.48-32.768 0-45.28"></path></svg><div class="search-pro-placeholder">搜索</div><div class="search-pro-key-hints"><kbd class="search-pro-key">Ctrl</kbd><kbd class="search-pro-key">K</kbd></div></button><!--]--><!--]--><!--[--><!----><!--]--><button type="button" class="vp-toggle-navbar-button" aria-label="Toggle Navbar" aria-expanded="false" aria-controls="nav-screen"><span><span class="vp-top"></span><span class="vp-middle"></span><span class="vp-bottom"></span></span></button></div></header><!----><!--]--><!----><div class="toggle-sidebar-wrapper"><span class="arrow start"></span></div><aside id="sidebar" class="vp-sidebar"><!--[--><!----><!--]--><ul class="vp-sidebar-links"><li><section class="vp-sidebar-group"><p class="vp-sidebar-header clickable active"><!----><a class="route-link nav-link active vp-sidebar-title" href="/DailyNotes/develop/" aria-label="开发技术"><!---->开发技术<!----></a><!----></p><ul class="vp-sidebar-links"><li><section class="vp-sidebar-group"><button class="vp-sidebar-header clickable active" type="button"><!----><span class="vp-sidebar-title">C 语言</span><span class="vp-arrow down"></span></button><ul class="vp-sidebar-links"><li><a class="route-link nav-link vp-sidebar-link vp-sidebar-page" href="/DailyNotes/develop/C/" aria-label="C 语言"><!---->C 语言<!----></a></li><li><a class="route-link nav-link vp-sidebar-link vp-sidebar-page" href="/DailyNotes/develop/C/1_syntax.html" aria-label="01. C语言-基本语法"><!---->01. C语言-基本语法<!----></a></li><li><a class="route-link nav-link vp-sidebar-link vp-sidebar-page" href="/DailyNotes/develop/C/2_VariableTypes.html" aria-label="02. C语言-变量&amp;数据类型"><!---->02. C语言-变量&amp;数据类型<!----></a></li><li><a class="route-link nav-link vp-sidebar-link vp-sidebar-page" href="/DailyNotes/develop/C/3_Operator.html" aria-label="03. C语言-运算符"><!---->03. C语言-运算符<!----></a></li><li><a class="route-link nav-link vp-sidebar-link vp-sidebar-page" href="/DailyNotes/develop/C/4_flow-control.html" aria-label="04. C语言-流程控制"><!---->04. C语言-流程控制<!----></a></li><li><a class="route-link nav-link vp-sidebar-link vp-sidebar-page" href="/DailyNotes/develop/C/5_pointer.html" aria-label="05. C语言-指针"><!---->05. C语言-指针<!----></a></li><li><a class="route-link nav-link vp-sidebar-link vp-sidebar-page" href="/DailyNotes/develop/C/6_function.html" aria-label="06. C语言-函数"><!---->06. C语言-函数<!----></a></li><li><a class="route-link nav-link vp-sidebar-link vp-sidebar-page" href="/DailyNotes/develop/C/7_array.html" aria-label="07. C语言-数组"><!---->07. C语言-数组<!----></a></li><li><a class="route-link nav-link vp-sidebar-link vp-sidebar-page" href="/DailyNotes/develop/C/8_string.html" aria-label="08. C语言-字符串"><!---->08. C语言-字符串<!----></a></li><li><a class="route-link nav-link active vp-sidebar-link vp-sidebar-page active" href="/DailyNotes/develop/C/9_otherType.html" aria-label="09. C语言-其他类型"><!---->09. C语言-其他类型<!----></a></li><li><a class="route-link nav-link vp-sidebar-link vp-sidebar-page" href="/DailyNotes/develop/C/10_memory.html" aria-label="10. C语言-内存管理"><!---->10. C语言-内存管理<!----></a></li><li><a class="route-link nav-link vp-sidebar-link vp-sidebar-page" href="/DailyNotes/develop/C/11_preprocessor.html" aria-label="11. C语言-预处理器"><!---->11. C语言-预处理器<!----></a></li><li><a class="route-link nav-link vp-sidebar-link vp-sidebar-page" href="/DailyNotes/develop/C/12_IO.html" aria-label="12. C语言-I/O 函数"><!---->12. C语言-I/O 函数<!----></a></li><li><a class="route-link nav-link vp-sidebar-link vp-sidebar-page" href="/DailyNotes/develop/C/13_file.html" aria-label="13. C语言-文件操作"><!---->13. C语言-文件操作<!----></a></li><li><a class="route-link nav-link vp-sidebar-link vp-sidebar-page" href="/DailyNotes/develop/C/14_specifier.html" aria-label="14. C语言-变量说明符"><!---->14. C语言-变量说明符<!----></a></li><li><a class="route-link nav-link vp-sidebar-link vp-sidebar-page" href="/DailyNotes/develop/C/15_multifile.html" aria-label="15. C语言-多文件项目"><!---->15. C语言-多文件项目<!----></a></li><li><a class="route-link nav-link vp-sidebar-link vp-sidebar-page" href="/DailyNotes/develop/C/16_cli.html" aria-label="16. C语言-命令行环境"><!---->16. C语言-命令行环境<!----></a></li><li><a class="route-link nav-link vp-sidebar-link vp-sidebar-page" href="/DailyNotes/develop/C/17_multibyte.html" aria-label="17. C语言-多字节字符"><!---->17. C语言-多字节字符<!----></a></li></ul></section></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-header clickable" type="button"><!----><span class="vp-sidebar-title">C++笔记</span><span class="vp-arrow end"></span></button><!----></section></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-header clickable" type="button"><!----><span class="vp-sidebar-title">前端</span><span class="vp-arrow end"></span></button><!----></section></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-header clickable" type="button"><!----><span class="vp-sidebar-title">Go</span><span class="vp-arrow end"></span></button><!----></section></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-header clickable" type="button"><!----><span class="vp-sidebar-title">Java</span><span class="vp-arrow end"></span></button><!----></section></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-header clickable" type="button"><!----><span class="vp-sidebar-title">Other</span><span class="vp-arrow end"></span></button><!----></section></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-header clickable" type="button"><!----><span class="vp-sidebar-title">PHP</span><span class="vp-arrow end"></span></button><!----></section></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-header clickable" type="button"><!----><span class="vp-sidebar-title">Python</span><span class="vp-arrow end"></span></button><!----></section></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-header clickable" type="button"><!----><span class="vp-sidebar-title">Rust</span><span class="vp-arrow end"></span></button><!----></section></li></ul></section></li></ul><!--[--><!----><!--]--></aside><!--[--><main id="main-content" class="vp-page"><!--[--><!--[--><!----><!--]--><!----><nav class="vp-breadcrumb disable"></nav><div class="vp-page-title"><h1><!---->09. C语言-其他类型</h1><div class="page-info"><span class="page-author-info" aria-label="作者🖊" data-balloon-pos="down"><svg xmlns="http://www.w3.org/2000/svg" class="icon author-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="author icon"><path d="M649.6 633.6c86.4-48 147.2-144 147.2-249.6 0-160-128-288-288-288s-288 128-288 288c0 108.8 57.6 201.6 147.2 249.6-121.6 48-214.4 153.6-240 288-3.2 9.6 0 19.2 6.4 25.6 3.2 9.6 12.8 12.8 22.4 12.8h704c9.6 0 19.2-3.2 25.6-12.8 6.4-6.4 9.6-16 6.4-25.6-25.6-134.4-121.6-240-243.2-288z"></path></svg><span><span class="page-author-item">echo0d</span></span><span property="author" content="echo0d"></span></span><!----><span class="page-date-info" aria-label="写作日期📅" data-balloon-pos="down"><svg xmlns="http://www.w3.org/2000/svg" class="icon calendar-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="calendar icon"><path d="M716.4 110.137c0-18.753-14.72-33.473-33.472-33.473-18.753 0-33.473 14.72-33.473 33.473v33.473h66.993v-33.473zm-334.87 0c0-18.753-14.72-33.473-33.473-33.473s-33.52 14.72-33.52 33.473v33.473h66.993v-33.473zm468.81 33.52H716.4v100.465c0 18.753-14.72 33.473-33.472 33.473a33.145 33.145 0 01-33.473-33.473V143.657H381.53v100.465c0 18.753-14.72 33.473-33.473 33.473a33.145 33.145 0 01-33.473-33.473V143.657H180.6A134.314 134.314 0 0046.66 277.595v535.756A134.314 134.314 0 00180.6 947.289h669.74a134.36 134.36 0 00133.94-133.938V277.595a134.314 134.314 0 00-133.94-133.938zm33.473 267.877H147.126a33.145 33.145 0 01-33.473-33.473c0-18.752 14.72-33.473 33.473-33.473h736.687c18.752 0 33.472 14.72 33.472 33.473a33.145 33.145 0 01-33.472 33.473z"></path></svg><span><!----></span><meta property="datePublished" content="2025-02-08T09:10:02.000Z"></span><!----><span class="page-reading-time-info" aria-label="阅读时间⌛" data-balloon-pos="down"><svg xmlns="http://www.w3.org/2000/svg" class="icon timer-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="timer icon"><path d="M799.387 122.15c4.402-2.978 7.38-7.897 7.38-13.463v-1.165c0-8.933-7.38-16.312-16.312-16.312H256.33c-8.933 0-16.311 7.38-16.311 16.312v1.165c0 5.825 2.977 10.874 7.637 13.592 4.143 194.44 97.22 354.963 220.201 392.763-122.204 37.542-214.893 196.511-220.2 389.397-4.661 5.049-7.638 11.651-7.638 19.03v5.825h566.49v-5.825c0-7.379-2.849-13.981-7.509-18.9-5.049-193.016-97.867-351.985-220.2-389.527 123.24-37.67 216.446-198.453 220.588-392.892zM531.16 450.445v352.632c117.674 1.553 211.787 40.778 211.787 88.676H304.097c0-48.286 95.149-87.382 213.728-88.676V450.445c-93.077-3.107-167.901-81.297-167.901-177.093 0-8.803 6.99-15.793 15.793-15.793 8.803 0 15.794 6.99 15.794 15.793 0 80.261 63.69 145.635 142.01 145.635s142.011-65.374 142.011-145.635c0-8.803 6.99-15.793 15.794-15.793s15.793 6.99 15.793 15.793c0 95.019-73.789 172.82-165.96 177.093z"></path></svg><span>大约 22 分钟</span><meta property="timeRequired" content="PT22M"></span><span class="page-category-info" aria-label="分类🌈" data-balloon-pos="down"><svg xmlns="http://www.w3.org/2000/svg" class="icon category-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="category icon"><path d="M148.41 106.992h282.176c22.263 0 40.31 18.048 40.31 40.31V429.48c0 22.263-18.047 40.31-40.31 40.31H148.41c-22.263 0-40.311-18.047-40.311-40.31V147.302c0-22.263 18.048-40.31 40.311-40.31zM147.556 553.478H429.73c22.263 0 40.311 18.048 40.311 40.31v282.176c0 22.263-18.048 40.312-40.31 40.312H147.555c-22.263 0-40.311-18.049-40.311-40.312V593.79c0-22.263 18.048-40.311 40.31-40.311zM593.927 106.992h282.176c22.263 0 40.31 18.048 40.31 40.31V429.48c0 22.263-18.047 40.31-40.31 40.31H593.927c-22.263 0-40.311-18.047-40.311-40.31V147.302c0-22.263 18.048-40.31 40.31-40.31zM730.22 920.502H623.926c-40.925 0-74.22-33.388-74.22-74.425V623.992c0-41.038 33.387-74.424 74.425-74.424h222.085c41.038 0 74.424 33.226 74.424 74.067v114.233c0 10.244-8.304 18.548-18.547 18.548s-18.548-8.304-18.548-18.548V623.635c0-20.388-16.746-36.974-37.33-36.974H624.13c-20.585 0-37.331 16.747-37.331 37.33v222.086c0 20.585 16.654 37.331 37.126 37.331H730.22c10.243 0 18.547 8.304 18.547 18.547 0 10.244-8.304 18.547-18.547 18.547z"></path></svg><!--[--><span class="page-category-item category4 clickable" role="navigation">C</span><!--]--><meta property="articleSection" content="C"></span><!----></div><hr></div><div class="vp-toc-placeholder"><aside id="toc"><!--[--><!----><!--]--><div class="vp-toc-header">此页内容<button type="button" class="print-button" title="打印"><svg xmlns="http://www.w3.org/2000/svg" class="icon print-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="print icon"><path d="M819.2 364.8h-44.8V128c0-17.067-14.933-32-32-32H281.6c-17.067 0-32 14.933-32 32v236.8h-44.8C145.067 364.8 96 413.867 96 473.6v192c0 59.733 49.067 108.8 108.8 108.8h44.8V896c0 17.067 14.933 32 32 32h460.8c17.067 0 32-14.933 32-32V774.4h44.8c59.733 0 108.8-49.067 108.8-108.8v-192c0-59.733-49.067-108.8-108.8-108.8zM313.6 160h396.8v204.8H313.6V160zm396.8 704H313.6V620.8h396.8V864zM864 665.6c0 25.6-19.2 44.8-44.8 44.8h-44.8V588.8c0-17.067-14.933-32-32-32H281.6c-17.067 0-32 14.933-32 32v121.6h-44.8c-25.6 0-44.8-19.2-44.8-44.8v-192c0-25.6 19.2-44.8 44.8-44.8h614.4c25.6 0 44.8 19.2 44.8 44.8v192z"></path></svg></button><div class="arrow end"></div></div><div class="vp-toc-wrapper"><ul class="vp-toc-list"><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level2" href="#_1-typedef-命令">1 typedef 命令</a></li><li><ul class="vp-toc-list"><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#_1-1-简介">1.1 简介</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#_1-2-主要好处">1.2 主要好处</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level2" href="#_2-struct-结构">2 struct 结构</a></li><li><ul class="vp-toc-list"><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#_2-1-简介">2.1 简介</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#_2-2-struct-的复制">2.2 struct 的复制</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#_2-3-struct-指针">2.3 struct 指针</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#_2-4-struct-的嵌套">2.4 struct 的嵌套</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#_2-5-位字段">2.5 位字段</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#_2-6-弹性数组成员">2.6 弹性数组成员</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level2" href="#_3-union-结构">3 Union 结构</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level2" href="#_4-enum-类型">4 Enum 类型</a></li><!----><!--]--></ul><div class="vp-toc-marker" style="top:-1.7rem;"></div></div><!--[--><!----><!--]--></aside></div><!--[--><!----><!--]--><div class="theme-hope-content"><h1 id="_09-c语言-其他类型" tabindex="-1"><a class="header-anchor" href="#_09-c语言-其他类型"><span>09. C语言-其他类型</span></a></h1><h2 id="_1-typedef-命令" tabindex="-1"><a class="header-anchor" href="#_1-typedef-命令"><span>1 typedef 命令</span></a></h2><h3 id="_1-1-简介" tabindex="-1"><a class="header-anchor" href="#_1-1-简介"><span>1.1 简介</span></a></h3><p><code>typedef</code>命令用来为某个类型起别名。</p><pre><code class="language-c"><span class="token keyword">typedef</span> type name<span class="token punctuation">;</span>
</code></pre><p>上面代码中，<code>type</code>代表类型名，<code>name</code>代表别名。</p><pre><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">unsigned</span> <span class="token keyword">char</span> BYTE<span class="token punctuation">;</span>

BYTE c <span class="token operator">=</span> <span class="token char">&#39;z&#39;</span><span class="token punctuation">;</span>
</code></pre><p>上面示例中，<code>typedef</code>命令为类型<code>unsign char</code>起别名<code>BYTE</code>，然后就可以使用<code>BYTE</code>声明变量。</p><p>typedef 可以一次指定多个别名。</p><pre><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">int</span> antelope<span class="token punctuation">,</span> bagel<span class="token punctuation">,</span> mushroom<span class="token punctuation">;</span>
</code></pre><p>上面示例中，一次性为<code>int</code>类型起了三个别名。</p><p>typedef 可以为指针起别名。</p><pre><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">int</span><span class="token operator">*</span> intptr<span class="token punctuation">;</span>

<span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
intptr x <span class="token operator">=</span> <span class="token operator">&amp;</span>a<span class="token punctuation">;</span>
</code></pre><p>上面示例中，<code>intptr</code>是<code>int*</code>的别名。不过，使用的时候要小心，这样不容易看出来，变量<code>x</code>是一个指针类型。</p><p>typedef 也可以用来为数组类型起别名。</p><pre><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">int</span> five_ints<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

five_ints x <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">11</span><span class="token punctuation">,</span> <span class="token number">22</span><span class="token punctuation">,</span> <span class="token number">33</span><span class="token punctuation">,</span> <span class="token number">44</span><span class="token punctuation">,</span> <span class="token number">55</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><p>上面示例中，<code>five_ints</code>是一个数组类型，包含5个整数的</p><p>typedef 为函数起别名的写法如下。</p><pre><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">signed</span> <span class="token keyword">char</span> <span class="token punctuation">(</span><span class="token operator">*</span>fp<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><p>上面示例中，类型别名<code>fp</code>是一个指针，代表函数<code>signed char (*)(void)</code>。</p><h3 id="_1-2-主要好处" tabindex="-1"><a class="header-anchor" href="#_1-2-主要好处"><span>1.2 主要好处</span></a></h3><p><code>typedef</code>为类型起别名的好处，主要有下面几点。</p><p>（1）更好的代码可读性。</p><pre><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">char</span><span class="token operator">*</span> STRING<span class="token punctuation">;</span>

STRING name<span class="token punctuation">;</span>
</code></pre><p>上面示例为字符指针起别名为<code>STRING</code>，以后使用<code>STRING</code>声明变量时，就可以轻易辨别该变量是字符串。</p><p>（2）为 struct、union、enum 等命令定义的复杂数据结构创建别名，从而便于引用。</p><pre><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">treenode</span> <span class="token punctuation">{</span>
  <span class="token comment">// ...</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">treenode</span><span class="token operator">*</span> Tree<span class="token punctuation">;</span>
</code></pre><p>上面示例中，<code>Tree</code>为<code>struct treenode*</code>的别名。</p><p>typedef 也可以与 struct 定义数据类型的命令写在一起。</p><pre><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">animal</span> <span class="token punctuation">{</span>
  <span class="token keyword">char</span><span class="token operator">*</span> name<span class="token punctuation">;</span>
  <span class="token keyword">int</span> leg_count<span class="token punctuation">,</span> speed<span class="token punctuation">;</span>
<span class="token punctuation">}</span> animal<span class="token punctuation">;</span>
</code></pre><p>上面示例中，自定义数据类型时，同时使用<code>typedef</code>命令，为<code>struct animal</code>起了一个别名<code>animal</code>。</p><p>这种情况下，C 语言允许省略 struct 命令后面的类型名。</p><pre><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token punctuation">{</span>
  <span class="token keyword">char</span> <span class="token operator">*</span>name<span class="token punctuation">;</span>
  <span class="token keyword">int</span> leg_count<span class="token punctuation">,</span> speed<span class="token punctuation">;</span>
<span class="token punctuation">}</span> animal<span class="token punctuation">;</span>
</code></pre><p>上面示例相当于为一个匿名的数据类型起了别名<code>animal</code>。</p><p>（3）typedef 方便以后为变量改类型。</p><pre><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">float</span> app_float<span class="token punctuation">;</span>

app_float f1<span class="token punctuation">,</span> f2<span class="token punctuation">,</span> f3<span class="token punctuation">;</span>
</code></pre><p>上面示例中，变量<code>f1</code>、<code>f2</code>、<code>f3</code>的类型都是<code>float</code>。如果以后需要为它们改类型，只需要修改<code>typedef</code>语句即可。</p><pre><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">long</span> <span class="token keyword">double</span> app_float<span class="token punctuation">;</span>
</code></pre><p>上面命令将变量<code>f1</code>、<code>f2</code>、<code>f3</code>的类型都改为<code>long double</code>。</p><p>（4）可移植性</p><p>某一个值在不同计算机上的类型，可能是不一样的。</p><pre><code class="language-c"><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">100000</span><span class="token punctuation">;</span>
</code></pre><p>上面代码在32位整数的计算机没有问题，但是在16位整数的计算机就会出错。</p><p>C 语言的解决办法，就是提供了类型别名，在不同计算机上会解释成不同类型，比如<code>int32_t</code>。</p><pre><code class="language-c"><span class="token class-name">int32_t</span> i <span class="token operator">=</span> <span class="token number">100000</span><span class="token punctuation">;</span>
</code></pre><p>上面示例将变量<code>i</code>声明成<code>int32_t</code>类型，保证它在不同计算机上都是32位宽度，移植代码时就不会出错。</p><p>这一类的类型别名都是用 typedef 定义的。下面是类似的例子。</p><pre><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">long</span> <span class="token keyword">int</span> <span class="token class-name">ptrdiff_t</span><span class="token punctuation">;</span>
<span class="token keyword">typedef</span> <span class="token keyword">unsigned</span> <span class="token keyword">long</span> <span class="token keyword">int</span> <span class="token class-name">size_t</span><span class="token punctuation">;</span>
<span class="token keyword">typedef</span> <span class="token keyword">int</span> <span class="token class-name">wchar_t</span><span class="token punctuation">;</span>
</code></pre><p>这些整数类型别名都放在头文件<code>stdint.h</code>，不同架构的计算机只需修改这个头文件即可，而无需修改代码。</p><p>因此，<code>typedef</code>有助于提高代码的可移植性，使其能适配不同架构的计算机。</p><p>（5）简化类型声明</p><p>C 语言有些类型声明相当复杂，比如下面这个。</p><pre><code class="language-c"><span class="token keyword">char</span> <span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token function">x</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><p>typedef 可以简化复杂的类型声明，使其更容易理解。首先，最外面一层起一个类型别名。</p><pre><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">char</span> <span class="token punctuation">(</span><span class="token operator">*</span>Func<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">Func</span> <span class="token punctuation">(</span><span class="token operator">*</span><span class="token function">x</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
</code></pre><p>这个看起来还是有点复杂，就为里面一层也定义一个别名。</p><pre><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">char</span> <span class="token punctuation">(</span><span class="token operator">*</span>Func<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">typedef</span> Func Arr<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
Arr<span class="token operator">*</span> <span class="token function">x</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><p>上面代码就比较容易解读了。</p><ul><li><code>x</code>是一个函数，返回一个指向 Arr 类型的指针。</li><li><code>Arr</code>是一个数组，有5个成员，每个成员是<code>Func</code>类型。</li><li><code>Func</code>是一个函数指针，指向一个无参数、返回字符值的函数。</li></ul><h2 id="_2-struct-结构" tabindex="-1"><a class="header-anchor" href="#_2-struct-结构"><span>2 struct 结构</span></a></h2><h3 id="_2-1-简介" tabindex="-1"><a class="header-anchor" href="#_2-1-简介"><span>2.1 简介</span></a></h3><p>C 语言内置的数据类型，除了最基本的几种原始类型，只有数组属于复合类型，可以同时包含多个值，但是只能包含相同类型的数据，实际使用中并不够用。</p><p>实际使用中，主要有下面两种情况，需要更灵活强大的复合类型。</p><ul><li>复杂的物体需要使用多个变量描述，这些变量都是相关的，最好有某种机制将它们联系起来。</li><li>某些函数需要传入多个参数，如果一个个按照顺序传入，非常麻烦，最好能组合成一个复合结构传入。</li></ul><p>为了解决这些问题，C 语言提供了<code>struct</code>关键字，允许自定义复合数据类型，将不同类型的值组合在一起。这样不仅为编程提供方便，也有利于增强代码的可读性。C 语言没有其他语言的对象（object）和类（class）的概念，struct 结构很大程度上提供了对象和类的功能。</p><p>下面是<code>struct</code>自定义数据类型的一个例子。</p><pre><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">fraction</span> <span class="token punctuation">{</span>
  <span class="token keyword">int</span> numerator<span class="token punctuation">;</span>
  <span class="token keyword">int</span> denominator<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><p>上面示例定义了一个分数的数据类型<code>struct fraction</code>，包含两个属性<code>numerator</code>和<code>denominator</code>。</p><p>注意，作为一个自定义的数据类型，它的类型名要包括<code>struct</code>关键字，比如上例是<code>struct fraction</code>，单独的<code>fraction</code>没有任何意义，甚至脚本还可以另外定义名为<code>fraction</code>的变量，虽然这样很容易造成混淆。另外，<code>struct</code>语句结尾的分号不能省略，否则很容易产生错误。</p><p>定义了新的数据类型以后，就可以声明该类型的变量，这与声明其他类型变量的写法是一样的。</p><pre><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">fraction</span> f1<span class="token punctuation">;</span>

f1<span class="token punctuation">.</span>numerator <span class="token operator">=</span> <span class="token number">22</span><span class="token punctuation">;</span>
f1<span class="token punctuation">.</span>denominator <span class="token operator">=</span> <span class="token number">7</span><span class="token punctuation">;</span>
</code></pre><p>上面示例中，先声明了一个<code>struct fraction</code>类型的变量<code>f1</code>，这时编译器就会为<code>f1</code>分配内存，接着就可以为<code>f1</code>的不同属性赋值。可以看到，struct 结构的属性通过点（<code>.</code>）来表示，比如<code>numerator</code>属性要写成<code>f1.numerator</code>。</p><p>再提醒一下，声明自定义类型的变量时，类型名前面，不要忘记加上<code>struct</code>关键字。也就是说，必须使用<code>struct fraction f1</code>声明变量，不能写成<code>fraction f1</code>。</p><p>除了逐一对属性赋值，也可以使用大括号，一次性对 struct 结构的所有属性赋值。</p><pre><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">car</span> <span class="token punctuation">{</span>
  <span class="token keyword">char</span><span class="token operator">*</span> name<span class="token punctuation">;</span>
  <span class="token keyword">float</span> price<span class="token punctuation">;</span>
  <span class="token keyword">int</span> speed<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">struct</span> <span class="token class-name">car</span> saturn <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">&quot;Saturn SL/2&quot;</span><span class="token punctuation">,</span> <span class="token number">16000.99</span><span class="token punctuation">,</span> <span class="token number">175</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><p>上面示例中，变量<code>saturn</code>是<code>struct car</code>类型，大括号里面同时对它的三个属性赋值。如果大括号里面的值的数量，少于属性的数量，那么缺失的属性自动初始化为<code>0</code>。</p><p>注意，大括号里面的值的顺序，必须与 struct 类型声明时属性的顺序一致。否则，必须为每个值指定属性名。</p><pre><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">car</span> saturn <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">.</span>speed<span class="token operator">=</span><span class="token number">172</span><span class="token punctuation">,</span> <span class="token punctuation">.</span>name<span class="token operator">=</span><span class="token string">&quot;Saturn SL/2&quot;</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><p>上面示例中，初始化的属性少于声明时的属性，这时剩下的那些属性都会初始化为<code>0</code>。</p><p>声明变量以后，可以修改某个属性的值。</p><pre><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">car</span> saturn <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">.</span>speed<span class="token operator">=</span><span class="token number">172</span><span class="token punctuation">,</span> <span class="token punctuation">.</span>name<span class="token operator">=</span><span class="token string">&quot;Saturn SL/2&quot;</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
saturn<span class="token punctuation">.</span>speed <span class="token operator">=</span> <span class="token number">168</span><span class="token punctuation">;</span>
</code></pre><p>上面示例将<code>speed</code>属性的值改成<code>168</code>。</p><p>struct 的数据类型声明语句与变量的声明语句，可以合并为一个语句。</p><pre><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">book</span> <span class="token punctuation">{</span>
  <span class="token keyword">char</span> title<span class="token punctuation">[</span><span class="token number">500</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token keyword">char</span> author<span class="token punctuation">[</span><span class="token number">100</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token keyword">float</span> value<span class="token punctuation">;</span>
<span class="token punctuation">}</span> b1<span class="token punctuation">;</span>
</code></pre><p>上面的语句同时声明了数据类型<code>book</code>和该类型的变量<code>b1</code>。如果类型标识符<code>book</code>只用在这一个地方，后面不再用到，这里可以将类型名省略。</p><pre><code class="language-c"><span class="token keyword">struct</span> <span class="token punctuation">{</span>
  <span class="token keyword">char</span> title<span class="token punctuation">[</span><span class="token number">500</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token keyword">char</span> author<span class="token punctuation">[</span><span class="token number">100</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token keyword">float</span> value<span class="token punctuation">;</span>
<span class="token punctuation">}</span> b1<span class="token punctuation">;</span>
</code></pre><p>上面示例中，<code>struct</code>声明了一个匿名数据类型，然后又声明了这个类型的变量<code>b1</code>。</p><p>与其他变量声明语句一样，可以在声明变量的同时，对变量赋值。</p><pre><code class="language-c"><span class="token keyword">struct</span> <span class="token punctuation">{</span>
  <span class="token keyword">char</span> title<span class="token punctuation">[</span><span class="token number">500</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token keyword">char</span> author<span class="token punctuation">[</span><span class="token number">100</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token keyword">float</span> value<span class="token punctuation">;</span>
<span class="token punctuation">}</span> b1 <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">&quot;Harry Potter&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;J. K. Rowling&quot;</span><span class="token punctuation">,</span> <span class="token number">10.0</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
  b2 <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">&quot;Cancer Ward&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;Aleksandr Solzhenitsyn&quot;</span><span class="token punctuation">,</span> <span class="token number">7.85</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><p>上面示例中，在声明变量<code>b1</code>和<code>b2</code>的同时，为它们赋值。</p><p>下一章介绍的<code>typedef</code>命令可以为 struct 结构指定一个别名，这样使用起来更简洁。</p><pre><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">cell_phone</span> <span class="token punctuation">{</span>
  <span class="token keyword">int</span> cell_no<span class="token punctuation">;</span>
  <span class="token keyword">float</span> minutes_of_charge<span class="token punctuation">;</span>
<span class="token punctuation">}</span> phone<span class="token punctuation">;</span>

phone p <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">5551234</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><p>上面示例中，<code>phone</code>就是<code>struct cell_phone</code>的别名。</p><p>指针变量也可以指向<code>struct</code>结构。</p><pre><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">book</span> <span class="token punctuation">{</span>
  <span class="token keyword">char</span> title<span class="token punctuation">[</span><span class="token number">500</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token keyword">char</span> author<span class="token punctuation">[</span><span class="token number">100</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token keyword">float</span> value<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token operator">*</span> b1<span class="token punctuation">;</span>

<span class="token comment">// 或者写成两个语句</span>
<span class="token keyword">struct</span> <span class="token class-name">book</span> <span class="token punctuation">{</span>
  <span class="token keyword">char</span> title<span class="token punctuation">[</span><span class="token number">500</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token keyword">char</span> author<span class="token punctuation">[</span><span class="token number">100</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token keyword">float</span> value<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">struct</span> <span class="token class-name">book</span><span class="token operator">*</span> b1<span class="token punctuation">;</span>
</code></pre><p>上面示例中，变量<code>b1</code>是一个指针，指向的数据是<code>struct book</code>类型的实例。</p><p>struct 结构也可以作为数组成员。</p><pre><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">fraction</span> numbers<span class="token punctuation">[</span><span class="token number">1000</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

numbers<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>numerator <span class="token operator">=</span> <span class="token number">22</span><span class="token punctuation">;</span>
numbers<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>denominator <span class="token operator">=</span> <span class="token number">7</span><span class="token punctuation">;</span>
</code></pre><p>上面示例声明了一个有1000个成员的数组<code>numbers</code>，每个成员都是自定义类型<code>fraction</code>的实例。</p><p>struct 结构占用的存储空间，不是各个属性存储空间的总和，而是最大内存占用属性的存储空间的倍数，其他属性会添加空位与之对齐。这样可以提高读写效率。</p><pre><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">foo</span> <span class="token punctuation">{</span>
  <span class="token keyword">int</span> a<span class="token punctuation">;</span>
  <span class="token keyword">char</span><span class="token operator">*</span> b<span class="token punctuation">;</span>
  <span class="token keyword">char</span> c<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;%d\n&quot;</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">foo</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 24</span>
</code></pre><p>上面示例中，<code>struct foo</code>有三个属性，在64位计算机上占用的存储空间分别是：<code>int a</code>占4个字节，指针<code>char* b</code>占8个字节，<code>char c</code>占1个字节。它们加起来，一共是13个字节（4 + 8 + 1）。但是实际上，<code>struct foo</code>会占用24个字节，原因是它最大的内存占用属性是<code>char* b</code>的8个字节，导致其他属性的存储空间也是8个字节，这样才可以对齐，导致整个<code>struct foo</code>就是24个字节（8 * 3）。</p><p>多出来的存储空间，都采用空位填充，所以上面的<code>struct foo</code>真实的结构其实是下面这样。</p><pre><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">foo</span> <span class="token punctuation">{</span>
  <span class="token keyword">int</span> a<span class="token punctuation">;</span>        <span class="token comment">// 4</span>
  <span class="token keyword">char</span> pad1<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 填充4字节</span>
  <span class="token keyword">char</span> <span class="token operator">*</span>b<span class="token punctuation">;</span>      <span class="token comment">// 8</span>
  <span class="token keyword">char</span> c<span class="token punctuation">;</span>       <span class="token comment">// 1</span>
  <span class="token keyword">char</span> pad2<span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 填充7字节</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;%d\n&quot;</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">foo</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 24</span>
</code></pre><p>为什么浪费这么多空间进行内存对齐呢？这是为了加快读写速度，把内存占用划分成等长的区块，就可以快速在 Struct 结构体中定位到每个属性的起始地址。</p><p>由于这个特性，在有必要的情况下，定义 Struct 结构体时，可以采用存储空间递增的顺序，定义每个属性，这样就能节省一些空间。</p><pre><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">foo</span> <span class="token punctuation">{</span>
  <span class="token keyword">char</span> c<span class="token punctuation">;</span>
  <span class="token keyword">int</span> a<span class="token punctuation">;</span>
  <span class="token keyword">char</span><span class="token operator">*</span> b<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;%d\n&quot;</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">foo</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 16</span>
</code></pre><p>上面示例中，占用空间最小的<code>char c</code>排在第一位，其次是<code>int a</code>，占用空间最大的<code>char* b</code>排在最后。整个<code>strct foo</code>的内存占用就从24字节下降到16字节。</p><h3 id="_2-2-struct-的复制" tabindex="-1"><a class="header-anchor" href="#_2-2-struct-的复制"><span>2.2 struct 的复制</span></a></h3><p>struct 变量可以使用赋值运算符（<code>=</code>），复制给另一个变量，这时会生成一个全新的副本。系统会分配一块新的内存空间，大小与原来的变量相同，把每个属性都复制过去，即原样生成了一份数据。这一点跟数组的复制不一样，务必小心。</p><pre><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">cat</span> <span class="token punctuation">{</span> <span class="token keyword">char</span> name<span class="token punctuation">[</span><span class="token number">30</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token keyword">short</span> age<span class="token punctuation">;</span> <span class="token punctuation">}</span> a<span class="token punctuation">,</span> b<span class="token punctuation">;</span>

<span class="token function">strcpy</span><span class="token punctuation">(</span>a<span class="token punctuation">.</span>name<span class="token punctuation">,</span> <span class="token string">&quot;Hula&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
a<span class="token punctuation">.</span>age <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>

b <span class="token operator">=</span> a<span class="token punctuation">;</span>
b<span class="token punctuation">.</span>name<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token char">&#39;M&#39;</span><span class="token punctuation">;</span>

<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;%s\n&quot;</span><span class="token punctuation">,</span> a<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Hula</span>
<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;%s\n&quot;</span><span class="token punctuation">,</span> b<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Mula</span>
</code></pre><p>上面示例中，变量<code>b</code>是变量<code>a</code>的副本，两个变量的值是各自独立的，修改掉<code>b.name</code>不影响<code>a.name</code>。</p><p>上面这个示例是有前提的，就是 struct 结构的属性必须定义成字符数组，才能复制数据。如果稍作修改，属性定义成字符指针，结果就不一样。</p><pre><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">cat</span> <span class="token punctuation">{</span> <span class="token keyword">char</span><span class="token operator">*</span> name<span class="token punctuation">;</span> <span class="token keyword">short</span> age<span class="token punctuation">;</span> <span class="token punctuation">}</span> a<span class="token punctuation">,</span> b<span class="token punctuation">;</span>

a<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">&quot;Hula&quot;</span><span class="token punctuation">;</span>
a<span class="token punctuation">.</span>age <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>

b <span class="token operator">=</span> a<span class="token punctuation">;</span>
</code></pre><p>上面示例中，<code>name</code>属性变成了一个字符指针，这时<code>a</code>赋值给<code>b</code>，导致<code>b.name</code>也是同样的字符指针，指向同一个地址，也就是说两个属性共享同一个地址。因为这时，struct 结构内部保存的是一个指针，而不是上一个例子的数组，这时复制的就不是字符串本身，而是它的指针。并且，这个时候也没法修改字符串，因为字符指针指向的字符串是不能修改的。</p><p>总结一下，赋值运算符（<code>=</code>）可以将 struct 结构每个属性的值，一模一样复制一份，拷贝给另一个 struct 变量。这一点跟数组完全不同，使用赋值运算符复制数组，不会复制数据，只会共享地址。</p><p>注意，这种赋值要求两个变量是同一个类型，不同类型的 struct 变量无法互相赋值。</p><p>另外，C 语言没有提供比较两个自定义数据结构是否相等的方法，无法用比较运算符（比如<code>==</code>和<code>!=</code>）比较两个数据结构是否相等或不等。</p><h3 id="_2-3-struct-指针" tabindex="-1"><a class="header-anchor" href="#_2-3-struct-指针"><span>2.3 struct 指针</span></a></h3><p>如果将 struct 变量传入函数，函数内部得到的是一个原始值的副本。</p><pre><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>

<span class="token keyword">struct</span> <span class="token class-name">turtle</span> <span class="token punctuation">{</span>
  <span class="token keyword">char</span><span class="token operator">*</span> name<span class="token punctuation">;</span>
  <span class="token keyword">char</span><span class="token operator">*</span> species<span class="token punctuation">;</span>
  <span class="token keyword">int</span> age<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">void</span> <span class="token function">happy</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">turtle</span> t<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  t<span class="token punctuation">.</span>age <span class="token operator">=</span> t<span class="token punctuation">.</span>age <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">struct</span> <span class="token class-name">turtle</span> myTurtle <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">&quot;MyTurtle&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;sea turtle&quot;</span><span class="token punctuation">,</span> <span class="token number">99</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token function">happy</span><span class="token punctuation">(</span>myTurtle<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;Age is %i\n&quot;</span><span class="token punctuation">,</span> myTurtle<span class="token punctuation">.</span>age<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 输出 99</span>
  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><p>上面示例中，函数<code>happy()</code>传入的是一个 struct 变量<code>myTurtle</code>，函数内部有一个自增操作。但是，执行完<code>happy()</code>以后，函数外部的<code>age</code>属性值根本没变。原因就是函数内部得到的是 struct 变量的副本，改变副本影响不到函数外部的原始数据。</p><p>通常情况下，开发者希望传入函数的是同一份数据，函数内部修改数据以后，会反映在函数外部。而且，传入的是同一份数据，也有利于提高程序性能。这时就需要将 struct 变量的指针传入函数，通过指针来修改 struct 属性，就可以影响到函数外部。</p><p>struct 指针传入函数的写法如下。</p><pre><code class="language-c"><span class="token keyword">void</span> <span class="token function">happy</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">turtle</span><span class="token operator">*</span> t<span class="token punctuation">)</span> <span class="token punctuation">{</span>
<span class="token punctuation">}</span>

<span class="token function">happy</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>myTurtle<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><p>上面代码中，<code>t</code>是 struct 结构的指针，调用函数时传入的是指针。struct 类型跟数组不一样，类型标识符本身并不是指针，所以传入时，指针必须写成<code>&amp;myTurtle</code>。</p><p>函数内部也必须使用<code>(*t).age</code>的写法，从指针拿到 struct 结构本身。</p><pre><code class="language-c"><span class="token keyword">void</span> <span class="token function">happy</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">turtle</span><span class="token operator">*</span> t<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token punctuation">(</span><span class="token operator">*</span>t<span class="token punctuation">)</span><span class="token punctuation">.</span>age <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">*</span>t<span class="token punctuation">)</span><span class="token punctuation">.</span>age <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><p>上面示例中，<code>(*t).age</code>不能写成<code>*t.age</code>，因为点运算符<code>.</code>的优先级高于<code>*</code>。<code>*t.age</code>这种写法会将<code>t.age</code>看成一个指针，然后取它对应的值，会出现无法预料的结果。</p><p>现在，重新编译执行上面的整个示例，<code>happy()</code>内部对 struct 结构的操作，就会反映到函数外部。</p><p><code>(*t).age</code>这样的写法很麻烦。C 语言就引入了一个新的箭头运算符（<code>-&gt;</code>），可以从 struct 指针上直接获取属性，大大增强了代码的可读性。</p><pre><code class="language-c"><span class="token keyword">void</span> <span class="token function">happy</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">turtle</span><span class="token operator">*</span> t<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  t<span class="token operator">-&gt;</span>age <span class="token operator">=</span> t<span class="token operator">-&gt;</span>age <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><p>总结一下，对于 struct 变量名，使用点运算符（<code>.</code>）获取属性；对于 struct 变量指针，使用箭头运算符（<code>-&gt;</code>）获取属性。以变量<code>myStruct</code>为例，假设<code>ptr</code>是它的指针，那么下面三种写法是同一回事。</p><pre><code class="language-c"><span class="token comment">// ptr == &amp;myStruct</span>
myStruct<span class="token punctuation">.</span>prop <span class="token operator">==</span> <span class="token punctuation">(</span><span class="token operator">*</span>ptr<span class="token punctuation">)</span><span class="token punctuation">.</span>prop <span class="token operator">==</span> ptr<span class="token operator">-&gt;</span>prop
</code></pre><h3 id="_2-4-struct-的嵌套" tabindex="-1"><a class="header-anchor" href="#_2-4-struct-的嵌套"><span>2.4 struct 的嵌套</span></a></h3><p>struct 结构的成员可以是另一个 struct 结构。</p><pre><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">species</span> <span class="token punctuation">{</span>
  <span class="token keyword">char</span><span class="token operator">*</span> name<span class="token punctuation">;</span>
  <span class="token keyword">int</span> kinds<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">struct</span> <span class="token class-name">fish</span> <span class="token punctuation">{</span>
  <span class="token keyword">char</span><span class="token operator">*</span> name<span class="token punctuation">;</span>
  <span class="token keyword">int</span> age<span class="token punctuation">;</span>
  <span class="token keyword">struct</span> <span class="token class-name">species</span> breed<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><p>上面示例中，<code>fish</code>的属性<code>breed</code>是另一个 struct 结构<code>species</code>。</p><p>赋值的时候有多种写法。</p><pre><code class="language-c"><span class="token comment">// 写法一</span>
<span class="token keyword">struct</span> <span class="token class-name">fish</span> shark <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">&quot;shark&quot;</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token string">&quot;Selachimorpha&quot;</span><span class="token punctuation">,</span> <span class="token number">500</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// 写法二</span>
<span class="token keyword">struct</span> <span class="token class-name">species</span> myBreed <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">&quot;Selachimorpha&quot;</span><span class="token punctuation">,</span> <span class="token number">500</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">struct</span> <span class="token class-name">fish</span> shark <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">&quot;shark&quot;</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">,</span> myBreed<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// 写法三</span>
<span class="token keyword">struct</span> <span class="token class-name">fish</span> shark <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token punctuation">.</span>name<span class="token operator">=</span><span class="token string">&quot;shark&quot;</span><span class="token punctuation">,</span>
  <span class="token punctuation">.</span>age<span class="token operator">=</span><span class="token number">9</span><span class="token punctuation">,</span>
  <span class="token punctuation">.</span>breed<span class="token operator">=</span><span class="token punctuation">{</span><span class="token string">&quot;Selachimorpha&quot;</span><span class="token punctuation">,</span> <span class="token number">500</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// 写法四</span>
<span class="token keyword">struct</span> <span class="token class-name">fish</span> shark <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token punctuation">.</span>name<span class="token operator">=</span><span class="token string">&quot;shark&quot;</span><span class="token punctuation">,</span>
  <span class="token punctuation">.</span>age<span class="token operator">=</span><span class="token number">9</span><span class="token punctuation">,</span>
  <span class="token punctuation">.</span>breed<span class="token punctuation">.</span>name<span class="token operator">=</span><span class="token string">&quot;Selachimorpha&quot;</span><span class="token punctuation">,</span>
  <span class="token punctuation">.</span>breed<span class="token punctuation">.</span>kinds<span class="token operator">=</span><span class="token number">500</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;Shark&#39;s species is %s&quot;</span><span class="token punctuation">,</span> shark<span class="token punctuation">.</span>breed<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><p>上面示例展示了嵌套 Struct 结构的四种赋值写法。另外，引用<code>breed</code>属性的内部属性，要使用两次点运算符（<code>shark.breed.name</code>）。</p><p>下面是另一个嵌套 struct 的例子。</p><pre><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">name</span> <span class="token punctuation">{</span>
  <span class="token keyword">char</span> first<span class="token punctuation">[</span><span class="token number">50</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token keyword">char</span> last<span class="token punctuation">[</span><span class="token number">50</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">struct</span> <span class="token class-name">student</span> <span class="token punctuation">{</span>
  <span class="token keyword">struct</span> <span class="token class-name">name</span> name<span class="token punctuation">;</span>
  <span class="token keyword">short</span> age<span class="token punctuation">;</span>
  <span class="token keyword">char</span> sex<span class="token punctuation">;</span>
<span class="token punctuation">}</span> student1<span class="token punctuation">;</span>

<span class="token function">strcpy</span><span class="token punctuation">(</span>student1<span class="token punctuation">.</span>name<span class="token punctuation">.</span>first<span class="token punctuation">,</span> <span class="token string">&quot;Harry&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">strcpy</span><span class="token punctuation">(</span>student1<span class="token punctuation">.</span>name<span class="token punctuation">.</span>last<span class="token punctuation">,</span> <span class="token string">&quot;Potter&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// or</span>
<span class="token keyword">struct</span> <span class="token class-name">name</span> myname <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">&quot;Harry&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;Potter&quot;</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
student1<span class="token punctuation">.</span>name <span class="token operator">=</span> myname<span class="token punctuation">;</span>
</code></pre><p>上面示例中，自定义类型<code>student</code>的<code>name</code>属性是另一个自定义类型，如果要引用后者的属性，就必须使用两个<code>.</code>运算符，比如<code>student1.name.first</code>。另外，对字符数组属性赋值，要使用<code>strcpy()</code>函数，不能直接赋值，因为直接改掉字符数组名的地址会报错。</p><p>struct 结构内部不仅可以引用其他结构，还可以自我引用，即结构内部引用当前结构。比如，链表结构的节点就可以写成下面这样。</p><pre><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">node</span> <span class="token punctuation">{</span>
  <span class="token keyword">int</span> data<span class="token punctuation">;</span>
  <span class="token keyword">struct</span> <span class="token class-name">node</span><span class="token operator">*</span> next<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><p>上面示例中，<code>node</code>结构的<code>next</code>属性，就是指向另一个<code>node</code>实例的指针。下面，使用这个结构自定义一个数据链表。</p><pre><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">node</span> <span class="token punctuation">{</span>
  <span class="token keyword">int</span> data<span class="token punctuation">;</span>
  <span class="token keyword">struct</span> <span class="token class-name">node</span><span class="token operator">*</span> next<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">struct</span> <span class="token class-name">node</span><span class="token operator">*</span> head<span class="token punctuation">;</span>

<span class="token comment">// 生成一个三个节点的列表 (11)-&gt;(22)-&gt;(33)</span>
head <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">node</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

head<span class="token operator">-&gt;</span>data <span class="token operator">=</span> <span class="token number">11</span><span class="token punctuation">;</span>
head<span class="token operator">-&gt;</span>next <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">node</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

head<span class="token operator">-&gt;</span>next<span class="token operator">-&gt;</span>data <span class="token operator">=</span> <span class="token number">22</span><span class="token punctuation">;</span>
head<span class="token operator">-&gt;</span>next<span class="token operator">-&gt;</span>next <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">node</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

head<span class="token operator">-&gt;</span>next<span class="token operator">-&gt;</span>next<span class="token operator">-&gt;</span>data <span class="token operator">=</span> <span class="token number">33</span><span class="token punctuation">;</span>
head<span class="token operator">-&gt;</span>next<span class="token operator">-&gt;</span>next<span class="token operator">-&gt;</span>next <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>

<span class="token comment">// 遍历这个列表</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">node</span> <span class="token operator">*</span>cur <span class="token operator">=</span> head<span class="token punctuation">;</span> cur <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span> cur <span class="token operator">=</span> cur<span class="token operator">-&gt;</span>next<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;%d\n&quot;</span><span class="token punctuation">,</span> cur<span class="token operator">-&gt;</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><p>上面示例是链表结构的最简单实现，通过<code>for</code>循环可以对其进行遍历。</p><h3 id="_2-5-位字段" tabindex="-1"><a class="header-anchor" href="#_2-5-位字段"><span>2.5 位字段</span></a></h3><p>struct 还可以用来定义二进制位组成的数据结构，称为“位字段”（bit field），这对于操作底层的二进制数据非常有用。</p><pre><code class="language-c"><span class="token keyword">struct</span> <span class="token punctuation">{</span>
  <span class="token keyword">unsigned</span> <span class="token keyword">int</span> ab<span class="token operator">:</span><span class="token number">1</span><span class="token punctuation">;</span>
  <span class="token keyword">unsigned</span> <span class="token keyword">int</span> cd<span class="token operator">:</span><span class="token number">1</span><span class="token punctuation">;</span>
  <span class="token keyword">unsigned</span> <span class="token keyword">int</span> ef<span class="token operator">:</span><span class="token number">1</span><span class="token punctuation">;</span>
  <span class="token keyword">unsigned</span> <span class="token keyword">int</span> gh<span class="token operator">:</span><span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span> synth<span class="token punctuation">;</span>

synth<span class="token punctuation">.</span>ab <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
synth<span class="token punctuation">.</span>cd <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
</code></pre><p>上面示例中，每个属性后面的<code>:1</code>，表示指定这些属性只占用一个二进制位，所以这个数据结构一共是4个二进制位。</p><p>注意，定义二进制位时，结构内部的各个属性只能是整数类型。</p><p>实际存储的时候，C 语言会按照<code>int</code>类型占用的字节数，存储一个位字段结构。如果有剩余的二进制位，可以使用未命名属性，填满那些位。也可以使用宽度为0的属性，表示占满当前字节剩余的二进制位，迫使下一个属性存储在下一个字节。</p><pre><code class="language-c"><span class="token keyword">struct</span> <span class="token punctuation">{</span>
  <span class="token keyword">unsigned</span> <span class="token keyword">int</span> field1 <span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">;</span>
  <span class="token keyword">unsigned</span> <span class="token keyword">int</span>        <span class="token operator">:</span> <span class="token number">2</span><span class="token punctuation">;</span>
  <span class="token keyword">unsigned</span> <span class="token keyword">int</span> field2 <span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">;</span>
  <span class="token keyword">unsigned</span> <span class="token keyword">int</span>        <span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">;</span>
  <span class="token keyword">unsigned</span> <span class="token keyword">int</span> field3 <span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span> stuff<span class="token punctuation">;</span>
</code></pre><p>上面示例中，<code>stuff.field1</code>与<code>stuff.field2</code>之间，有一个宽度为两个二进制位的未命名属性。<code>stuff.field3</code>将存储在下一个字节。</p><h3 id="_2-6-弹性数组成员" tabindex="-1"><a class="header-anchor" href="#_2-6-弹性数组成员"><span>2.6 弹性数组成员</span></a></h3><p>很多时候，不能事先确定数组到底有多少个成员。如果声明数组的时候，事先给出一个很大的成员数，就会很浪费空间。C 语言提供了一个解决方法，叫做弹性数组成员（flexible array member）。</p><p>如果不能事先确定数组成员的数量时，可以定义一个 struct 结构。</p><pre><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">vstring</span> <span class="token punctuation">{</span>
  <span class="token keyword">int</span> len<span class="token punctuation">;</span>
  <span class="token keyword">char</span> chars<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><p>上面示例中，<code>struct vstring</code>结构有两个属性。<code>len</code>属性用来记录数组<code>chars</code>的长度，<code>chars</code>属性是一个数组，但是没有给出成员数量。</p><p><code>chars</code>数组到底有多少个成员，可以在为<code>vstring</code>分配内存时确定。</p><pre><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">vstring</span><span class="token operator">*</span> str <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">vstring</span><span class="token punctuation">)</span> <span class="token operator">+</span> n <span class="token operator">*</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
str<span class="token operator">-&gt;</span>len <span class="token operator">=</span> n<span class="token punctuation">;</span>
</code></pre><p>上面示例中，假定<code>chars</code>数组的成员数量是<code>n</code>，只有在运行时才能知道<code>n</code>到底是多少。然后，就为<code>struct vstring</code>分配它需要的内存：它本身占用的内存长度，再加上<code>n</code>个数组成员占用的内存长度。最后，<code>len</code>属性记录一下<code>n</code>是多少。</p><p>这样就可以让数组<code>chars</code>有<code>n</code>个成员，不用事先确定，可以跟运行时的需要保持一致。</p><p>弹性数组成员有一些专门的规则。首先，弹性成员的数组，必须是 struct 结构的最后一个属性。另外，除了弹性数组成员，struct 结构必须至少还有一个其他属性。</p><h2 id="_3-union-结构" tabindex="-1"><a class="header-anchor" href="#_3-union-结构"><span>3 Union 结构</span></a></h2><p>有时需要一种数据结构，不同的场合表示不同的数据类型。比如，如果只用一种数据结构表示水果的“量”，这种结构就需要有时是整数（6个苹果），有时是浮点数（1.5公斤草莓）。</p><p>C 语言提供了 Union 结构，用来自定义可以灵活变更的数据结构。它内部包含各种属性，但是所有属性共用一块内存，导致这些属性都是对同一个二进制数据的解读，其中往往只有一个属性的解读是有意义的。并且，后面写入的属性会覆盖前面的属性，这意味着同一块内存，可以先供某一个属性使用，然后再供另一个属性使用。这样做的最大好处是节省内存空间。</p><pre><code class="language-c"><span class="token keyword">union</span> quantity <span class="token punctuation">{</span>
  <span class="token keyword">short</span> count<span class="token punctuation">;</span>
  <span class="token keyword">float</span> weight<span class="token punctuation">;</span>
  <span class="token keyword">float</span> volume<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><p>上面示例中，<code>union</code>命令定义了一个包含三个属性的数据类型<code>quantity</code>。虽然包含三个属性，但是只能写入一个值，三个属性都是对这个值的不同解读。最后赋值的属性，往往就是可以取到有意义的值的那个属性。</p><p>使用时，声明一个该类型的变量。</p><pre><code class="language-c"><span class="token comment">// 写法一</span>
<span class="token keyword">union</span> quantity q<span class="token punctuation">;</span>
q<span class="token punctuation">.</span>count <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">;</span>

<span class="token comment">// 写法二</span>
<span class="token keyword">union</span> quantity q <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">.</span>count<span class="token operator">=</span><span class="token number">4</span><span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// 写法三</span>
<span class="token keyword">union</span> quantity q <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">4</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><p>上面代码展示了为 Union 结构赋值的三种写法。最后一种写法不指定属性名，就会赋值给第一个属性。</p><p>执行完上面的代码以后，<code>q.count</code>可以取到值，另外两个属性取不到值。</p><pre><code class="language-c"><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;count is %i\n&quot;</span><span class="token punctuation">,</span> q<span class="token punctuation">.</span>count<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// count is 4</span>
<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;weight is %f\n&quot;</span><span class="token punctuation">,</span> q<span class="token punctuation">.</span>weight<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 未定义行为</span>
</code></pre><p>如果要让<code>q.weight</code>属性可以取到值，就要先为它赋值。</p><pre><code class="language-c">q<span class="token punctuation">.</span>weight <span class="token operator">=</span> <span class="token number">0.5</span><span class="token punctuation">;</span>
<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;weight is %f\n&quot;</span><span class="token punctuation">,</span> q<span class="token punctuation">.</span>weight<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// weight is 0.5</span>
</code></pre><p>一旦为其他属性赋值，原先可以取到值的<code>q.count</code>属性就跟着改变，使用它可能就没有意义了。除了这一点，Union 结构的其他用法与 Struct 结构，基本上是一致的。</p><p>Union 结构也支持指针运算符<code>-&gt;</code>。</p><pre><code class="language-c"><span class="token keyword">union</span> quantity <span class="token punctuation">{</span>
  <span class="token keyword">short</span> count<span class="token punctuation">;</span>
  <span class="token keyword">float</span> weight<span class="token punctuation">;</span>
  <span class="token keyword">float</span> volume<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">union</span> quantity q<span class="token punctuation">;</span>
q<span class="token punctuation">.</span>count <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">;</span>

<span class="token keyword">union</span> quantity<span class="token operator">*</span> ptr<span class="token punctuation">;</span>
ptr <span class="token operator">=</span> <span class="token operator">&amp;</span>q<span class="token punctuation">;</span>

<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;%d\n&quot;</span><span class="token punctuation">,</span> ptr<span class="token operator">-&gt;</span>count<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 4</span>
</code></pre><p>上面示例中，<code>ptr</code>是<code>q</code>的指针，那么<code>ptr-&gt;count</code>等同于<code>q.count</code>。</p><p>Union 结构指针与它的属性有关，当前正在按照哪个属性解读数据，它的指针就是对应的数据类型。</p><pre><code class="language-c"><span class="token keyword">union</span> foo <span class="token punctuation">{</span>
  <span class="token keyword">int</span> a<span class="token punctuation">;</span>
  <span class="token keyword">float</span> b<span class="token punctuation">;</span>
<span class="token punctuation">}</span> x<span class="token punctuation">;</span>

<span class="token keyword">int</span><span class="token operator">*</span> foo_int_p <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>x<span class="token punctuation">;</span>
<span class="token keyword">float</span><span class="token operator">*</span> foo_float_p <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">float</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>x<span class="token punctuation">;</span>

x<span class="token punctuation">.</span>a <span class="token operator">=</span> <span class="token number">12</span><span class="token punctuation">;</span>
<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;%d\n&quot;</span><span class="token punctuation">,</span> x<span class="token punctuation">.</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>           <span class="token comment">// 12</span>
<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;%d\n&quot;</span><span class="token punctuation">,</span> <span class="token operator">*</span>foo_int_p<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 12</span>

x<span class="token punctuation">.</span>b <span class="token operator">=</span> <span class="token number">3.141592</span><span class="token punctuation">;</span>
<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;%f\n&quot;</span><span class="token punctuation">,</span> x<span class="token punctuation">.</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>           <span class="token comment">// 3.141592</span>
<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;%f\n&quot;</span><span class="token punctuation">,</span> <span class="token operator">*</span>foo_float_p<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 3.141592</span>
</code></pre><p>上面示例中，<code>&amp;x</code>是 foo 结构的指针，它的数据类型完全由当前赋值的属性决定。</p><p>typedef 命令可以为 Union 数据类型起别名。</p><pre><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">union</span> <span class="token punctuation">{</span>
  <span class="token keyword">short</span> count<span class="token punctuation">;</span>
  <span class="token keyword">float</span> weight<span class="token punctuation">;</span>
  <span class="token keyword">float</span> volume<span class="token punctuation">;</span>
<span class="token punctuation">}</span> quantity<span class="token punctuation">;</span>
</code></pre><p>上面示例中，<code>union</code>命令定义了一个包含三个属性的数据类型，<code>typedef</code>命令为它起别名为<code>quantity</code>。</p><p>Union 结构的好处，主要是节省空间。它将一段内存空间，重用于不同类型的数据。定义了三个属性，但同一时间只用到一个，使用 Union 结构就可以节省另外两个属性的空间。Union 结构占用的内存长度，等于它内部最长属性的长度。</p><h2 id="_4-enum-类型" tabindex="-1"><a class="header-anchor" href="#_4-enum-类型"><span>4 Enum 类型</span></a></h2><p>如果一种数据类型的取值只有少数几种可能，并且每种取值都有自己的含义，为了提高代码的可读性，可以将它们定义为 Enum 类型，中文名为枚举。</p><pre><code class="language-c"><span class="token keyword">enum</span> <span class="token class-name">colors</span> <span class="token punctuation">{</span>RED<span class="token punctuation">,</span> GREEN<span class="token punctuation">,</span> BLUE<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;%d\n&quot;</span><span class="token punctuation">,</span> RED<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 0</span>
<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;%d\n&quot;</span><span class="token punctuation">,</span> GREEN<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 1</span>
<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;%d\n&quot;</span><span class="token punctuation">,</span> BLUE<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 2</span>
</code></pre><p>上面示例中，假定程序里面需要三种颜色，就可以使用<code>enum</code>命令，把这三种颜色定义成一种枚举类型<code>colors</code>，它只有三种取值可能<code>RED</code>、<code>GREEN</code>、<code>BLUE</code>。这时，这三个名字自动成为整数常量，编译器默认将它们的值设为数字<code>0</code>、<code>1</code>、<code>2</code>。相比之下，<code>RED</code>要比<code>0</code>的可读性好了许多。</p><p>注意，Enum 内部的常量名，遵守标识符的命名规范，但是通常都使用大写。</p><p>使用时，可以将变量声明为 Enum 类型。</p><pre><code class="language-c"><span class="token keyword">enum</span> <span class="token class-name">colors</span> color<span class="token punctuation">;</span>
</code></pre><p>上面代码将变量<code>color</code>声明为<code>enum colors</code>类型。这个变量的值就是常量<code>RED</code>、<code>GREEN</code>、<code>BLUE</code>之中的一个。</p><pre><code class="language-c">color <span class="token operator">=</span> BLUE<span class="token punctuation">;</span>
<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;%i\n&quot;</span><span class="token punctuation">,</span> color<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 2</span>
</code></pre><p>上面代码将变量<code>color</code>的值设为<code>BLUE</code>，这里<code>BLUE</code>就是一个常量，值等于<code>2</code>。</p><p>typedef 命令可以为 Enum 类型起别名。</p><pre><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">enum</span> <span class="token punctuation">{</span>
  SHEEP<span class="token punctuation">,</span>
  WHEAT<span class="token punctuation">,</span>
  WOOD<span class="token punctuation">,</span>
  BRICK<span class="token punctuation">,</span>
  ORE
<span class="token punctuation">}</span> RESOURCE<span class="token punctuation">;</span>

RESOURCE r<span class="token punctuation">;</span>
</code></pre><p>上面示例中，<code>RESOURCE</code>是 Enum 类型的别名。声明变量时，使用这个别名即可。</p><p>还有一种不常见的写法，就是声明 Enum 类型时，在同一行里面为变量赋值。</p><pre><code class="language-c"><span class="token keyword">enum</span> <span class="token punctuation">{</span>
  SHEEP<span class="token punctuation">,</span>
  WHEAT<span class="token punctuation">,</span>
  WOOD<span class="token punctuation">,</span>
  BRICK<span class="token punctuation">,</span>
  ORE
<span class="token punctuation">}</span> r <span class="token operator">=</span> BRICK<span class="token punctuation">,</span> s <span class="token operator">=</span> WOOD<span class="token punctuation">;</span>
</code></pre><p>上面示例中，<code>r</code>的值是<code>3</code>，<code>s</code>的值是<code>2</code>。</p><p>由于 Enum 的属性会自动声明为常量，所以有时候使用 Enum 的目的，不是为了自定义一种数据类型，而是为了声明一组常量。这时就可以使用下面这种写法，比较简单。</p><pre><code class="language-c"><span class="token keyword">enum</span> <span class="token punctuation">{</span> ONE<span class="token punctuation">,</span> TWO <span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;%d %d&quot;</span><span class="token punctuation">,</span> ONE<span class="token punctuation">,</span> TWO<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 0 1</span>
</code></pre><p>上面示例中，<code>enum</code>是一个关键字，后面跟着一个代码块，常量就在代码内声明。<code>ONE</code>和<code>TWO</code>就是两个 Enum 常量。</p><p>常量之间使用逗号分隔。最后一个常量后面的尾逗号，可以省略，也可以保留。</p><pre><code class="language-c"><span class="token keyword">enum</span> <span class="token punctuation">{</span> ONE<span class="token punctuation">,</span> TWO<span class="token punctuation">,</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><p>由于Enum 会自动编号，因此可以不必为常量赋值。C 语言会自动从0开始递增，为常量赋值。但是，C 语言也允许为 ENUM 常量指定值，不过只能指定为整数，不能是其他类型。因此，任何可以使用整数的场合，都可以使用 Enum 常量。</p><pre><code class="language-c"><span class="token keyword">enum</span> <span class="token punctuation">{</span> ONE <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> TWO <span class="token operator">=</span> <span class="token number">2</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;%d %d&quot;</span><span class="token punctuation">,</span> ONE<span class="token punctuation">,</span> TWO<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 1 2</span>
</code></pre><p>Enum 常量可以是不连续的值。</p><pre><code class="language-c"><span class="token keyword">enum</span> <span class="token punctuation">{</span> X <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">,</span> Y <span class="token operator">=</span> <span class="token number">18</span><span class="token punctuation">,</span> Z <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">2</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><p>Enum 常量也可以是同一个值。</p><pre><code class="language-c"><span class="token keyword">enum</span> <span class="token punctuation">{</span> X <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">,</span> Y <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">,</span> Z <span class="token operator">=</span> <span class="token number">2</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><p>如果一组常量之中，有些指定了值，有些没有指定。那么，没有指定值的常量会从上一个指定了值的常量，开始自动递增赋值。</p><pre><code class="language-c"><span class="token keyword">enum</span> <span class="token punctuation">{</span>
  A<span class="token punctuation">,</span>    <span class="token comment">// 0</span>
  B<span class="token punctuation">,</span>    <span class="token comment">// 1</span>
  C <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">,</span>  <span class="token comment">// 4</span>
  D<span class="token punctuation">,</span>    <span class="token comment">// 5</span>
  E<span class="token punctuation">,</span>    <span class="token comment">// 6</span>
  F <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">,</span>   <span class="token comment">// 3</span>
  G<span class="token punctuation">,</span>    <span class="token comment">// 4</span>
  H     <span class="token comment">// 5</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><p>Enum 的作用域与变量相同。如果是在顶层声明，那么在整个文件内都有效；如果是在代码块内部声明，则只对该代码块有效。如果与使用<code>int</code>声明的常量相比，Enum 的好处是更清晰地表示代码意图。</p></div><!--[--><!----><!--]--><footer class="page-meta"><div class="meta-item edit-link"><a href="https://github.com/echo0d/DailyNotes/edit/main/src/develop/C/9_otherType.md" rel="noopener noreferrer" target="_blank" aria-label="在 GitHub 上编辑此页" class="nav-link label"><!--[--><svg xmlns="http://www.w3.org/2000/svg" class="icon edit-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="edit icon"><path d="M430.818 653.65a60.46 60.46 0 0 1-50.96-93.281l71.69-114.012 7.773-10.365L816.038 80.138A60.46 60.46 0 0 1 859.225 62a60.46 60.46 0 0 1 43.186 18.138l43.186 43.186a60.46 60.46 0 0 1 0 86.373L588.879 565.55l-8.637 8.637-117.466 68.234a60.46 60.46 0 0 1-31.958 11.229z"></path><path d="M728.802 962H252.891A190.883 190.883 0 0 1 62.008 771.98V296.934a190.883 190.883 0 0 1 190.883-192.61h267.754a60.46 60.46 0 0 1 0 120.92H252.891a69.962 69.962 0 0 0-69.098 69.099V771.98a69.962 69.962 0 0 0 69.098 69.098h475.911A69.962 69.962 0 0 0 797.9 771.98V503.363a60.46 60.46 0 1 1 120.922 0V771.98A190.883 190.883 0 0 1 728.802 962z"></path></svg><!--]-->在 GitHub 上编辑此页<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span><!----></a></div><div class="meta-item git-info"><div class="update-time"><span class="label">上次编辑于: </span><!----></div><div class="contributors"><span class="label">贡献者: </span><!--[--><!--[--><span class="contributor" title="email: echo0d@163.com">echo0d</span><!--]--><!--]--></div></div></footer><nav class="vp-page-nav"><a class="route-link nav-link prev" href="/DailyNotes/develop/C/8_string.html" aria-label="08. C语言-字符串"><div class="hint"><span class="arrow start"></span>上一页</div><div class="link"><!---->08. C语言-字符串</div></a><a class="route-link nav-link next" href="/DailyNotes/develop/C/10_memory.html" aria-label="10. C语言-内存管理"><div class="hint">下一页<span class="arrow end"></span></div><div class="link">10. C语言-内存管理<!----></div></a></nav><!----><!--[--><!----><!--]--><!--]--></main><!--]--><footer class="vp-footer-wrapper"><div class="vp-footer">听君一席话，如听一席话</div><div class="vp-copyright">Copyright © 2025 echo0d </div></footer></div><!--]--><!--[--><!----><!----><!--]--><!--]--></div>
    <script type="module" src="/DailyNotes/assets/app-vU8izl1I.js" defer></script>
  </body>
</html>
