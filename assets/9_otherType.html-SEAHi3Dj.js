import{_ as s}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as a,b as p,o as t}from"./app-BDHo8HdU.js";const o={};function e(c,n){return t(),a("div",null,[...n[0]||(n[0]=[p(`<h1 id="_09-c语言-其他类型" tabindex="-1"><a class="header-anchor" href="#_09-c语言-其他类型"><span>09. C语言-其他类型</span></a></h1><h2 id="_1-typedef-命令" tabindex="-1"><a class="header-anchor" href="#_1-typedef-命令"><span>1 typedef 命令</span></a></h2><h3 id="_1-1-简介" tabindex="-1"><a class="header-anchor" href="#_1-1-简介"><span>1.1 简介</span></a></h3><p><code>typedef</code>命令用来为某个类型起别名。</p><pre><code class="language-c"><span class="token keyword">typedef</span> type name<span class="token punctuation">;</span>
</code></pre><p>上面代码中，<code>type</code>代表类型名，<code>name</code>代表别名。</p><pre><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">unsigned</span> <span class="token keyword">char</span> BYTE<span class="token punctuation">;</span>

BYTE c <span class="token operator">=</span> <span class="token char">&#39;z&#39;</span><span class="token punctuation">;</span>
</code></pre><p>上面示例中，<code>typedef</code>命令为类型<code>unsign char</code>起别名<code>BYTE</code>，然后就可以使用<code>BYTE</code>声明变量。</p><p>typedef 可以一次指定多个别名。</p><pre><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">int</span> antelope<span class="token punctuation">,</span> bagel<span class="token punctuation">,</span> mushroom<span class="token punctuation">;</span>
</code></pre><p>上面示例中，一次性为<code>int</code>类型起了三个别名。</p><p>typedef 可以为指针起别名。</p><pre><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">int</span><span class="token operator">*</span> intptr<span class="token punctuation">;</span>

<span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
intptr x <span class="token operator">=</span> <span class="token operator">&amp;</span>a<span class="token punctuation">;</span>
</code></pre><p>上面示例中，<code>intptr</code>是<code>int*</code>的别名。不过，使用的时候要小心，这样不容易看出来，变量<code>x</code>是一个指针类型。</p><p>typedef 也可以用来为数组类型起别名。</p><pre><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">int</span> five_ints<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

five_ints x <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">11</span><span class="token punctuation">,</span> <span class="token number">22</span><span class="token punctuation">,</span> <span class="token number">33</span><span class="token punctuation">,</span> <span class="token number">44</span><span class="token punctuation">,</span> <span class="token number">55</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><p>上面示例中，<code>five_ints</code>是一个数组类型，包含5个整数的</p><p>typedef 为函数起别名的写法如下。</p><pre><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">signed</span> <span class="token keyword">char</span> <span class="token punctuation">(</span><span class="token operator">*</span>fp<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><p>上面示例中，类型别名<code>fp</code>是一个指针，代表函数<code>signed char (*)(void)</code>。</p><h3 id="_1-2-主要好处" tabindex="-1"><a class="header-anchor" href="#_1-2-主要好处"><span>1.2 主要好处</span></a></h3><p><code>typedef</code>为类型起别名的好处，主要有下面几点。</p><p>（1）更好的代码可读性。</p><pre><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">char</span><span class="token operator">*</span> STRING<span class="token punctuation">;</span>

STRING name<span class="token punctuation">;</span>
</code></pre><p>上面示例为字符指针起别名为<code>STRING</code>，以后使用<code>STRING</code>声明变量时，就可以轻易辨别该变量是字符串。</p><p>（2）为 struct、union、enum 等命令定义的复杂数据结构创建别名，从而便于引用。</p><pre><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">treenode</span> <span class="token punctuation">{</span>
  <span class="token comment">// ...</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">treenode</span><span class="token operator">*</span> Tree<span class="token punctuation">;</span>
</code></pre><p>上面示例中，<code>Tree</code>为<code>struct treenode*</code>的别名。</p><p>typedef 也可以与 struct 定义数据类型的命令写在一起。</p><pre><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">animal</span> <span class="token punctuation">{</span>
  <span class="token keyword">char</span><span class="token operator">*</span> name<span class="token punctuation">;</span>
  <span class="token keyword">int</span> leg_count<span class="token punctuation">,</span> speed<span class="token punctuation">;</span>
<span class="token punctuation">}</span> animal<span class="token punctuation">;</span>
</code></pre><p>上面示例中，自定义数据类型时，同时使用<code>typedef</code>命令，为<code>struct animal</code>起了一个别名<code>animal</code>。</p><p>这种情况下，C 语言允许省略 struct 命令后面的类型名。</p><pre><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token punctuation">{</span>
  <span class="token keyword">char</span> <span class="token operator">*</span>name<span class="token punctuation">;</span>
  <span class="token keyword">int</span> leg_count<span class="token punctuation">,</span> speed<span class="token punctuation">;</span>
<span class="token punctuation">}</span> animal<span class="token punctuation">;</span>
</code></pre><p>上面示例相当于为一个匿名的数据类型起了别名<code>animal</code>。</p><p>（3）typedef 方便以后为变量改类型。</p><pre><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">float</span> app_float<span class="token punctuation">;</span>

app_float f1<span class="token punctuation">,</span> f2<span class="token punctuation">,</span> f3<span class="token punctuation">;</span>
</code></pre><p>上面示例中，变量<code>f1</code>、<code>f2</code>、<code>f3</code>的类型都是<code>float</code>。如果以后需要为它们改类型，只需要修改<code>typedef</code>语句即可。</p><pre><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">long</span> <span class="token keyword">double</span> app_float<span class="token punctuation">;</span>
</code></pre><p>上面命令将变量<code>f1</code>、<code>f2</code>、<code>f3</code>的类型都改为<code>long double</code>。</p><p>（4）可移植性</p><p>某一个值在不同计算机上的类型，可能是不一样的。</p><pre><code class="language-c"><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">100000</span><span class="token punctuation">;</span>
</code></pre><p>上面代码在32位整数的计算机没有问题，但是在16位整数的计算机就会出错。</p><p>C 语言的解决办法，就是提供了类型别名，在不同计算机上会解释成不同类型，比如<code>int32_t</code>。</p><pre><code class="language-c"><span class="token class-name">int32_t</span> i <span class="token operator">=</span> <span class="token number">100000</span><span class="token punctuation">;</span>
</code></pre><p>上面示例将变量<code>i</code>声明成<code>int32_t</code>类型，保证它在不同计算机上都是32位宽度，移植代码时就不会出错。</p><p>这一类的类型别名都是用 typedef 定义的。下面是类似的例子。</p><pre><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">long</span> <span class="token keyword">int</span> <span class="token class-name">ptrdiff_t</span><span class="token punctuation">;</span>
<span class="token keyword">typedef</span> <span class="token keyword">unsigned</span> <span class="token keyword">long</span> <span class="token keyword">int</span> <span class="token class-name">size_t</span><span class="token punctuation">;</span>
<span class="token keyword">typedef</span> <span class="token keyword">int</span> <span class="token class-name">wchar_t</span><span class="token punctuation">;</span>
</code></pre><p>这些整数类型别名都放在头文件<code>stdint.h</code>，不同架构的计算机只需修改这个头文件即可，而无需修改代码。</p><p>因此，<code>typedef</code>有助于提高代码的可移植性，使其能适配不同架构的计算机。</p><p>（5）简化类型声明</p><p>C 语言有些类型声明相当复杂，比如下面这个。</p><pre><code class="language-c"><span class="token keyword">char</span> <span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token function">x</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><p>typedef 可以简化复杂的类型声明，使其更容易理解。首先，最外面一层起一个类型别名。</p><pre><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">char</span> <span class="token punctuation">(</span><span class="token operator">*</span>Func<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">Func</span> <span class="token punctuation">(</span><span class="token operator">*</span><span class="token function">x</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
</code></pre><p>这个看起来还是有点复杂，就为里面一层也定义一个别名。</p><pre><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">char</span> <span class="token punctuation">(</span><span class="token operator">*</span>Func<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">typedef</span> Func Arr<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
Arr<span class="token operator">*</span> <span class="token function">x</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><p>上面代码就比较容易解读了。</p><ul><li><code>x</code>是一个函数，返回一个指向 Arr 类型的指针。</li><li><code>Arr</code>是一个数组，有5个成员，每个成员是<code>Func</code>类型。</li><li><code>Func</code>是一个函数指针，指向一个无参数、返回字符值的函数。</li></ul><h2 id="_2-struct-结构" tabindex="-1"><a class="header-anchor" href="#_2-struct-结构"><span>2 struct 结构</span></a></h2><h3 id="_2-1-简介" tabindex="-1"><a class="header-anchor" href="#_2-1-简介"><span>2.1 简介</span></a></h3><p>C 语言内置的数据类型，除了最基本的几种原始类型，只有数组属于复合类型，可以同时包含多个值，但是只能包含相同类型的数据，实际使用中并不够用。</p><p>实际使用中，主要有下面两种情况，需要更灵活强大的复合类型。</p><ul><li>复杂的物体需要使用多个变量描述，这些变量都是相关的，最好有某种机制将它们联系起来。</li><li>某些函数需要传入多个参数，如果一个个按照顺序传入，非常麻烦，最好能组合成一个复合结构传入。</li></ul><p>为了解决这些问题，C 语言提供了<code>struct</code>关键字，允许自定义复合数据类型，将不同类型的值组合在一起。这样不仅为编程提供方便，也有利于增强代码的可读性。C 语言没有其他语言的对象（object）和类（class）的概念，struct 结构很大程度上提供了对象和类的功能。</p><p>下面是<code>struct</code>自定义数据类型的一个例子。</p><pre><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">fraction</span> <span class="token punctuation">{</span>
  <span class="token keyword">int</span> numerator<span class="token punctuation">;</span>
  <span class="token keyword">int</span> denominator<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><p>上面示例定义了一个分数的数据类型<code>struct fraction</code>，包含两个属性<code>numerator</code>和<code>denominator</code>。</p><p>注意，作为一个自定义的数据类型，它的类型名要包括<code>struct</code>关键字，比如上例是<code>struct fraction</code>，单独的<code>fraction</code>没有任何意义，甚至脚本还可以另外定义名为<code>fraction</code>的变量，虽然这样很容易造成混淆。另外，<code>struct</code>语句结尾的分号不能省略，否则很容易产生错误。</p><p>定义了新的数据类型以后，就可以声明该类型的变量，这与声明其他类型变量的写法是一样的。</p><pre><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">fraction</span> f1<span class="token punctuation">;</span>

f1<span class="token punctuation">.</span>numerator <span class="token operator">=</span> <span class="token number">22</span><span class="token punctuation">;</span>
f1<span class="token punctuation">.</span>denominator <span class="token operator">=</span> <span class="token number">7</span><span class="token punctuation">;</span>
</code></pre><p>上面示例中，先声明了一个<code>struct fraction</code>类型的变量<code>f1</code>，这时编译器就会为<code>f1</code>分配内存，接着就可以为<code>f1</code>的不同属性赋值。可以看到，struct 结构的属性通过点（<code>.</code>）来表示，比如<code>numerator</code>属性要写成<code>f1.numerator</code>。</p><p>再提醒一下，声明自定义类型的变量时，类型名前面，不要忘记加上<code>struct</code>关键字。也就是说，必须使用<code>struct fraction f1</code>声明变量，不能写成<code>fraction f1</code>。</p><p>除了逐一对属性赋值，也可以使用大括号，一次性对 struct 结构的所有属性赋值。</p><pre><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">car</span> <span class="token punctuation">{</span>
  <span class="token keyword">char</span><span class="token operator">*</span> name<span class="token punctuation">;</span>
  <span class="token keyword">float</span> price<span class="token punctuation">;</span>
  <span class="token keyword">int</span> speed<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">struct</span> <span class="token class-name">car</span> saturn <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">&quot;Saturn SL/2&quot;</span><span class="token punctuation">,</span> <span class="token number">16000.99</span><span class="token punctuation">,</span> <span class="token number">175</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><p>上面示例中，变量<code>saturn</code>是<code>struct car</code>类型，大括号里面同时对它的三个属性赋值。如果大括号里面的值的数量，少于属性的数量，那么缺失的属性自动初始化为<code>0</code>。</p><p>注意，大括号里面的值的顺序，必须与 struct 类型声明时属性的顺序一致。否则，必须为每个值指定属性名。</p><pre><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">car</span> saturn <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">.</span>speed<span class="token operator">=</span><span class="token number">172</span><span class="token punctuation">,</span> <span class="token punctuation">.</span>name<span class="token operator">=</span><span class="token string">&quot;Saturn SL/2&quot;</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><p>上面示例中，初始化的属性少于声明时的属性，这时剩下的那些属性都会初始化为<code>0</code>。</p><p>声明变量以后，可以修改某个属性的值。</p><pre><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">car</span> saturn <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">.</span>speed<span class="token operator">=</span><span class="token number">172</span><span class="token punctuation">,</span> <span class="token punctuation">.</span>name<span class="token operator">=</span><span class="token string">&quot;Saturn SL/2&quot;</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
saturn<span class="token punctuation">.</span>speed <span class="token operator">=</span> <span class="token number">168</span><span class="token punctuation">;</span>
</code></pre><p>上面示例将<code>speed</code>属性的值改成<code>168</code>。</p><p>struct 的数据类型声明语句与变量的声明语句，可以合并为一个语句。</p><pre><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">book</span> <span class="token punctuation">{</span>
  <span class="token keyword">char</span> title<span class="token punctuation">[</span><span class="token number">500</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token keyword">char</span> author<span class="token punctuation">[</span><span class="token number">100</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token keyword">float</span> value<span class="token punctuation">;</span>
<span class="token punctuation">}</span> b1<span class="token punctuation">;</span>
</code></pre><p>上面的语句同时声明了数据类型<code>book</code>和该类型的变量<code>b1</code>。如果类型标识符<code>book</code>只用在这一个地方，后面不再用到，这里可以将类型名省略。</p><pre><code class="language-c"><span class="token keyword">struct</span> <span class="token punctuation">{</span>
  <span class="token keyword">char</span> title<span class="token punctuation">[</span><span class="token number">500</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token keyword">char</span> author<span class="token punctuation">[</span><span class="token number">100</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token keyword">float</span> value<span class="token punctuation">;</span>
<span class="token punctuation">}</span> b1<span class="token punctuation">;</span>
</code></pre><p>上面示例中，<code>struct</code>声明了一个匿名数据类型，然后又声明了这个类型的变量<code>b1</code>。</p><p>与其他变量声明语句一样，可以在声明变量的同时，对变量赋值。</p><pre><code class="language-c"><span class="token keyword">struct</span> <span class="token punctuation">{</span>
  <span class="token keyword">char</span> title<span class="token punctuation">[</span><span class="token number">500</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token keyword">char</span> author<span class="token punctuation">[</span><span class="token number">100</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token keyword">float</span> value<span class="token punctuation">;</span>
<span class="token punctuation">}</span> b1 <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">&quot;Harry Potter&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;J. K. Rowling&quot;</span><span class="token punctuation">,</span> <span class="token number">10.0</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
  b2 <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">&quot;Cancer Ward&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;Aleksandr Solzhenitsyn&quot;</span><span class="token punctuation">,</span> <span class="token number">7.85</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><p>上面示例中，在声明变量<code>b1</code>和<code>b2</code>的同时，为它们赋值。</p><p>下一章介绍的<code>typedef</code>命令可以为 struct 结构指定一个别名，这样使用起来更简洁。</p><pre><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">cell_phone</span> <span class="token punctuation">{</span>
  <span class="token keyword">int</span> cell_no<span class="token punctuation">;</span>
  <span class="token keyword">float</span> minutes_of_charge<span class="token punctuation">;</span>
<span class="token punctuation">}</span> phone<span class="token punctuation">;</span>

phone p <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">5551234</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><p>上面示例中，<code>phone</code>就是<code>struct cell_phone</code>的别名。</p><p>指针变量也可以指向<code>struct</code>结构。</p><pre><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">book</span> <span class="token punctuation">{</span>
  <span class="token keyword">char</span> title<span class="token punctuation">[</span><span class="token number">500</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token keyword">char</span> author<span class="token punctuation">[</span><span class="token number">100</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token keyword">float</span> value<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token operator">*</span> b1<span class="token punctuation">;</span>

<span class="token comment">// 或者写成两个语句</span>
<span class="token keyword">struct</span> <span class="token class-name">book</span> <span class="token punctuation">{</span>
  <span class="token keyword">char</span> title<span class="token punctuation">[</span><span class="token number">500</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token keyword">char</span> author<span class="token punctuation">[</span><span class="token number">100</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token keyword">float</span> value<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">struct</span> <span class="token class-name">book</span><span class="token operator">*</span> b1<span class="token punctuation">;</span>
</code></pre><p>上面示例中，变量<code>b1</code>是一个指针，指向的数据是<code>struct book</code>类型的实例。</p><p>struct 结构也可以作为数组成员。</p><pre><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">fraction</span> numbers<span class="token punctuation">[</span><span class="token number">1000</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

numbers<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>numerator <span class="token operator">=</span> <span class="token number">22</span><span class="token punctuation">;</span>
numbers<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>denominator <span class="token operator">=</span> <span class="token number">7</span><span class="token punctuation">;</span>
</code></pre><p>上面示例声明了一个有1000个成员的数组<code>numbers</code>，每个成员都是自定义类型<code>fraction</code>的实例。</p><p>struct 结构占用的存储空间，不是各个属性存储空间的总和，而是最大内存占用属性的存储空间的倍数，其他属性会添加空位与之对齐。这样可以提高读写效率。</p><pre><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">foo</span> <span class="token punctuation">{</span>
  <span class="token keyword">int</span> a<span class="token punctuation">;</span>
  <span class="token keyword">char</span><span class="token operator">*</span> b<span class="token punctuation">;</span>
  <span class="token keyword">char</span> c<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;%d\\n&quot;</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">foo</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 24</span>
</code></pre><p>上面示例中，<code>struct foo</code>有三个属性，在64位计算机上占用的存储空间分别是：<code>int a</code>占4个字节，指针<code>char* b</code>占8个字节，<code>char c</code>占1个字节。它们加起来，一共是13个字节（4 + 8 + 1）。但是实际上，<code>struct foo</code>会占用24个字节，原因是它最大的内存占用属性是<code>char* b</code>的8个字节，导致其他属性的存储空间也是8个字节，这样才可以对齐，导致整个<code>struct foo</code>就是24个字节（8 * 3）。</p><p>多出来的存储空间，都采用空位填充，所以上面的<code>struct foo</code>真实的结构其实是下面这样。</p><pre><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">foo</span> <span class="token punctuation">{</span>
  <span class="token keyword">int</span> a<span class="token punctuation">;</span>        <span class="token comment">// 4</span>
  <span class="token keyword">char</span> pad1<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 填充4字节</span>
  <span class="token keyword">char</span> <span class="token operator">*</span>b<span class="token punctuation">;</span>      <span class="token comment">// 8</span>
  <span class="token keyword">char</span> c<span class="token punctuation">;</span>       <span class="token comment">// 1</span>
  <span class="token keyword">char</span> pad2<span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 填充7字节</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;%d\\n&quot;</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">foo</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 24</span>
</code></pre><p>为什么浪费这么多空间进行内存对齐呢？这是为了加快读写速度，把内存占用划分成等长的区块，就可以快速在 Struct 结构体中定位到每个属性的起始地址。</p><p>由于这个特性，在有必要的情况下，定义 Struct 结构体时，可以采用存储空间递增的顺序，定义每个属性，这样就能节省一些空间。</p><pre><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">foo</span> <span class="token punctuation">{</span>
  <span class="token keyword">char</span> c<span class="token punctuation">;</span>
  <span class="token keyword">int</span> a<span class="token punctuation">;</span>
  <span class="token keyword">char</span><span class="token operator">*</span> b<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;%d\\n&quot;</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">foo</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 16</span>
</code></pre><p>上面示例中，占用空间最小的<code>char c</code>排在第一位，其次是<code>int a</code>，占用空间最大的<code>char* b</code>排在最后。整个<code>strct foo</code>的内存占用就从24字节下降到16字节。</p><h3 id="_2-2-struct-的复制" tabindex="-1"><a class="header-anchor" href="#_2-2-struct-的复制"><span>2.2 struct 的复制</span></a></h3><p>struct 变量可以使用赋值运算符（<code>=</code>），复制给另一个变量，这时会生成一个全新的副本。系统会分配一块新的内存空间，大小与原来的变量相同，把每个属性都复制过去，即原样生成了一份数据。这一点跟数组的复制不一样，务必小心。</p><pre><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">cat</span> <span class="token punctuation">{</span> <span class="token keyword">char</span> name<span class="token punctuation">[</span><span class="token number">30</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token keyword">short</span> age<span class="token punctuation">;</span> <span class="token punctuation">}</span> a<span class="token punctuation">,</span> b<span class="token punctuation">;</span>

<span class="token function">strcpy</span><span class="token punctuation">(</span>a<span class="token punctuation">.</span>name<span class="token punctuation">,</span> <span class="token string">&quot;Hula&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
a<span class="token punctuation">.</span>age <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>

b <span class="token operator">=</span> a<span class="token punctuation">;</span>
b<span class="token punctuation">.</span>name<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token char">&#39;M&#39;</span><span class="token punctuation">;</span>

<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;%s\\n&quot;</span><span class="token punctuation">,</span> a<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Hula</span>
<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;%s\\n&quot;</span><span class="token punctuation">,</span> b<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Mula</span>
</code></pre><p>上面示例中，变量<code>b</code>是变量<code>a</code>的副本，两个变量的值是各自独立的，修改掉<code>b.name</code>不影响<code>a.name</code>。</p><p>上面这个示例是有前提的，就是 struct 结构的属性必须定义成字符数组，才能复制数据。如果稍作修改，属性定义成字符指针，结果就不一样。</p><pre><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">cat</span> <span class="token punctuation">{</span> <span class="token keyword">char</span><span class="token operator">*</span> name<span class="token punctuation">;</span> <span class="token keyword">short</span> age<span class="token punctuation">;</span> <span class="token punctuation">}</span> a<span class="token punctuation">,</span> b<span class="token punctuation">;</span>

a<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">&quot;Hula&quot;</span><span class="token punctuation">;</span>
a<span class="token punctuation">.</span>age <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>

b <span class="token operator">=</span> a<span class="token punctuation">;</span>
</code></pre><p>上面示例中，<code>name</code>属性变成了一个字符指针，这时<code>a</code>赋值给<code>b</code>，导致<code>b.name</code>也是同样的字符指针，指向同一个地址，也就是说两个属性共享同一个地址。因为这时，struct 结构内部保存的是一个指针，而不是上一个例子的数组，这时复制的就不是字符串本身，而是它的指针。并且，这个时候也没法修改字符串，因为字符指针指向的字符串是不能修改的。</p><p>总结一下，赋值运算符（<code>=</code>）可以将 struct 结构每个属性的值，一模一样复制一份，拷贝给另一个 struct 变量。这一点跟数组完全不同，使用赋值运算符复制数组，不会复制数据，只会共享地址。</p><p>注意，这种赋值要求两个变量是同一个类型，不同类型的 struct 变量无法互相赋值。</p><p>另外，C 语言没有提供比较两个自定义数据结构是否相等的方法，无法用比较运算符（比如<code>==</code>和<code>!=</code>）比较两个数据结构是否相等或不等。</p><h3 id="_2-3-struct-指针" tabindex="-1"><a class="header-anchor" href="#_2-3-struct-指针"><span>2.3 struct 指针</span></a></h3><p>如果将 struct 变量传入函数，函数内部得到的是一个原始值的副本。</p><pre><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>

<span class="token keyword">struct</span> <span class="token class-name">turtle</span> <span class="token punctuation">{</span>
  <span class="token keyword">char</span><span class="token operator">*</span> name<span class="token punctuation">;</span>
  <span class="token keyword">char</span><span class="token operator">*</span> species<span class="token punctuation">;</span>
  <span class="token keyword">int</span> age<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">void</span> <span class="token function">happy</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">turtle</span> t<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  t<span class="token punctuation">.</span>age <span class="token operator">=</span> t<span class="token punctuation">.</span>age <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">struct</span> <span class="token class-name">turtle</span> myTurtle <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">&quot;MyTurtle&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;sea turtle&quot;</span><span class="token punctuation">,</span> <span class="token number">99</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token function">happy</span><span class="token punctuation">(</span>myTurtle<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;Age is %i\\n&quot;</span><span class="token punctuation">,</span> myTurtle<span class="token punctuation">.</span>age<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 输出 99</span>
  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><p>上面示例中，函数<code>happy()</code>传入的是一个 struct 变量<code>myTurtle</code>，函数内部有一个自增操作。但是，执行完<code>happy()</code>以后，函数外部的<code>age</code>属性值根本没变。原因就是函数内部得到的是 struct 变量的副本，改变副本影响不到函数外部的原始数据。</p><p>通常情况下，开发者希望传入函数的是同一份数据，函数内部修改数据以后，会反映在函数外部。而且，传入的是同一份数据，也有利于提高程序性能。这时就需要将 struct 变量的指针传入函数，通过指针来修改 struct 属性，就可以影响到函数外部。</p><p>struct 指针传入函数的写法如下。</p><pre><code class="language-c"><span class="token keyword">void</span> <span class="token function">happy</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">turtle</span><span class="token operator">*</span> t<span class="token punctuation">)</span> <span class="token punctuation">{</span>
<span class="token punctuation">}</span>

<span class="token function">happy</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>myTurtle<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><p>上面代码中，<code>t</code>是 struct 结构的指针，调用函数时传入的是指针。struct 类型跟数组不一样，类型标识符本身并不是指针，所以传入时，指针必须写成<code>&amp;myTurtle</code>。</p><p>函数内部也必须使用<code>(*t).age</code>的写法，从指针拿到 struct 结构本身。</p><pre><code class="language-c"><span class="token keyword">void</span> <span class="token function">happy</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">turtle</span><span class="token operator">*</span> t<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token punctuation">(</span><span class="token operator">*</span>t<span class="token punctuation">)</span><span class="token punctuation">.</span>age <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">*</span>t<span class="token punctuation">)</span><span class="token punctuation">.</span>age <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><p>上面示例中，<code>(*t).age</code>不能写成<code>*t.age</code>，因为点运算符<code>.</code>的优先级高于<code>*</code>。<code>*t.age</code>这种写法会将<code>t.age</code>看成一个指针，然后取它对应的值，会出现无法预料的结果。</p><p>现在，重新编译执行上面的整个示例，<code>happy()</code>内部对 struct 结构的操作，就会反映到函数外部。</p><p><code>(*t).age</code>这样的写法很麻烦。C 语言就引入了一个新的箭头运算符（<code>-&gt;</code>），可以从 struct 指针上直接获取属性，大大增强了代码的可读性。</p><pre><code class="language-c"><span class="token keyword">void</span> <span class="token function">happy</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">turtle</span><span class="token operator">*</span> t<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  t<span class="token operator">-&gt;</span>age <span class="token operator">=</span> t<span class="token operator">-&gt;</span>age <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><p>总结一下，对于 struct 变量名，使用点运算符（<code>.</code>）获取属性；对于 struct 变量指针，使用箭头运算符（<code>-&gt;</code>）获取属性。以变量<code>myStruct</code>为例，假设<code>ptr</code>是它的指针，那么下面三种写法是同一回事。</p><pre><code class="language-c"><span class="token comment">// ptr == &amp;myStruct</span>
myStruct<span class="token punctuation">.</span>prop <span class="token operator">==</span> <span class="token punctuation">(</span><span class="token operator">*</span>ptr<span class="token punctuation">)</span><span class="token punctuation">.</span>prop <span class="token operator">==</span> ptr<span class="token operator">-&gt;</span>prop
</code></pre><h3 id="_2-4-struct-的嵌套" tabindex="-1"><a class="header-anchor" href="#_2-4-struct-的嵌套"><span>2.4 struct 的嵌套</span></a></h3><p>struct 结构的成员可以是另一个 struct 结构。</p><pre><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">species</span> <span class="token punctuation">{</span>
  <span class="token keyword">char</span><span class="token operator">*</span> name<span class="token punctuation">;</span>
  <span class="token keyword">int</span> kinds<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">struct</span> <span class="token class-name">fish</span> <span class="token punctuation">{</span>
  <span class="token keyword">char</span><span class="token operator">*</span> name<span class="token punctuation">;</span>
  <span class="token keyword">int</span> age<span class="token punctuation">;</span>
  <span class="token keyword">struct</span> <span class="token class-name">species</span> breed<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><p>上面示例中，<code>fish</code>的属性<code>breed</code>是另一个 struct 结构<code>species</code>。</p><p>赋值的时候有多种写法。</p><pre><code class="language-c"><span class="token comment">// 写法一</span>
<span class="token keyword">struct</span> <span class="token class-name">fish</span> shark <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">&quot;shark&quot;</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token string">&quot;Selachimorpha&quot;</span><span class="token punctuation">,</span> <span class="token number">500</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// 写法二</span>
<span class="token keyword">struct</span> <span class="token class-name">species</span> myBreed <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">&quot;Selachimorpha&quot;</span><span class="token punctuation">,</span> <span class="token number">500</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">struct</span> <span class="token class-name">fish</span> shark <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">&quot;shark&quot;</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">,</span> myBreed<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// 写法三</span>
<span class="token keyword">struct</span> <span class="token class-name">fish</span> shark <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token punctuation">.</span>name<span class="token operator">=</span><span class="token string">&quot;shark&quot;</span><span class="token punctuation">,</span>
  <span class="token punctuation">.</span>age<span class="token operator">=</span><span class="token number">9</span><span class="token punctuation">,</span>
  <span class="token punctuation">.</span>breed<span class="token operator">=</span><span class="token punctuation">{</span><span class="token string">&quot;Selachimorpha&quot;</span><span class="token punctuation">,</span> <span class="token number">500</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// 写法四</span>
<span class="token keyword">struct</span> <span class="token class-name">fish</span> shark <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token punctuation">.</span>name<span class="token operator">=</span><span class="token string">&quot;shark&quot;</span><span class="token punctuation">,</span>
  <span class="token punctuation">.</span>age<span class="token operator">=</span><span class="token number">9</span><span class="token punctuation">,</span>
  <span class="token punctuation">.</span>breed<span class="token punctuation">.</span>name<span class="token operator">=</span><span class="token string">&quot;Selachimorpha&quot;</span><span class="token punctuation">,</span>
  <span class="token punctuation">.</span>breed<span class="token punctuation">.</span>kinds<span class="token operator">=</span><span class="token number">500</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;Shark&#39;s species is %s&quot;</span><span class="token punctuation">,</span> shark<span class="token punctuation">.</span>breed<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><p>上面示例展示了嵌套 Struct 结构的四种赋值写法。另外，引用<code>breed</code>属性的内部属性，要使用两次点运算符（<code>shark.breed.name</code>）。</p><p>下面是另一个嵌套 struct 的例子。</p><pre><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">name</span> <span class="token punctuation">{</span>
  <span class="token keyword">char</span> first<span class="token punctuation">[</span><span class="token number">50</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token keyword">char</span> last<span class="token punctuation">[</span><span class="token number">50</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">struct</span> <span class="token class-name">student</span> <span class="token punctuation">{</span>
  <span class="token keyword">struct</span> <span class="token class-name">name</span> name<span class="token punctuation">;</span>
  <span class="token keyword">short</span> age<span class="token punctuation">;</span>
  <span class="token keyword">char</span> sex<span class="token punctuation">;</span>
<span class="token punctuation">}</span> student1<span class="token punctuation">;</span>

<span class="token function">strcpy</span><span class="token punctuation">(</span>student1<span class="token punctuation">.</span>name<span class="token punctuation">.</span>first<span class="token punctuation">,</span> <span class="token string">&quot;Harry&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">strcpy</span><span class="token punctuation">(</span>student1<span class="token punctuation">.</span>name<span class="token punctuation">.</span>last<span class="token punctuation">,</span> <span class="token string">&quot;Potter&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// or</span>
<span class="token keyword">struct</span> <span class="token class-name">name</span> myname <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">&quot;Harry&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;Potter&quot;</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
student1<span class="token punctuation">.</span>name <span class="token operator">=</span> myname<span class="token punctuation">;</span>
</code></pre><p>上面示例中，自定义类型<code>student</code>的<code>name</code>属性是另一个自定义类型，如果要引用后者的属性，就必须使用两个<code>.</code>运算符，比如<code>student1.name.first</code>。另外，对字符数组属性赋值，要使用<code>strcpy()</code>函数，不能直接赋值，因为直接改掉字符数组名的地址会报错。</p><p>struct 结构内部不仅可以引用其他结构，还可以自我引用，即结构内部引用当前结构。比如，链表结构的节点就可以写成下面这样。</p><pre><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">node</span> <span class="token punctuation">{</span>
  <span class="token keyword">int</span> data<span class="token punctuation">;</span>
  <span class="token keyword">struct</span> <span class="token class-name">node</span><span class="token operator">*</span> next<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><p>上面示例中，<code>node</code>结构的<code>next</code>属性，就是指向另一个<code>node</code>实例的指针。下面，使用这个结构自定义一个数据链表。</p><pre><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">node</span> <span class="token punctuation">{</span>
  <span class="token keyword">int</span> data<span class="token punctuation">;</span>
  <span class="token keyword">struct</span> <span class="token class-name">node</span><span class="token operator">*</span> next<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">struct</span> <span class="token class-name">node</span><span class="token operator">*</span> head<span class="token punctuation">;</span>

<span class="token comment">// 生成一个三个节点的列表 (11)-&gt;(22)-&gt;(33)</span>
head <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">node</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

head<span class="token operator">-&gt;</span>data <span class="token operator">=</span> <span class="token number">11</span><span class="token punctuation">;</span>
head<span class="token operator">-&gt;</span>next <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">node</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

head<span class="token operator">-&gt;</span>next<span class="token operator">-&gt;</span>data <span class="token operator">=</span> <span class="token number">22</span><span class="token punctuation">;</span>
head<span class="token operator">-&gt;</span>next<span class="token operator">-&gt;</span>next <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">node</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

head<span class="token operator">-&gt;</span>next<span class="token operator">-&gt;</span>next<span class="token operator">-&gt;</span>data <span class="token operator">=</span> <span class="token number">33</span><span class="token punctuation">;</span>
head<span class="token operator">-&gt;</span>next<span class="token operator">-&gt;</span>next<span class="token operator">-&gt;</span>next <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>

<span class="token comment">// 遍历这个列表</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">node</span> <span class="token operator">*</span>cur <span class="token operator">=</span> head<span class="token punctuation">;</span> cur <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span> cur <span class="token operator">=</span> cur<span class="token operator">-&gt;</span>next<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;%d\\n&quot;</span><span class="token punctuation">,</span> cur<span class="token operator">-&gt;</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><p>上面示例是链表结构的最简单实现，通过<code>for</code>循环可以对其进行遍历。</p><h3 id="_2-5-位字段" tabindex="-1"><a class="header-anchor" href="#_2-5-位字段"><span>2.5 位字段</span></a></h3><p>struct 还可以用来定义二进制位组成的数据结构，称为“位字段”（bit field），这对于操作底层的二进制数据非常有用。</p><pre><code class="language-c"><span class="token keyword">struct</span> <span class="token punctuation">{</span>
  <span class="token keyword">unsigned</span> <span class="token keyword">int</span> ab<span class="token operator">:</span><span class="token number">1</span><span class="token punctuation">;</span>
  <span class="token keyword">unsigned</span> <span class="token keyword">int</span> cd<span class="token operator">:</span><span class="token number">1</span><span class="token punctuation">;</span>
  <span class="token keyword">unsigned</span> <span class="token keyword">int</span> ef<span class="token operator">:</span><span class="token number">1</span><span class="token punctuation">;</span>
  <span class="token keyword">unsigned</span> <span class="token keyword">int</span> gh<span class="token operator">:</span><span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span> synth<span class="token punctuation">;</span>

synth<span class="token punctuation">.</span>ab <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
synth<span class="token punctuation">.</span>cd <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
</code></pre><p>上面示例中，每个属性后面的<code>:1</code>，表示指定这些属性只占用一个二进制位，所以这个数据结构一共是4个二进制位。</p><p>注意，定义二进制位时，结构内部的各个属性只能是整数类型。</p><p>实际存储的时候，C 语言会按照<code>int</code>类型占用的字节数，存储一个位字段结构。如果有剩余的二进制位，可以使用未命名属性，填满那些位。也可以使用宽度为0的属性，表示占满当前字节剩余的二进制位，迫使下一个属性存储在下一个字节。</p><pre><code class="language-c"><span class="token keyword">struct</span> <span class="token punctuation">{</span>
  <span class="token keyword">unsigned</span> <span class="token keyword">int</span> field1 <span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">;</span>
  <span class="token keyword">unsigned</span> <span class="token keyword">int</span>        <span class="token operator">:</span> <span class="token number">2</span><span class="token punctuation">;</span>
  <span class="token keyword">unsigned</span> <span class="token keyword">int</span> field2 <span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">;</span>
  <span class="token keyword">unsigned</span> <span class="token keyword">int</span>        <span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">;</span>
  <span class="token keyword">unsigned</span> <span class="token keyword">int</span> field3 <span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span> stuff<span class="token punctuation">;</span>
</code></pre><p>上面示例中，<code>stuff.field1</code>与<code>stuff.field2</code>之间，有一个宽度为两个二进制位的未命名属性。<code>stuff.field3</code>将存储在下一个字节。</p><h3 id="_2-6-弹性数组成员" tabindex="-1"><a class="header-anchor" href="#_2-6-弹性数组成员"><span>2.6 弹性数组成员</span></a></h3><p>很多时候，不能事先确定数组到底有多少个成员。如果声明数组的时候，事先给出一个很大的成员数，就会很浪费空间。C 语言提供了一个解决方法，叫做弹性数组成员（flexible array member）。</p><p>如果不能事先确定数组成员的数量时，可以定义一个 struct 结构。</p><pre><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">vstring</span> <span class="token punctuation">{</span>
  <span class="token keyword">int</span> len<span class="token punctuation">;</span>
  <span class="token keyword">char</span> chars<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><p>上面示例中，<code>struct vstring</code>结构有两个属性。<code>len</code>属性用来记录数组<code>chars</code>的长度，<code>chars</code>属性是一个数组，但是没有给出成员数量。</p><p><code>chars</code>数组到底有多少个成员，可以在为<code>vstring</code>分配内存时确定。</p><pre><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">vstring</span><span class="token operator">*</span> str <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">vstring</span><span class="token punctuation">)</span> <span class="token operator">+</span> n <span class="token operator">*</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
str<span class="token operator">-&gt;</span>len <span class="token operator">=</span> n<span class="token punctuation">;</span>
</code></pre><p>上面示例中，假定<code>chars</code>数组的成员数量是<code>n</code>，只有在运行时才能知道<code>n</code>到底是多少。然后，就为<code>struct vstring</code>分配它需要的内存：它本身占用的内存长度，再加上<code>n</code>个数组成员占用的内存长度。最后，<code>len</code>属性记录一下<code>n</code>是多少。</p><p>这样就可以让数组<code>chars</code>有<code>n</code>个成员，不用事先确定，可以跟运行时的需要保持一致。</p><p>弹性数组成员有一些专门的规则。首先，弹性成员的数组，必须是 struct 结构的最后一个属性。另外，除了弹性数组成员，struct 结构必须至少还有一个其他属性。</p><h2 id="_3-union-结构" tabindex="-1"><a class="header-anchor" href="#_3-union-结构"><span>3 Union 结构</span></a></h2><p>有时需要一种数据结构，不同的场合表示不同的数据类型。比如，如果只用一种数据结构表示水果的“量”，这种结构就需要有时是整数（6个苹果），有时是浮点数（1.5公斤草莓）。</p><p>C 语言提供了 Union 结构，用来自定义可以灵活变更的数据结构。它内部包含各种属性，但是所有属性共用一块内存，导致这些属性都是对同一个二进制数据的解读，其中往往只有一个属性的解读是有意义的。并且，后面写入的属性会覆盖前面的属性，这意味着同一块内存，可以先供某一个属性使用，然后再供另一个属性使用。这样做的最大好处是节省内存空间。</p><pre><code class="language-c"><span class="token keyword">union</span> quantity <span class="token punctuation">{</span>
  <span class="token keyword">short</span> count<span class="token punctuation">;</span>
  <span class="token keyword">float</span> weight<span class="token punctuation">;</span>
  <span class="token keyword">float</span> volume<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><p>上面示例中，<code>union</code>命令定义了一个包含三个属性的数据类型<code>quantity</code>。虽然包含三个属性，但是只能写入一个值，三个属性都是对这个值的不同解读。最后赋值的属性，往往就是可以取到有意义的值的那个属性。</p><p>使用时，声明一个该类型的变量。</p><pre><code class="language-c"><span class="token comment">// 写法一</span>
<span class="token keyword">union</span> quantity q<span class="token punctuation">;</span>
q<span class="token punctuation">.</span>count <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">;</span>

<span class="token comment">// 写法二</span>
<span class="token keyword">union</span> quantity q <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">.</span>count<span class="token operator">=</span><span class="token number">4</span><span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// 写法三</span>
<span class="token keyword">union</span> quantity q <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">4</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><p>上面代码展示了为 Union 结构赋值的三种写法。最后一种写法不指定属性名，就会赋值给第一个属性。</p><p>执行完上面的代码以后，<code>q.count</code>可以取到值，另外两个属性取不到值。</p><pre><code class="language-c"><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;count is %i\\n&quot;</span><span class="token punctuation">,</span> q<span class="token punctuation">.</span>count<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// count is 4</span>
<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;weight is %f\\n&quot;</span><span class="token punctuation">,</span> q<span class="token punctuation">.</span>weight<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 未定义行为</span>
</code></pre><p>如果要让<code>q.weight</code>属性可以取到值，就要先为它赋值。</p><pre><code class="language-c">q<span class="token punctuation">.</span>weight <span class="token operator">=</span> <span class="token number">0.5</span><span class="token punctuation">;</span>
<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;weight is %f\\n&quot;</span><span class="token punctuation">,</span> q<span class="token punctuation">.</span>weight<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// weight is 0.5</span>
</code></pre><p>一旦为其他属性赋值，原先可以取到值的<code>q.count</code>属性就跟着改变，使用它可能就没有意义了。除了这一点，Union 结构的其他用法与 Struct 结构，基本上是一致的。</p><p>Union 结构也支持指针运算符<code>-&gt;</code>。</p><pre><code class="language-c"><span class="token keyword">union</span> quantity <span class="token punctuation">{</span>
  <span class="token keyword">short</span> count<span class="token punctuation">;</span>
  <span class="token keyword">float</span> weight<span class="token punctuation">;</span>
  <span class="token keyword">float</span> volume<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">union</span> quantity q<span class="token punctuation">;</span>
q<span class="token punctuation">.</span>count <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">;</span>

<span class="token keyword">union</span> quantity<span class="token operator">*</span> ptr<span class="token punctuation">;</span>
ptr <span class="token operator">=</span> <span class="token operator">&amp;</span>q<span class="token punctuation">;</span>

<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;%d\\n&quot;</span><span class="token punctuation">,</span> ptr<span class="token operator">-&gt;</span>count<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 4</span>
</code></pre><p>上面示例中，<code>ptr</code>是<code>q</code>的指针，那么<code>ptr-&gt;count</code>等同于<code>q.count</code>。</p><p>Union 结构指针与它的属性有关，当前正在按照哪个属性解读数据，它的指针就是对应的数据类型。</p><pre><code class="language-c"><span class="token keyword">union</span> foo <span class="token punctuation">{</span>
  <span class="token keyword">int</span> a<span class="token punctuation">;</span>
  <span class="token keyword">float</span> b<span class="token punctuation">;</span>
<span class="token punctuation">}</span> x<span class="token punctuation">;</span>

<span class="token keyword">int</span><span class="token operator">*</span> foo_int_p <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>x<span class="token punctuation">;</span>
<span class="token keyword">float</span><span class="token operator">*</span> foo_float_p <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">float</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>x<span class="token punctuation">;</span>

x<span class="token punctuation">.</span>a <span class="token operator">=</span> <span class="token number">12</span><span class="token punctuation">;</span>
<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;%d\\n&quot;</span><span class="token punctuation">,</span> x<span class="token punctuation">.</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>           <span class="token comment">// 12</span>
<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;%d\\n&quot;</span><span class="token punctuation">,</span> <span class="token operator">*</span>foo_int_p<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 12</span>

x<span class="token punctuation">.</span>b <span class="token operator">=</span> <span class="token number">3.141592</span><span class="token punctuation">;</span>
<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;%f\\n&quot;</span><span class="token punctuation">,</span> x<span class="token punctuation">.</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>           <span class="token comment">// 3.141592</span>
<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;%f\\n&quot;</span><span class="token punctuation">,</span> <span class="token operator">*</span>foo_float_p<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 3.141592</span>
</code></pre><p>上面示例中，<code>&amp;x</code>是 foo 结构的指针，它的数据类型完全由当前赋值的属性决定。</p><p>typedef 命令可以为 Union 数据类型起别名。</p><pre><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">union</span> <span class="token punctuation">{</span>
  <span class="token keyword">short</span> count<span class="token punctuation">;</span>
  <span class="token keyword">float</span> weight<span class="token punctuation">;</span>
  <span class="token keyword">float</span> volume<span class="token punctuation">;</span>
<span class="token punctuation">}</span> quantity<span class="token punctuation">;</span>
</code></pre><p>上面示例中，<code>union</code>命令定义了一个包含三个属性的数据类型，<code>typedef</code>命令为它起别名为<code>quantity</code>。</p><p>Union 结构的好处，主要是节省空间。它将一段内存空间，重用于不同类型的数据。定义了三个属性，但同一时间只用到一个，使用 Union 结构就可以节省另外两个属性的空间。Union 结构占用的内存长度，等于它内部最长属性的长度。</p><h2 id="_4-enum-类型" tabindex="-1"><a class="header-anchor" href="#_4-enum-类型"><span>4 Enum 类型</span></a></h2><p>如果一种数据类型的取值只有少数几种可能，并且每种取值都有自己的含义，为了提高代码的可读性，可以将它们定义为 Enum 类型，中文名为枚举。</p><pre><code class="language-c"><span class="token keyword">enum</span> <span class="token class-name">colors</span> <span class="token punctuation">{</span>RED<span class="token punctuation">,</span> GREEN<span class="token punctuation">,</span> BLUE<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;%d\\n&quot;</span><span class="token punctuation">,</span> RED<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 0</span>
<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;%d\\n&quot;</span><span class="token punctuation">,</span> GREEN<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 1</span>
<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;%d\\n&quot;</span><span class="token punctuation">,</span> BLUE<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 2</span>
</code></pre><p>上面示例中，假定程序里面需要三种颜色，就可以使用<code>enum</code>命令，把这三种颜色定义成一种枚举类型<code>colors</code>，它只有三种取值可能<code>RED</code>、<code>GREEN</code>、<code>BLUE</code>。这时，这三个名字自动成为整数常量，编译器默认将它们的值设为数字<code>0</code>、<code>1</code>、<code>2</code>。相比之下，<code>RED</code>要比<code>0</code>的可读性好了许多。</p><p>注意，Enum 内部的常量名，遵守标识符的命名规范，但是通常都使用大写。</p><p>使用时，可以将变量声明为 Enum 类型。</p><pre><code class="language-c"><span class="token keyword">enum</span> <span class="token class-name">colors</span> color<span class="token punctuation">;</span>
</code></pre><p>上面代码将变量<code>color</code>声明为<code>enum colors</code>类型。这个变量的值就是常量<code>RED</code>、<code>GREEN</code>、<code>BLUE</code>之中的一个。</p><pre><code class="language-c">color <span class="token operator">=</span> BLUE<span class="token punctuation">;</span>
<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;%i\\n&quot;</span><span class="token punctuation">,</span> color<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 2</span>
</code></pre><p>上面代码将变量<code>color</code>的值设为<code>BLUE</code>，这里<code>BLUE</code>就是一个常量，值等于<code>2</code>。</p><p>typedef 命令可以为 Enum 类型起别名。</p><pre><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">enum</span> <span class="token punctuation">{</span>
  SHEEP<span class="token punctuation">,</span>
  WHEAT<span class="token punctuation">,</span>
  WOOD<span class="token punctuation">,</span>
  BRICK<span class="token punctuation">,</span>
  ORE
<span class="token punctuation">}</span> RESOURCE<span class="token punctuation">;</span>

RESOURCE r<span class="token punctuation">;</span>
</code></pre><p>上面示例中，<code>RESOURCE</code>是 Enum 类型的别名。声明变量时，使用这个别名即可。</p><p>还有一种不常见的写法，就是声明 Enum 类型时，在同一行里面为变量赋值。</p><pre><code class="language-c"><span class="token keyword">enum</span> <span class="token punctuation">{</span>
  SHEEP<span class="token punctuation">,</span>
  WHEAT<span class="token punctuation">,</span>
  WOOD<span class="token punctuation">,</span>
  BRICK<span class="token punctuation">,</span>
  ORE
<span class="token punctuation">}</span> r <span class="token operator">=</span> BRICK<span class="token punctuation">,</span> s <span class="token operator">=</span> WOOD<span class="token punctuation">;</span>
</code></pre><p>上面示例中，<code>r</code>的值是<code>3</code>，<code>s</code>的值是<code>2</code>。</p><p>由于 Enum 的属性会自动声明为常量，所以有时候使用 Enum 的目的，不是为了自定义一种数据类型，而是为了声明一组常量。这时就可以使用下面这种写法，比较简单。</p><pre><code class="language-c"><span class="token keyword">enum</span> <span class="token punctuation">{</span> ONE<span class="token punctuation">,</span> TWO <span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;%d %d&quot;</span><span class="token punctuation">,</span> ONE<span class="token punctuation">,</span> TWO<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 0 1</span>
</code></pre><p>上面示例中，<code>enum</code>是一个关键字，后面跟着一个代码块，常量就在代码内声明。<code>ONE</code>和<code>TWO</code>就是两个 Enum 常量。</p><p>常量之间使用逗号分隔。最后一个常量后面的尾逗号，可以省略，也可以保留。</p><pre><code class="language-c"><span class="token keyword">enum</span> <span class="token punctuation">{</span> ONE<span class="token punctuation">,</span> TWO<span class="token punctuation">,</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><p>由于Enum 会自动编号，因此可以不必为常量赋值。C 语言会自动从0开始递增，为常量赋值。但是，C 语言也允许为 ENUM 常量指定值，不过只能指定为整数，不能是其他类型。因此，任何可以使用整数的场合，都可以使用 Enum 常量。</p><pre><code class="language-c"><span class="token keyword">enum</span> <span class="token punctuation">{</span> ONE <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> TWO <span class="token operator">=</span> <span class="token number">2</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;%d %d&quot;</span><span class="token punctuation">,</span> ONE<span class="token punctuation">,</span> TWO<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 1 2</span>
</code></pre><p>Enum 常量可以是不连续的值。</p><pre><code class="language-c"><span class="token keyword">enum</span> <span class="token punctuation">{</span> X <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">,</span> Y <span class="token operator">=</span> <span class="token number">18</span><span class="token punctuation">,</span> Z <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">2</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><p>Enum 常量也可以是同一个值。</p><pre><code class="language-c"><span class="token keyword">enum</span> <span class="token punctuation">{</span> X <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">,</span> Y <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">,</span> Z <span class="token operator">=</span> <span class="token number">2</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><p>如果一组常量之中，有些指定了值，有些没有指定。那么，没有指定值的常量会从上一个指定了值的常量，开始自动递增赋值。</p><pre><code class="language-c"><span class="token keyword">enum</span> <span class="token punctuation">{</span>
  A<span class="token punctuation">,</span>    <span class="token comment">// 0</span>
  B<span class="token punctuation">,</span>    <span class="token comment">// 1</span>
  C <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">,</span>  <span class="token comment">// 4</span>
  D<span class="token punctuation">,</span>    <span class="token comment">// 5</span>
  E<span class="token punctuation">,</span>    <span class="token comment">// 6</span>
  F <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">,</span>   <span class="token comment">// 3</span>
  G<span class="token punctuation">,</span>    <span class="token comment">// 4</span>
  H     <span class="token comment">// 5</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><p>Enum 的作用域与变量相同。如果是在顶层声明，那么在整个文件内都有效；如果是在代码块内部声明，则只对该代码块有效。如果与使用<code>int</code>声明的常量相比，Enum 的好处是更清晰地表示代码意图。</p>`,220)])])}const k=s(o,[["render",e]]),r=JSON.parse('{"path":"/develop/C/9_otherType.html","title":"09. C语言-其他类型","lang":"zh-CN","frontmatter":{"category":"C","tags":["C"],"description":"09. C语言-其他类型 1 typedef 命令 1.1 简介 typedef命令用来为某个类型起别名。 上面代码中，type代表类型名，name代表别名。 上面示例中，typedef命令为类型unsign char起别名BYTE，然后就可以使用BYTE声明变量。 typedef 可以一次指定多个别名。 上面示例中，一次性为int类型起了三个别名。 ...","head":[["meta",{"property":"og:url","content":"https://echo0d.github.io/DailyNotes/develop/C/9_otherType.html"}],["meta",{"property":"og:site_name","content":"echo0d-notes"}],["meta",{"property":"og:title","content":"09. C语言-其他类型"}],["meta",{"property":"og:description","content":"09. C语言-其他类型 1 typedef 命令 1.1 简介 typedef命令用来为某个类型起别名。 上面代码中，type代表类型名，name代表别名。 上面示例中，typedef命令为类型unsign char起别名BYTE，然后就可以使用BYTE声明变量。 typedef 可以一次指定多个别名。 上面示例中，一次性为int类型起了三个别名。 ..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-04-11T02:11:10.000Z"}],["meta",{"property":"article:author","content":"echo0d"}],["meta",{"property":"article:tag","content":"C"}],["meta",{"property":"article:modified_time","content":"2025-04-11T02:11:10.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"09. C语言-其他类型\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-04-11T02:11:10.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"echo0d\\",\\"url\\":\\"\\"}]}"]]},"headers":[{"level":2,"title":"1 typedef 命令","slug":"_1-typedef-命令","link":"#_1-typedef-命令","children":[{"level":3,"title":"1.1 简介","slug":"_1-1-简介","link":"#_1-1-简介","children":[]},{"level":3,"title":"1.2 主要好处","slug":"_1-2-主要好处","link":"#_1-2-主要好处","children":[]}]},{"level":2,"title":"2 struct 结构","slug":"_2-struct-结构","link":"#_2-struct-结构","children":[{"level":3,"title":"2.1 简介","slug":"_2-1-简介","link":"#_2-1-简介","children":[]},{"level":3,"title":"2.2 struct 的复制","slug":"_2-2-struct-的复制","link":"#_2-2-struct-的复制","children":[]},{"level":3,"title":"2.3 struct 指针","slug":"_2-3-struct-指针","link":"#_2-3-struct-指针","children":[]},{"level":3,"title":"2.4 struct 的嵌套","slug":"_2-4-struct-的嵌套","link":"#_2-4-struct-的嵌套","children":[]},{"level":3,"title":"2.5 位字段","slug":"_2-5-位字段","link":"#_2-5-位字段","children":[]},{"level":3,"title":"2.6 弹性数组成员","slug":"_2-6-弹性数组成员","link":"#_2-6-弹性数组成员","children":[]}]},{"level":2,"title":"3 Union 结构","slug":"_3-union-结构","link":"#_3-union-结构","children":[]},{"level":2,"title":"4 Enum 类型","slug":"_4-enum-类型","link":"#_4-enum-类型","children":[]}],"git":{"createdTime":1739005802000,"updatedTime":1744337470000,"contributors":[{"name":"echo0d","email":"echo0d@163.com","commits":2}]},"readingTime":{"minutes":22.38,"words":6715},"filePathRelative":"develop/C/9_otherType.md","localizedDate":"2025年2月8日","excerpt":"","autoDesc":true}');export{k as comp,r as data};
