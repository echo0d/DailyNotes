import{_ as p}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as o,a,d as e,e as t,b as i,o as l,r as c}from"./app-Q99yxrzh.js";const r="/DailyNotes/assets/img6-BC4xVItl.png",u="/DailyNotes/assets/img1-BeoV3Ouu.png",d={},h={href:"https://www.cnnvd.org.cn/home/loophole",target:"_blank",rel:"noopener noreferrer"},k={href:"https://nvd.nist.gov/vuln/search",target:"_blank",rel:"noopener noreferrer"};function m(v,n){const s=c("ExternalLinkIcon");return l(),o("div",null,[n[2]||(n[2]=a("h1",{id:"权限绕过-shiro-cve-2020-11989-apache-shiro782权限绕过漏洞",tabindex:"-1"},[a("a",{class:"header-anchor",href:"#权限绕过-shiro-cve-2020-11989-apache-shiro782权限绕过漏洞"},[a("span",null,"权限绕过_shiro_CVE-2020-11989_Apache Shiro782权限绕过漏洞")])],-1)),n[3]||(n[3]=a("hr",null,null,-1)),n[4]||(n[4]=a("hr",null,null,-1)),n[5]||(n[5]=a("h2",{id:"漏洞介绍",tabindex:"-1"},[a("a",{class:"header-anchor",href:"#漏洞介绍"},[a("span",null,"漏洞介绍")])],-1)),a("blockquote",null,[a("p",null,[a("a",h,[n[0]||(n[0]=e("国家信息安全漏洞库 (cnnvd.org.cn)")),t(s)])]),a("p",null,[a("a",k,[n[1]||(n[1]=e("NVD - Search and Statistics (nist.gov)")),t(s)])])]),n[6]||(n[6]=i(`<hr><p>Apache Shiro是美国阿帕奇（Apache）软件基金会的一套用于执行认证、授权、加密和会话管理的Java安全框架。使用Shiro的易于理解的API，可以快速、轻松地获得任何应用程序，从最小的移动应用程序到最大的网络和企业应用程序。</p><p>近日，监测发现Apache Shiro官网安全更新，其中 Apache Shiro 1.5.3之前版本中存在认证绕过漏洞（CVE-2020-11989）。当 Apache Shiro 与Spring动态控制器一起使用时，特制请求可能会导致身份认证绕过。</p><hr><h3 id="漏洞危害" tabindex="-1"><a class="header-anchor" href="#漏洞危害"><span>漏洞危害</span></a></h3><p>在Shiro&lt;1.5.3的情况下，将Shiro与Spring Controller一起使用时，相应请求可能会导致身份验证绕过。</p><hr><h3 id="影响范围" tabindex="-1"><a class="header-anchor" href="#影响范围"><span>影响范围</span></a></h3><p>shiro &lt; 1.5.3</p><hr><h3 id="漏洞原理" tabindex="-1"><a class="header-anchor" href="#漏洞原理"><span>漏洞原理</span></a></h3><p>shiro使用的时候需要先配置拦截规则如下：</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code> <span class="token comment">// 配置路径拦截规则</span>
<span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedHashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">&quot;/doLogin&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;anon&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// map.put(&quot;/**&quot;, &quot;authc&quot;);</span>
map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">&quot;/hello/**&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;authc&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//配置成map.put(&quot;/hello/*&quot;, &quot;authc&quot;);也可以</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>1.anon为匿名拦截器，不需要登录就能访问，一般用于静态资源,或者移动端接口</p><p>2.authc为登录拦截器，需要登录认证才能访问的资源。</p><p>使用了shiro的项目中，我们请求的URL(URL1)，经过shiro权限检验(URL2)，最后到springboot项目找到路由来处理(URL3) 漏洞的出现就在URL1,URL2和URL3 有可能不是同一个URL，这就导致我们能绕过shiro的校验，直接访问后端需要首选的URL。</p><h4 id="源码分析" tabindex="-1"><a class="header-anchor" href="#源码分析"><span>源码分析</span></a></h4><p>由于shiro先获取的url，然后会判断分号是否存在，如果存在就会把后面的删除，进入shiro匹配，匹配不上默认放行，之后Spring web对路径进行规范化从而访问到了相应的页面。</p><p>进入decodeAndCleanUriString方法，发现此方法会以分号将传入的URI进行截断，并将分号以及分号后面的数据进行清空，返回分号前面的URI数据，从而让/a/b;/c变为/a/b。</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">String</span> <span class="token function">decodeAndCleanUriString</span><span class="token punctuation">(</span><span class="token class-name">HttpServletRequest</span> request<span class="token punctuation">,</span> <span class="token class-name">String</span> uri<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        uri <span class="token operator">=</span> <span class="token function">decodeRequestString</span><span class="token punctuation">(</span>request<span class="token punctuation">,</span> uri<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> semicolonIndex <span class="token operator">=</span> uri<span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span><span class="token char">&#39;;&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token punctuation">(</span>semicolonIndex <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token operator">?</span> uri<span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> semicolonIndex<span class="token punctuation">)</span> <span class="token operator">:</span> uri<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Spring拦截器的decodeAndCleanUriString方法中，Spring对于分号处理的方式与Shiro不同，Spring会先获取分号的位置，并检测分号后是否存在/，如果有，将/的位置记录在slashIndex变量中，并将分号前的数据与/之后的数据进行拼接，从而让/a/b;/c变为/a/b/c。返回处理后的requestURI。</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code>    <span class="token keyword">private</span> <span class="token class-name">String</span> <span class="token function">decodeAndCleanUriString</span><span class="token punctuation">(</span><span class="token class-name">HttpServletRequest</span> request<span class="token punctuation">,</span> <span class="token class-name">String</span> uri<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        uri <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">removeSemicolonContent</span><span class="token punctuation">(</span>uri<span class="token punctuation">)</span><span class="token punctuation">;</span>
        uri <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">decodeRequestString</span><span class="token punctuation">(</span>request<span class="token punctuation">,</span> uri<span class="token punctuation">)</span><span class="token punctuation">;</span>
        uri <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getSanitizedPath</span><span class="token punctuation">(</span>uri<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> uri<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr><h2 id="漏洞利用" tabindex="-1"><a class="header-anchor" href="#漏洞利用"><span>漏洞利用</span></a></h2><hr><h3 id="利用方式-1" tabindex="-1"><a class="header-anchor" href="#利用方式-1"><span>利用方式 1</span></a></h3><hr><h4 id="漏洞利用思路" tabindex="-1"><a class="header-anchor" href="#漏洞利用思路"><span>漏洞利用思路</span></a></h4><p>利用shiro对路径中分号的错误处理方式进行绕过。</p><h4 id="漏洞利用过程" tabindex="-1"><a class="header-anchor" href="#漏洞利用过程"><span>漏洞利用过程</span></a></h4><p>直接访问历经/hello/1，会被重定向到login界面：（vulfocus中的环境有些错误，需要访问hello/xxx才会重定向）</p><figure><img src="`+r+'" alt="img6" tabindex="0" loading="lazy"><figcaption>img6</figcaption></figure><p>访问/;/hello即可绕过权限验证访问hello页面。</p><figure><img src="'+u+'" alt="img1" tabindex="0" loading="lazy"><figcaption>img1</figcaption></figure><hr><h4 id="威胁防护建议" tabindex="-1"><a class="header-anchor" href="#威胁防护建议"><span>威胁防护建议</span></a></h4><p>检测并拦截url中的/;字符</p><hr><h4 id="用户处置建议" tabindex="-1"><a class="header-anchor" href="#用户处置建议"><span>用户处置建议</span></a></h4><p>升级Shiro到最新版本</p>',40))])}const f=p(d,[["render",m],["__file","权限绕过_shiro_CVE-2020-11989_Apache Shiro782权限绕过漏洞.html.vue"]]),S=JSON.parse('{"path":"/CyberSecurity/RedTeam/2-WebVulnerability/shiro/%E6%9D%83%E9%99%90%E7%BB%95%E8%BF%87_shiro_CVE-2020-11989_Apache%20Shiro782%E6%9D%83%E9%99%90%E7%BB%95%E8%BF%87%E6%BC%8F%E6%B4%9E.html","title":"权限绕过_shiro_CVE-2020-11989_Apache Shiro782权限绕过漏洞","lang":"zh-CN","frontmatter":{},"headers":[{"level":2,"title":"漏洞介绍","slug":"漏洞介绍","link":"#漏洞介绍","children":[{"level":3,"title":"漏洞危害","slug":"漏洞危害","link":"#漏洞危害","children":[]},{"level":3,"title":"影响范围","slug":"影响范围","link":"#影响范围","children":[]},{"level":3,"title":"漏洞原理","slug":"漏洞原理","link":"#漏洞原理","children":[]}]},{"level":2,"title":"漏洞利用","slug":"漏洞利用","link":"#漏洞利用","children":[{"level":3,"title":"利用方式 1","slug":"利用方式-1","link":"#利用方式-1","children":[]}]}],"git":{"createdTime":1731665131000,"updatedTime":1731665131000,"contributors":[{"name":"echo0d","email":"echo0d@163.com","commits":1}]},"readingTime":{"minutes":2.8,"words":841},"filePathRelative":"CyberSecurity/RedTeam/2-WebVulnerability/shiro/权限绕过_shiro_CVE-2020-11989_Apache Shiro782权限绕过漏洞.md","localizedDate":"2024年11月15日","excerpt":"\\n<hr>\\n<hr>\\n<h2>漏洞介绍</h2>\\n<blockquote>\\n<p><a href=\\"https://www.cnnvd.org.cn/home/loophole\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">国家信息安全漏洞库 (cnnvd.org.cn)</a></p>\\n<p><a href=\\"https://nvd.nist.gov/vuln/search\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">NVD - Search and Statistics (nist.gov)</a></p>\\n</blockquote>"}');export{f as comp,S as data};
