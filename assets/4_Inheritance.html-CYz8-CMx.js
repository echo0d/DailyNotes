import{_ as s}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as a,b as p,o as t}from"./app-vU8izl1I.js";const e={};function o(c,n){return t(),a("div",null,[...n[0]||(n[0]=[p(`<h1 id="_04-c-继承" tabindex="-1"><a class="header-anchor" href="#_04-c-继承"><span>04. C++ 继承</span></a></h1><p>C++中的继承是面向对象编程的核心特性之一，允许创建新类（派生类）基于现有类（基类）的属性和行为。</p><h2 id="_1-继承基础" tabindex="-1"><a class="header-anchor" href="#_1-继承基础"><span>1 继承基础</span></a></h2><pre><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">BaseClass</span> <span class="token punctuation">{</span>
   <span class="token comment">// 基类成员...</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">DerivedClass</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">BaseClass</span></span> <span class="token punctuation">{</span>
   <span class="token comment">// 派生类成员...</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><p><strong>构造函数与析构函数在继承中的调用顺序</strong></p><ul><li>创建派生类对象时：先调用基类构造函数，再调用派生类构造函数</li><li>销毁派生类对象时：先调用派生类析构函数，再调用基类析构函数</li></ul><p><strong>继承的好处</strong></p><ol><li>代码重用：避免重复编写相同功能</li><li>建立类层次结构：反映现实世界的关系</li><li>多态性：通过基类指针/引用操作派生类对象</li></ol><h2 id="_2-继承类型" tabindex="-1"><a class="header-anchor" href="#_2-继承类型"><span>2 继承类型</span></a></h2><p>C++支持三种主要的继承类型，通过不同的访问修饰符控制：</p><ol><li><p><strong>公有继承（public）</strong>：</p><ul><li>基类的公有成员在派生类中仍是公有成员</li><li>基类的保护成员在派生类中仍是保护成员</li><li>基类的私有成员在派生类中不可访问</li></ul></li><li><p><strong>保护继承（protected）</strong>：</p><ul><li>基类的公有和保护成员在派生类中变为保护成员</li><li>基类的私有成员在派生类中不可访问</li></ul></li><li><p><strong>私有继承（private）</strong>：</p><ul><li>基类的公有和保护成员在派生类中变为私有成员</li><li>基类的私有成员在派生类中不可访问</li></ul></li></ol><p><strong>继承示例</strong></p><pre><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Shape</span> <span class="token punctuation">{</span>
<span class="token keyword">protected</span><span class="token operator">:</span>
    <span class="token keyword">int</span> width<span class="token punctuation">;</span>
    <span class="token keyword">int</span> height<span class="token punctuation">;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">void</span> <span class="token function">setWidth</span><span class="token punctuation">(</span><span class="token keyword">int</span> w<span class="token punctuation">)</span> <span class="token punctuation">{</span> width <span class="token operator">=</span> w<span class="token punctuation">;</span> <span class="token punctuation">}</span>
    <span class="token keyword">void</span> <span class="token function">setHeight</span><span class="token punctuation">(</span><span class="token keyword">int</span> h<span class="token punctuation">)</span> <span class="token punctuation">{</span> height <span class="token operator">=</span> h<span class="token punctuation">;</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// 公有继承</span>
<span class="token keyword">class</span> <span class="token class-name">Rectangle</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">Shape</span></span> <span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">int</span> <span class="token function">getArea</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token punctuation">(</span>width <span class="token operator">*</span> height<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><h2 id="_3-多继承" tabindex="-1"><a class="header-anchor" href="#_3-多继承"><span>3 多继承</span></a></h2><p>C++支持多继承，允许一个类继承自多个基类：</p><pre><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">A</span> <span class="token punctuation">{</span> <span class="token comment">/*...*/</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">class</span> <span class="token class-name">B</span> <span class="token punctuation">{</span> <span class="token comment">/*...*/</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">class</span> <span class="token class-name">C</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">A</span><span class="token punctuation">,</span> <span class="token keyword">public</span> <span class="token class-name">B</span></span> <span class="token punctuation">{</span>
    <span class="token comment">// 同时继承A和B的成员</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><h2 id="_4-虚函数与多态" tabindex="-1"><a class="header-anchor" href="#_4-虚函数与多态"><span>4 虚函数与多态</span></a></h2><p>通过在基类中声明虚函数实现多态：</p><pre><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Shape</span> <span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">virtual</span> <span class="token keyword">int</span> <span class="token function">getArea</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">Rectangle</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">Shape</span></span> <span class="token punctuation">{</span>
<span class="token keyword">private</span><span class="token operator">:</span>
    <span class="token keyword">int</span> width<span class="token punctuation">,</span> height<span class="token punctuation">;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token function">Rectangle</span><span class="token punctuation">(</span><span class="token keyword">int</span> w<span class="token punctuation">,</span> <span class="token keyword">int</span> h<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">width</span><span class="token punctuation">(</span>w<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">height</span><span class="token punctuation">(</span>h<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
    <span class="token keyword">int</span> <span class="token function">getArea</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">override</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> width <span class="token operator">*</span> height<span class="token punctuation">;</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><h2 id="_5-需要注意的问题" tabindex="-1"><a class="header-anchor" href="#_5-需要注意的问题"><span>5 需要注意的问题</span></a></h2><p>在C++的继承中，有两个特别需要注意的问题：</p><p><strong>1. 菱形继承问题（钻石继承）</strong></p><p>当一个类间接地从同一个基类继承两次时，就会出现菱形继承问题。例如：</p><pre><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">A</span> <span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">int</span> a<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">B</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">A</span></span> <span class="token punctuation">{</span>
    <span class="token comment">// 从A继承了a</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">C</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">A</span></span> <span class="token punctuation">{</span>
    <span class="token comment">// 也从A继承了a</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">D</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">B</span><span class="token punctuation">,</span> <span class="token keyword">public</span> <span class="token class-name">C</span></span> <span class="token punctuation">{</span>
    <span class="token comment">// 现在D有两份a：一份来自B，一份来自C</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><p>这会导致的问题：</p><ul><li>数据冗余：基类A的成员在D中存在两份副本</li><li>歧义：当访问 <code>a</code> 时，编译器不知道应该访问哪一个版本（<code>B::a</code> 还是 <code>C::a</code>）</li><li>如果基类有虚函数，虚函数表也会复制，影响多态性</li></ul><p>解决方案是使用<strong>虚继承</strong>：</p><pre><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">B</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">virtual</span> <span class="token keyword">public</span> <span class="token class-name">A</span></span> <span class="token punctuation">{</span> <span class="token comment">/*...*/</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">class</span> <span class="token class-name">C</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">virtual</span> <span class="token keyword">public</span> <span class="token class-name">A</span></span> <span class="token punctuation">{</span> <span class="token comment">/*...*/</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><p>虚继承确保无论通过多少条路径继承，基类的成员在派生类中只存在一个实例。</p><p><strong>2. 继承不应用于&quot;有一个&quot;关系</strong></p><p>这是一个设计原则问题。继承表示&quot;是一个&quot; (is-a) 关系，而不是&quot;有一个&quot; (has-a) 关系：</p><ul><li>&quot;是一个&quot;关系适合用继承：矩形<strong>是一个</strong>形状</li><li>&quot;有一个&quot;关系应该用组合：汽车<strong>有一个</strong>引擎</li></ul><p>错误的例子：</p><pre><code class="language-cpp"><span class="token comment">// 错误设计：Car不是一个Engine</span>
<span class="token keyword">class</span> <span class="token class-name">Engine</span> <span class="token punctuation">{</span> <span class="token comment">/*...*/</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">class</span> <span class="token class-name">Car</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">Engine</span></span> <span class="token punctuation">{</span> <span class="token comment">/*...*/</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><p>正确的设计：</p><pre><code class="language-cpp"><span class="token comment">// 正确设计：Car有一个Engine</span>
<span class="token keyword">class</span> <span class="token class-name">Engine</span> <span class="token punctuation">{</span> <span class="token comment">/*...*/</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">class</span> <span class="token class-name">Car</span> <span class="token punctuation">{</span>
<span class="token keyword">private</span><span class="token operator">:</span>
    Engine engine<span class="token punctuation">;</span>  <span class="token comment">// 组合</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><p>错误使用继承而不是组合会导致：</p><ul><li>打破封装：派生类暴露了不需要的基类接口</li><li>紧耦合：当基类改变时，所有派生类都受影响</li><li>违反&quot;里氏替换原则&quot;：派生类不能总是替代基类使用</li></ul><p>区分&quot;是一个&quot;和&quot;有一个&quot;关系是面向对象设计中的关键决策，正确应用可以创建更清晰、更易于维护的代码结构。</p><p>继承是实现代码复用和程序扩展的强大工具，合理使用可以创建灵活且可维护的面向对象系统。</p>`,40)])])}const u=s(e,[["render",o]]),i=JSON.parse('{"path":"/develop/CPP/4_Inheritance.html","title":"04. C++ 继承","lang":"zh-CN","frontmatter":{"category":"C++","tags":["Cpp"],"description":"04. C++ 继承 C++中的继承是面向对象编程的核心特性之一，允许创建新类（派生类）基于现有类（基类）的属性和行为。 1 继承基础 构造函数与析构函数在继承中的调用顺序 创建派生类对象时：先调用基类构造函数，再调用派生类构造函数 销毁派生类对象时：先调用派生类析构函数，再调用基类析构函数 继承的好处 代码重用：避免重复编写相同功能 建立类层次结构：...","head":[["meta",{"property":"og:url","content":"https://echo0d.github.io/DailyNotes/develop/CPP/4_Inheritance.html"}],["meta",{"property":"og:site_name","content":"echo0d-notes"}],["meta",{"property":"og:title","content":"04. C++ 继承"}],["meta",{"property":"og:description","content":"04. C++ 继承 C++中的继承是面向对象编程的核心特性之一，允许创建新类（派生类）基于现有类（基类）的属性和行为。 1 继承基础 构造函数与析构函数在继承中的调用顺序 创建派生类对象时：先调用基类构造函数，再调用派生类构造函数 销毁派生类对象时：先调用派生类析构函数，再调用基类析构函数 继承的好处 代码重用：避免重复编写相同功能 建立类层次结构：..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-04-15T03:35:09.000Z"}],["meta",{"property":"article:author","content":"echo0d"}],["meta",{"property":"article:tag","content":"Cpp"}],["meta",{"property":"article:modified_time","content":"2025-04-15T03:35:09.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"04. C++ 继承\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-04-15T03:35:09.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"echo0d\\",\\"url\\":\\"\\"}]}"]]},"headers":[{"level":2,"title":"1 继承基础","slug":"_1-继承基础","link":"#_1-继承基础","children":[]},{"level":2,"title":"2 继承类型","slug":"_2-继承类型","link":"#_2-继承类型","children":[]},{"level":2,"title":"3 多继承","slug":"_3-多继承","link":"#_3-多继承","children":[]},{"level":2,"title":"4 虚函数与多态","slug":"_4-虚函数与多态","link":"#_4-虚函数与多态","children":[]},{"level":2,"title":"5 需要注意的问题","slug":"_5-需要注意的问题","link":"#_5-需要注意的问题","children":[]}],"git":{"createdTime":1744688109000,"updatedTime":1744688109000,"contributors":[{"name":"echo0d","email":"echo0d@163.com","commits":1}]},"readingTime":{"minutes":3.56,"words":1067},"filePathRelative":"develop/CPP/4_Inheritance.md","localizedDate":"2025年4月15日","excerpt":"","autoDesc":true}');export{u as comp,i as data};
