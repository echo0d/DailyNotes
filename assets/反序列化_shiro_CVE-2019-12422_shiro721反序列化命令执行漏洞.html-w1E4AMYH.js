import{_ as t}from"./plugin-vue_export-helper-x3n3nnut.js";import{r as s,o,c as d,a as e,b as i,d as r,e as n}from"./app-0W2hpau8.js";const c="/DailyNotes/assets/img12-izM49nZG.png",l="/DailyNotes/assets/img13-DNXepU6B.png",h="/DailyNotes/assets/img6-287izPla.png",p="/DailyNotes/assets/img7-6h8h0N29.png",g="/DailyNotes/assets/img8-ZoBlloxv.png",m="/DailyNotes/assets/img9-aNJDpKhU.png",u="/DailyNotes/assets/img5-kcgL7o0J.png",b={},_=e("h1",{id:"反序列化-shiro-cve-2019-12422-shiro721反序列化命令执行漏洞",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#反序列化-shiro-cve-2019-12422-shiro721反序列化命令执行漏洞","aria-hidden":"true"},"#"),i(" 反序列化_shiro_CVE-2019-12422_shiro721反序列化命令执行漏洞")],-1),f=e("hr",null,null,-1),v=e("hr",null,null,-1),x=e("h2",{id:"漏洞介绍",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#漏洞介绍","aria-hidden":"true"},"#"),i(" 漏洞介绍")],-1),y={href:"https://www.cnnvd.org.cn/home/loophole",target:"_blank",rel:"noopener noreferrer"},S={href:"https://nvd.nist.gov/vuln/search",target:"_blank",rel:"noopener noreferrer"},C=n(`<hr><p>Apache Shiro™（读作“sheeroh”，即日语“城”）是一个开源安全框架，提供身份验证、授权、密码学和会话管理。Shiro框架直观、易用，同时也能提供健壮的安全性。Shiro 1.2.4以下版本代码中使用了默认密钥，造成了shiro550漏洞，在后续的版本更新中，修复了之前shiro-550的固定KEY值，官方移除了代码中的默认密钥，要求开发者自己设置，如果开发者没有设置，则默认动态生成，降低了固定密钥泄漏的风险。然后后续的流程还是没变， 1.2.5 &lt;= Shiro &lt; 1.4.2版本中仍然存在类似的漏洞，即shiro-721。</p><hr><h3 id="漏洞危害" tabindex="-1"><a class="header-anchor" href="#漏洞危害" aria-hidden="true">#</a> 漏洞危害</h3><p>利用java反序列化造成远程命令执行。</p><hr><h3 id="影响范围" tabindex="-1"><a class="header-anchor" href="#影响范围" aria-hidden="true">#</a> 影响范围</h3><p>1.2.5 &lt;= Shiro &lt; 1.4.2</p><hr><h3 id="漏洞原理" tabindex="-1"><a class="header-anchor" href="#漏洞原理" aria-hidden="true">#</a> 漏洞原理</h3><p>Shiro使用了AES-128-CBC模式对cookie进行加密，导致恶意用户可以通过Padding Oracle攻击方式构造序列化数据进行反序列化攻击,例如SHIRO-550，Shiro-721。攻击者通过已知 RememberMe 密文使用 Padding Oracle Attack 爆破和篡改密文，构造可解密的恶意的反序列化数据，触发反序列化漏洞。</p><h4 id="源码分析" tabindex="-1"><a class="header-anchor" href="#源码分析" aria-hidden="true">#</a> 源码分析</h4><p>Padding Oracle Attack 是利用类似于盲注的思想来判断是否爆破成功的，在验证 Padding 失败时的返回信息应该不同，那我们看一下在Shiro中，验证Padding失败时的返回值。</p><p>AbstractRememberMeManager#getRememberedPrincipals开始</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>public PrincipalCollection getRememberedPrincipals(SubjectContext subjectContext) {
    PrincipalCollection principals = null;
    try {
        byte[] bytes = getRememberedSerializedIdentity(subjectContext);
        //SHIRO-138 - only call convertBytesToPrincipals if bytes exist:
        if (bytes != null &amp;&amp; bytes.length &gt; 0) {
            principals = convertBytesToPrincipals(bytes, subjectContext);
        }
    } catch (RuntimeException re) {
        principals = onRememberedPrincipalFailure(re, subjectContext);
    }
    return principals;
}
12345678910111213
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>负责解密的 convertBytesToPrincipals 方法会调用 CipherService 的 decrypt 方法，调用栈如下所示如下:</p><figure><img src="`+c+'" alt="img12" tabindex="0" loading="lazy"><figcaption>img12</figcaption></figure><p>其中 PKCS5Padding#unpad 方法对数据的填充格式进行判断，有问题会返回 -1；当返回值小于0时，CipherCore#doFinal 方法会抛出 BadPadding-Exception 异常；</p><p>接着 JcaCipherService#crypt 方法、 AbstractRe-memberMeManager#getRememberedPrincipals 方法均返回异常，而且AbstractRemember-MeManager#getRememberedPrincipals方法还好调用onRememberedPrincipalFailure移除rem-emberMe cookie并添加 deleteMe。</p><figure><img src="'+l+'" alt="img13" tabindex="0" loading="lazy"><figcaption>img13</figcaption></figure><p>由此可见，只要 padding 错误，服务端就会返回一个 cookie: rememberMe=deleteMe;攻击者可以借由此特征进行 Padding Oracle Attack。</p><hr><h2 id="漏洞利用" tabindex="-1"><a class="header-anchor" href="#漏洞利用" aria-hidden="true">#</a> 漏洞利用</h2><hr><h3 id="利用方式-1" tabindex="-1"><a class="header-anchor" href="#利用方式-1" aria-hidden="true">#</a> 利用方式 1</h3><hr><h4 id="漏洞利用思路" tabindex="-1"><a class="header-anchor" href="#漏洞利用思路" aria-hidden="true">#</a> 漏洞利用思路</h4>',27),P={href:"https://cloud.tencent.com/developer/article/2130129",target:"_blank",rel:"noopener noreferrer"},k=n('<h4 id="漏洞利用过程" tabindex="-1"><a class="header-anchor" href="#漏洞利用过程" aria-hidden="true">#</a> 漏洞利用过程</h4><p>本次漏洞复现使用工具：https://github.com/feihong-cs/ShiroExploit-Deprecated。或者可以参考https://github.com/inspiringz/Shiro-721</p><p>登录</p><figure><img src="'+h+'" alt="img6" tabindex="0" loading="lazy"><figcaption>img6</figcaption></figure><p>抓包</p><figure><img src="'+p+'" alt="img7" tabindex="0" loading="lazy"><figcaption>img7</figcaption></figure><p>填写到工具中</p><figure><img src="'+g+'" alt="img8" tabindex="0" loading="lazy"><figcaption>img8</figcaption></figure><p>选择</p><figure><img src="'+m+'" alt="img9" tabindex="0" loading="lazy"><figcaption>img9</figcaption></figure><p>结果</p><figure><img src="'+u+'" alt="img5" tabindex="0" loading="lazy"><figcaption>img5</figcaption></figure><hr><h4 id="威胁防护建议" tabindex="-1"><a class="header-anchor" href="#威胁防护建议" aria-hidden="true">#</a> 威胁防护建议</h4><p>拦截Cookie中长度过大的rememberMe值</p><hr><h4 id="用户处置建议" tabindex="-1"><a class="header-anchor" href="#用户处置建议" aria-hidden="true">#</a> 用户处置建议</h4><p>升级Shiro到最新版</p>',18);function N(M,R){const a=s("ExternalLinkIcon");return o(),d("div",null,[_,f,v,x,e("blockquote",null,[e("p",null,[e("a",y,[i("国家信息安全漏洞库 (cnnvd.org.cn)"),r(a)])]),e("p",null,[e("a",S,[i("NVD - Search and Statistics (nist.gov)"),r(a)])])]),C,e("p",null,[i("在cookie中使用的是AES-128-CBC模式进行的加密，在加密流程中使用了Padding填充，这里导致用户可以通过"),e("a",P,[i("Padding Oracle攻击"),r(a)]),i("来生成攻击代码来构造恶意的rememberMe字段，然后触发反序列化攻击，最终导致的任意代码执行。本漏洞实际并不是针对shiro代码逻辑的漏洞，而是针对shiro使用的AES-128-CBC加密模式的攻击。")]),k])}const z=t(b,[["render",N],["__file","反序列化_shiro_CVE-2019-12422_shiro721反序列化命令执行漏洞.html.vue"]]);export{z as default};
