import{_ as o}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c,b as t,a as s,d as a,e,r as l,o as u}from"./app-ClR9AqGF.js";const i={},k={href:"https://www.cnblogs.com/yyhuni/p/18012041",target:"_blank",rel:"noopener noreferrer"},r={href:"https://juejin.im/post/5ad3e6b36fb9a028ba1fee6a",target:"_blank",rel:"noopener noreferrer"};function d(m,n){const p=l("ExternalLinkIcon");return u(),c("div",null,[n[9]||(n[9]=t(`<h1 id="java-常见漏洞" tabindex="-1"><a class="header-anchor" href="#java-常见漏洞"><span>Java 常见漏洞</span></a></h1><p>总结 Java 常见漏洞及其审计技巧，包括 RCE、SQL 注入、反序列化等。</p><h2 id="命令执行" tabindex="-1"><a class="header-anchor" href="#命令执行"><span>命令执行</span></a></h2><p>Java 中实现命令执行的方式：</p><ul><li>反射</li><li><code>Runtime.getRuntime.exec</code></li><li><code>ProcessBuilder</code></li><li><code>groovy_shell</code></li></ul><p>代码审计时，查找可用于命令执行的相关关键字如<code>groovy</code>、<code>Runtime.getRuntime.exec</code>、<code>ProcessBuilder </code>、<code>Class.forName</code>等，找到对应的地址后跟踪方法调用栈，最后找他的入口点即客户端传参获取地点进行分析</p><p><strong>示例代码 1：使用 <code>Runtime.getRuntime().exec()</code></strong></p><pre><code class="language-java"><span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span><span class="token class-name">BufferedReader</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span><span class="token class-name">InputStreamReader</span></span><span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">CommandExecutor</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">try</span> <span class="token punctuation">{</span>
            <span class="token class-name">Process</span> process <span class="token operator">=</span> <span class="token class-name">Runtime</span><span class="token punctuation">.</span><span class="token function">getRuntime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">exec</span><span class="token punctuation">(</span><span class="token string">&quot;calc&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token class-name">BufferedReader</span> reader <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BufferedReader</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">InputStreamReader</span><span class="token punctuation">(</span>process<span class="token punctuation">.</span><span class="token function">getInputStream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token class-name">String</span> line<span class="token punctuation">;</span>
            <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>line <span class="token operator">=</span> reader<span class="token punctuation">.</span><span class="token function">readLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>line<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><p><strong>示例代码 2：使用 <code>ProcessBuilder</code></strong></p><pre><code class="language-java"><span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span><span class="token class-name">BufferedReader</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span><span class="token class-name">InputStreamReader</span></span><span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ProcessBuilderDemo</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">try</span> <span class="token punctuation">{</span>
            <span class="token class-name">ProcessBuilder</span> builder <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ProcessBuilder</span><span class="token punctuation">(</span><span class="token string">&quot;ipconfig&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token class-name">Process</span> process <span class="token operator">=</span> builder<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token class-name">BufferedReader</span> reader <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BufferedReader</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">InputStreamReader</span><span class="token punctuation">(</span>process<span class="token punctuation">.</span><span class="token function">getInputStream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token class-name">String</span> line<span class="token punctuation">;</span>
            <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>line <span class="token operator">=</span> reader<span class="token punctuation">.</span><span class="token function">readLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>line<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

</code></pre><p><strong>示例代码 3：使用<code>GroovyShell</code></strong></p><pre><code class="language-java"><span class="token keyword">import</span> <span class="token import"><span class="token namespace">groovy<span class="token punctuation">.</span>lang<span class="token punctuation">.</span></span><span class="token class-name">GroovyShell</span></span><span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> groovyShellDemo <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">GroovyShell</span> shell <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">GroovyShell</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">String</span> cmd <span class="token operator">=</span> <span class="token string">&quot;\\&quot;whoami\\&quot;.execute().text&quot;</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>shell<span class="token punctuation">.</span><span class="token function">evaluate</span><span class="token punctuation">(</span>cmd<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

</code></pre>`,12)),s("p",null,[n[1]||(n[1]=a("类似的还有很多，还可以远程加载脚本，参考",-1)),s("a",k,[n[0]||(n[0]=a("Groovy 命令执行指南 - Atomovo - 博客园 (cnblogs.com)",-1)),e(p)])]),n[10]||(n[10]=t(`<p><strong>示例代码 4：反射调用之一</strong></p><pre><code class="language-java"><span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span><span class="token class-name">BufferedReader</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span><span class="token class-name">IOException</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span><span class="token class-name">InputStreamReader</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span></span><span class="token class-name">Class</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>reflect<span class="token punctuation">.</span></span><span class="token operator">*</span></span><span class="token punctuation">;</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> reflectDemo <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">ClassNotFoundException</span><span class="token punctuation">,</span> <span class="token class-name">NoSuchMethodException</span><span class="token punctuation">,</span> <span class="token class-name">InvocationTargetException</span><span class="token punctuation">,</span> <span class="token class-name">IllegalAccessException</span> <span class="token punctuation">{</span>
        <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> c <span class="token operator">=</span> <span class="token class-name">Class</span><span class="token punctuation">.</span><span class="token function">forName</span><span class="token punctuation">(</span><span class="token string">&quot;java.lang.Runtime&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//获取类</span>
        <span class="token class-name">Method</span> m1 <span class="token operator">=</span>  c<span class="token punctuation">.</span><span class="token function">getMethod</span><span class="token punctuation">(</span><span class="token string">&quot;getRuntime&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//获取getRuntime方法，用于创建对象</span>
        <span class="token class-name">Method</span> m2 <span class="token operator">=</span> c<span class="token punctuation">.</span><span class="token function">getMethod</span><span class="token punctuation">(</span><span class="token string">&quot;exec&quot;</span><span class="token punctuation">,</span><span class="token class-name">String</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//获取exec方法，用于执行命令</span>
        <span class="token class-name">Object</span> obj <span class="token operator">=</span>  m1<span class="token punctuation">.</span><span class="token function">invoke</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">,</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//创建对象</span>
        <span class="token class-name">Process</span> process <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">Process</span><span class="token punctuation">)</span> m2<span class="token punctuation">.</span><span class="token function">invoke</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span><span class="token string">&quot;whoami&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//反射调用</span>
        <span class="token comment">// 下面可以不要，直接m2.invoke(obj,&quot;whoami&quot;); 只是没回显</span>
        <span class="token keyword">try</span> <span class="token punctuation">(</span><span class="token class-name">BufferedReader</span> reader <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BufferedReader</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">InputStreamReader</span><span class="token punctuation">(</span>process<span class="token punctuation">.</span><span class="token function">getInputStream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token class-name">String</span> line<span class="token punctuation">;</span>
            <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>line <span class="token operator">=</span> reader<span class="token punctuation">.</span><span class="token function">readLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>line<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">RuntimeException</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

</code></pre><h2 id="反序列化" tabindex="-1"><a class="header-anchor" href="#反序列化"><span>反序列化</span></a></h2><p>在 Java 中反序列化漏洞之所以比较严重的原因之一是：Java 存在大量的公用库，例如 Apache Commons Collections。WebLogic、WebSphere、JBoss、Jenkins、OpenNMS 这些应用的反序列化漏洞能够得以利用，便是依靠了 Apache Commons Collections。当然反序列漏洞的根源并不在于公共库，而是在于 Java 程序没有对反序列化生成的对象的类型做限制。</p><p>代码审计时，首先查找用于解析的类库（xml、yml、json 等），追踪方法调用栈然后考虑参数是否可控：</p><ul><li><p><code>XMLDecoder.readObject</code></p></li><li><p><code>Yaml.load</code></p></li><li><p><code>XStream.fromXML </code></p></li><li><p><code>ObjectMapper.readValue</code></p></li><li><p><code>JSON.parseObject</code></p></li></ul><p>当参数可控时，查找应用的 Class Path 中是否包含 Apache Commons Collections 等危险库（ysoserial 所支持的其他库亦可）。同时满足了这些条件后，我们便可直接通过 ysoserial 生成所需的命令执行的反序列化语句。</p><p>利用链通常分为三部分，触发点、中继点、执行点。</p>`,8)),s("ul",null,[n[7]||(n[7]=s("li",null,[s("p",null,"触发点"),s("ul",null,[s("li",null,[a("触发点比较简单，主要是"),s("code",null,"readObj")])])],-1)),s("li",null,[n[6]||(n[6]=s("p",null,"中继点，这里不太懂，管他呢 我也挖不出来~",-1)),s("ul",null,[s("li",null,[s("p",null,[n[3]||(n[3]=a("动态代理，相关知识可参考",-1)),s("a",r,[n[2]||(n[2]=a("Java 动态代理",-1)),e(p)]),n[4]||(n[4]=a("。要实现动态代理需要有三个类：",-1))]),n[5]||(n[5]=s("ul",null,[s("li",null,[s("p",null,"委托类，委托类就是处理业务逻辑的类，动态代理的目的就是在委托类中的代码运行时插入其他的操作，如日志打印。此外，委托类必须实现某个接口。")]),s("li",null,[s("p",null,[a("中介类，中介类是对"),s("code",null,"InvocationHandler"),a("接口的实现，它持有一个委托类对象的引用，在代理类调用相关方法时，会劫持到中介类的"),s("code",null,"invoke"),a("方法中，在插入操作后，通过反射调用委托类的方法。")])]),s("li",null,[s("p",null,[a("代理类，代理类通过"),s("code",null,"Proxy.newProxyInstance"),a("来创建，返回类型是委托类所实现的接口的类型。其他类会调用代理类来获取相应的功能，委托类是透明的。")])])],-1))])])]),n[8]||(n[8]=t("<li><p><strong>执行点</strong></p><p>反序列化利用链的挖掘比较困难的点是反序列化执行点，有了反序列化执行点，一般情况下都可以挖掘出不止一条的利用连。常见执行命令的方式：</p><ul><li>反射利用<code>Runtime.getRuntime().exec</code>或<code>java.lang.ProcessBuilder</code>执行</li><li>JNDI 远程调用</li><li>Templates 执行字节码</li><li>EL 表达式</li><li>其他可执行命令的接口</li></ul></li>",1))]),n[11]||(n[11]=t(`<h2 id="文件相关" tabindex="-1"><a class="header-anchor" href="#文件相关"><span>文件相关</span></a></h2><p>文件上传、下载、删除</p><p>关键字：</p><ul><li>JDK 原始的<code>java.io.FileInputStream</code>类</li><li>JDK 原始的<code>java.io.RandomAccessFile</code>类</li><li>Apache Commons IO 提供的<code>org.apache.commons.io.FileUtils</code>类</li><li>JDK1.7 新增的基于 NIO 非阻塞异步读取文件的<code>java.nio.channels.AsynchronousFileChannel</code>类。</li><li>JDK1.7 新增的基于 NIO 读取文件的<code>java.nio.file.Files</code>类。常用方法如:<code>Files.readAllBytes</code>、<code>Files.readAllLines</code></li><li><code>FileInputStream</code></li><li><code>FileOutputStream</code></li><li><code>File</code></li><li><code>FileUtils</code></li><li><code>IOUtils</code></li><li><code>BufferedReader</code></li><li><code>ServletFileUpload</code></li><li><code>MultipartFile</code></li><li><code>CommonsMultipartFile</code></li><li><code>PrintWriter</code></li><li><code>ZipInputStream</code></li><li><code>ZipEntry.getSize</code></li><li><code>Delete</code></li><li><code>deleteFile</code></li><li><code>fileName</code></li><li><code>filePath</code></li></ul><p>找到对应的地址后跟踪方法调用栈，最后找他的入口点即客户端传参获取地点进行分析</p><h2 id="表达式注入" tabindex="-1"><a class="header-anchor" href="#表达式注入"><span>表达式注入</span></a></h2><p>Spring 为解析 SpEL 提供了两套不同的接口，分别是<code>SimpleEvaluationContext</code>及<code>StandardEvaluationContext</code>。<code>SimpleEvaluationContext</code>仅支持 SpEL 语法的子集，抛弃了 Java 类型引用、构造函数及 beam 引用相对较为安全。而<code>StandardEvaluationContext</code>则包含了 SpEL 的所有功能，并且在不指定 <code>EvaluationContext</code>的情况下，将默认采用<code>StandardEvaluationContext</code>。 漏洞成因：很大一部分开发人员未对用户输入进行处理就直接通过解析引擎对 SpEL 继续解析。一旦用户能够控制解析的 SpEL 语句，便可通过反射的方式构造代码执行的 SpEL 语句，从而达到 RCE 的目的。</p><p><strong>SpEL 表达式的用法</strong></p><ol><li><p>注解（无法外部传入）</p><pre><code class="language-java"><span class="token annotation punctuation">@value</span><span class="token punctuation">(</span><span class="token string">&quot;#{表达式}&quot;</span><span class="token punctuation">)</span>
<span class="token keyword">public</span> <span class="token class-name">String</span> arg<span class="token punctuation">;</span>
</code></pre></li><li><p>xml</p><pre><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>Bean1<span class="token punctuation">&quot;</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>com.test.xxx<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
	<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>arg<span class="token punctuation">&quot;</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>#{表达式}<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">&gt;</span></span>
</code></pre><p>前面两种情况通常也是写死在代码中的，但是也有已知的利用场景，就是利用反序列化让程序加载我们事先构造好的恶意 xml 文件，如 jackson 的 CVE-2017-17485、weblogic 的 CVE-2019-2725 等。</p></li><li><p>在代码中处理外部传入的表达式</p><p>这部分是关注的重点。</p><pre><code class="language-java"><span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span><span class="token string">&quot;/spel&quot;</span><span class="token punctuation">)</span>
<span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">spel</span><span class="token punctuation">(</span><span class="token annotation punctuation">@RequestParam</span><span class="token punctuation">(</span>name <span class="token operator">=</span> <span class="token string">&quot;spel&quot;</span><span class="token punctuation">)</span> <span class="token class-name">String</span> spel<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">ExpressionParser</span> expressionParser <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SpelExpressionParser</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">Expression</span> expression <span class="token operator">=</span> expressionParser<span class="token punctuation">.</span><span class="token function">parseExpression</span><span class="token punctuation">(</span>spel<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">Object</span> object <span class="token operator">=</span> expression<span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> object<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></li></ol><p><strong>漏洞可以利用的前置条件有三个：</strong></p><ol><li>传入的表达式没过滤</li><li>表达式解析之后调用了<code>getValue/setValue</code>方法</li><li>使用<code>StandardEvaluationContext</code>（默认）作为上下文对象</li></ol><p><strong>想要执行命令，spel 表达式有如下两种：</strong></p><ul><li><p>使用<code>T(Type)</code>表示<code>Type</code>类的实例,<code>Type</code>为全限定名称,如<code>T(com.test.Bean1)</code>。但是<code>java.lang</code>例外,该包下的类可以不指定包名。得到类实例后会访问类静态方法与字段。</p><pre><code class="language-java"><span class="token class-name">T</span><span class="token punctuation">(</span><span class="token class-name"><span class="token namespace">java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span></span>Runtime</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getRuntime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">exec</span><span class="token punctuation">(</span><span class="token string">&quot;whoami&quot;</span><span class="token punctuation">)</span>
</code></pre></li><li><p>直接通过 java 语法实例化对象、调用方法</p><pre><code class="language-java"><span class="token keyword">new</span> <span class="token class-name">ProcessBuilder</span><span class="token punctuation">(</span><span class="token string">&quot;whoami&quot;</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

<span class="token comment">//可以利用反射来绕过一些过滤</span>
#<span class="token punctuation">{</span>&#39;&#39;<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">forName</span><span class="token punctuation">(</span>&#39;java<span class="token punctuation">.</span>la<span class="token char">&#39;+&#39;</span><span class="token class-name"><span class="token namespace">ng<span class="token punctuation">.</span></span>Ru</span><span class="token char">&#39;+&#39;</span>ntime&#39;<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getMethod</span><span class="token punctuation">(</span><span class="token char">&#39;ex&#39;</span><span class="token operator">+</span><span class="token char">&#39;ec&#39;</span><span class="token punctuation">,</span>&#39;&#39;<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">invoke</span><span class="token punctuation">(</span>&#39;&#39;<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">forName</span><span class="token punctuation">(</span>&#39;java<span class="token punctuation">.</span>la<span class="token char">&#39;+&#39;</span><span class="token class-name"><span class="token namespace">ng<span class="token punctuation">.</span></span>Ru</span><span class="token char">&#39;+&#39;</span>ntime&#39;<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getMethod</span><span class="token punctuation">(</span><span class="token char">&#39;getRu&#39;</span><span class="token operator">+</span><span class="token char">&#39;ntime&#39;</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">invoke</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token char">&#39;calc&#39;</span><span class="token punctuation">)</span><span class="token punctuation">}</span>
</code></pre></li></ul><p><strong>审计技巧：</strong></p><p>全局查找关键字</p><ul><li><code>org.springframework.expression</code></li><li><code>parseExpression</code></li><li><code>getValue</code></li><li><code>getValueType</code></li><li><code>value=&quot;#{*}</code></li></ul><h2 id="sql-注入" tabindex="-1"><a class="header-anchor" href="#sql-注入"><span>SQL 注入</span></a></h2><p><strong>执行 sql 语句的几种方式</strong></p><ol><li>JDBC</li><li>Hibernate</li><li>Mybatis</li></ol><p><strong>审计技巧</strong></p><ul><li><p>使用<code>statement</code>对象带入数据库中查询</p></li><li><p><code>+</code>、<code>append</code>直接拼接（<strong>没有预编译</strong>）</p></li><li><p><code>like</code>、<code>order by</code>等无法使用<strong>预编译</strong>的语句</p></li><li><p><code>$()</code>拼接参数</p></li><li><p>常用的 sql 查询关键字，如<code>Select</code>,<code>insert</code>,<code>update</code>,<code>delete</code></p></li><li><p><code>%</code>、<code>in</code>等</p></li></ul><p>找到对应的地址后跟踪方法调用栈，最后找客户端传参获取地点进行分析</p><h2 id="ssrf" tabindex="-1"><a class="header-anchor" href="#ssrf"><span>SSRF</span></a></h2><p>SSRF 漏洞形成的原因大部分是因为服务端提供了可以从其他服务器获取资源的功能，然而并没有对用户的输入以及发起请求的 url 进行过滤&amp;限制，从而导致了 ssrf 的漏洞。</p><p><strong>常见漏洞情况</strong></p><ul><li>抓取用户输入图片的地址并且本地化存储</li><li>从远程服务器请求资源</li><li>对外发起网络请求</li></ul><p><strong>利用方式</strong></p><ul><li>利用 file 协议读取文件内容（仅限使用 URLConnection 或 URL 发起的请求）</li><li>利用 http 进行内网 web 服务端口探测</li><li>利用 http 进行内网非 web 服务端口探测(如果将异常抛出来的情况下)</li><li>利用 http 进行 NTLM-relay 攻击(仅限 HttpURLConnection 或者二次包装 HttpURLConnection 并未复写 AuthenticationInfo 方法的对象) <strong>不懂</strong></li></ul><p><strong>审计技巧</strong></p><ul><li><p>全局查找<code>URLConnection</code>、<code>HttpURLConnection</code>、<code>HttpClient</code>、<code>Request</code>、<code>okhttp</code>、<code>OkHttpClient</code>、<code>Request.Get</code>、<code>Request.post</code>、<code>URL.openStream</code>、<code>ImageIO</code>等能够发起远程请求的类及函数，找到对应地址后打断点跟踪引用其的方法调用栈，从客户端传参开始，判断是否可控，及可控情况</p></li><li><p>SSRF 漏洞<strong>URL</strong>中常出现 url、f、file、page 等<strong>参数</strong>。</p></li></ul><h2 id="xxe" tabindex="-1"><a class="header-anchor" href="#xxe"><span>XXE</span></a></h2><p><strong>解析 XML 的几种方式</strong></p><ul><li>XMLReader</li><li>SAXBuilder</li><li>SAXReader</li><li>SAXParserFactory</li><li>Digester</li><li>DocumentBuilderFactory</li></ul><p><strong>审计技巧</strong></p><ul><li><p><code>Documentbuilder</code></p></li><li><p><code>DocumentBuilderFactory</code></p></li><li><p><code>SAXReader</code></p></li><li><p><code>SAXParser</code></p></li><li><p><code>SAXParserFactory</code></p></li><li><p><code>SAXBuilder</code></p></li><li><p><code>TransformerFactory</code></p></li><li><p><code>reqXml</code></p></li><li><p><code>getInputStream</code></p></li><li><p><code>XMLReaderFactory</code></p></li><li><p><code>.newInstance</code></p></li><li><p><code>SchemaFactory</code></p></li><li><p><code>SAXTransformerFactory</code></p></li><li><p><code>javax.xml.bind</code></p></li><li><p><code>XMLReader</code></p></li><li><p><code>XmlUtils.get</code></p></li><li><p><code>Validator</code></p></li></ul><p>找到对应的地址后跟踪方法调用栈，最后找他的入口点即客户端传参获取地点进行分析</p><p>xxe 的防御比较简单，禁用外部实体即可。</p><h2 id="xss" tabindex="-1"><a class="header-anchor" href="#xss"><span>XSS</span></a></h2><p>不想写了</p>`,39))])}const h=o(i,[["render",d]]),v=JSON.parse('{"path":"/CodeAudittutorial/3-JavaVul/JavaVul.html","title":"Java 常见漏洞","lang":"zh-CN","frontmatter":{"category":"代码审计","tags":["Java"],"star":"1","sticky":"1","description":"Java 常见漏洞 总结 Java 常见漏洞及其审计技巧，包括 RCE、SQL 注入、反序列化等。 命令执行 Java 中实现命令执行的方式： 反射 Runtime.getRuntime.exec ProcessBuilder groovy_shell 代码审计时，查找可用于命令执行的相关关键字如groovy、Runtime.getRuntime.ex...","head":[["meta",{"property":"og:url","content":"https://echo0d.github.io/DailyNotes/CodeAudittutorial/3-JavaVul/JavaVul.html"}],["meta",{"property":"og:site_name","content":"echo0d-notes"}],["meta",{"property":"og:title","content":"Java 常见漏洞"}],["meta",{"property":"og:description","content":"Java 常见漏洞 总结 Java 常见漏洞及其审计技巧，包括 RCE、SQL 注入、反序列化等。 命令执行 Java 中实现命令执行的方式： 反射 Runtime.getRuntime.exec ProcessBuilder groovy_shell 代码审计时，查找可用于命令执行的相关关键字如groovy、Runtime.getRuntime.ex..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-06-04T09:27:16.000Z"}],["meta",{"property":"article:author","content":"echo0d"}],["meta",{"property":"article:tag","content":"Java"}],["meta",{"property":"article:modified_time","content":"2025-06-04T09:27:16.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Java 常见漏洞\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-06-04T09:27:16.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"echo0d\\",\\"url\\":\\"\\"}]}"]]},"headers":[{"level":2,"title":"命令执行","slug":"命令执行","link":"#命令执行","children":[]},{"level":2,"title":"反序列化","slug":"反序列化","link":"#反序列化","children":[]},{"level":2,"title":"文件相关","slug":"文件相关","link":"#文件相关","children":[]},{"level":2,"title":"表达式注入","slug":"表达式注入","link":"#表达式注入","children":[]},{"level":2,"title":"SQL 注入","slug":"sql-注入","link":"#sql-注入","children":[]},{"level":2,"title":"SSRF","slug":"ssrf","link":"#ssrf","children":[]},{"level":2,"title":"XXE","slug":"xxe","link":"#xxe","children":[]},{"level":2,"title":"XSS","slug":"xss","link":"#xss","children":[]}],"git":{"createdTime":1723730045000,"updatedTime":1749029236000,"contributors":[{"name":"echo0d","email":"echo0d@163.com","commits":5}]},"readingTime":{"minutes":7.2,"words":2160},"filePathRelative":"CodeAudittutorial/3-JavaVul/JavaVul.md","localizedDate":"2024年8月15日","excerpt":"\\n<p>总结 Java 常见漏洞及其审计技巧，包括 RCE、SQL 注入、反序列化等。</p>\\n","autoDesc":true}');export{h as comp,v as data};
