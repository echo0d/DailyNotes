import{_ as s}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as a,b as t,o as p}from"./app-vU8izl1I.js";const o={};function e(c,n){return p(),a("div",null,[...n[0]||(n[0]=[t(`<h1 id="_6-c-多态" tabindex="-1"><a class="header-anchor" href="#_6-c-多态"><span>6. C++ 多态</span></a></h1><p>在 C++ 中，<strong>多态（Polymorphism）</strong> 是面向对象编程（OOP）的核心特性之一，它允许同一个接口在不同的场景下表现出不同的行为。多态的主要目的是通过统一的接口实现不同的功能，从而提高代码的灵活性和可扩展性。</p><p>C++ 中的多态分为两种类型：<strong>编译时多态（静态多态）</strong> 和 <strong>运行时多态（动态多态）</strong>。</p><hr><h2 id="_1-编译时多态-静态多态" tabindex="-1"><a class="header-anchor" href="#_1-编译时多态-静态多态"><span>1 <strong>编译时多态（静态多态）</strong></span></a></h2><p>编译时多态是在程序编译阶段确定的多态行为，主要通过<strong>函数重载</strong>和<strong>运算符重载</strong>实现。</p><h3 id="_1-1-特点" tabindex="-1"><a class="header-anchor" href="#_1-1-特点"><span>1.1 <strong>特点</strong></span></a></h3><ul><li>在编译时决定调用哪个函数或运算符。</li><li>不涉及虚函数或继承。</li><li>性能较高，因为不需要运行时的动态绑定。</li></ul><h3 id="_1-2-实现方式" tabindex="-1"><a class="header-anchor" href="#_1-2-实现方式"><span>1.2 <strong>实现方式</strong></span></a></h3><ol><li><p><strong>函数重载</strong> 函数重载允许在同一作用域中定义多个同名函数，通过参数列表的不同来区分。</p><pre><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

<span class="token keyword">void</span> <span class="token function">display</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;整数: &quot;</span> <span class="token operator">&lt;&lt;</span> i <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">void</span> <span class="token function">display</span><span class="token punctuation">(</span><span class="token keyword">double</span> d<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;浮点数: &quot;</span> <span class="token operator">&lt;&lt;</span> d <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">display</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 调用整数版本</span>
    <span class="token function">display</span><span class="token punctuation">(</span><span class="token number">3.14</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 调用浮点数版本</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></li><li><p><strong>运算符重载</strong> 运算符重载允许为用户自定义类型定义新的运算符行为。</p><pre><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">Complex</span> <span class="token punctuation">{</span>
<span class="token keyword">private</span><span class="token operator">:</span>
    <span class="token keyword">double</span> real<span class="token punctuation">,</span> imag<span class="token punctuation">;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token function">Complex</span><span class="token punctuation">(</span><span class="token keyword">double</span> r<span class="token punctuation">,</span> <span class="token keyword">double</span> i<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">real</span><span class="token punctuation">(</span>r<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">imag</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

    Complex <span class="token keyword">operator</span><span class="token operator">+</span><span class="token punctuation">(</span><span class="token keyword">const</span> Complex<span class="token operator">&amp;</span> other<span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token function">Complex</span><span class="token punctuation">(</span>real <span class="token operator">+</span> other<span class="token punctuation">.</span>real<span class="token punctuation">,</span> imag <span class="token operator">+</span> other<span class="token punctuation">.</span>imag<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">void</span> <span class="token function">display</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span>
        cout <span class="token operator">&lt;&lt;</span> real <span class="token operator">&lt;&lt;</span> <span class="token string">&quot; + &quot;</span> <span class="token operator">&lt;&lt;</span> imag <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;i&quot;</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    Complex <span class="token function">c1</span><span class="token punctuation">(</span><span class="token number">1.0</span><span class="token punctuation">,</span> <span class="token number">2.0</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">c2</span><span class="token punctuation">(</span><span class="token number">3.0</span><span class="token punctuation">,</span> <span class="token number">4.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    Complex c3 <span class="token operator">=</span> c1 <span class="token operator">+</span> c2<span class="token punctuation">;</span> <span class="token comment">// 使用重载的加法运算符</span>
    c3<span class="token punctuation">.</span><span class="token function">display</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></li></ol><hr><h2 id="_2-运行时多态-动态多态" tabindex="-1"><a class="header-anchor" href="#_2-运行时多态-动态多态"><span>2 <strong>运行时多态（动态多态）</strong></span></a></h2><p>运行时多态是在程序运行阶段决定的多态行为，主要通过<strong>继承</strong>和<strong>虚函数</strong>实现。</p><h3 id="_2-1-特点" tabindex="-1"><a class="header-anchor" href="#_2-1-特点"><span>2.1 <strong>特点</strong></span></a></h3><ul><li>通过基类指针或引用调用派生类的函数。</li><li>使用虚函数实现动态绑定。</li><li>提高了代码的灵活性，但会略微降低性能（因为需要运行时查找虚函数表）。</li></ul><h3 id="_2-2-实现方式" tabindex="-1"><a class="header-anchor" href="#_2-2-实现方式"><span>2.2 <strong>实现方式</strong></span></a></h3><ol><li><p><strong>虚函数</strong> 虚函数是通过在基类中使用 <code>virtual</code> 关键字声明的函数，允许派生类重写该函数。</p><pre><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">Base</span> <span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">show</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 虚函数</span>
        cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;Base 类的 show 函数&quot;</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">Derived</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">Base</span></span> <span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">void</span> <span class="token function">show</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">override</span> <span class="token punctuation">{</span> <span class="token comment">// 重写基类的虚函数</span>
        cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;Derived 类的 show 函数&quot;</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    Base<span class="token operator">*</span> basePtr<span class="token punctuation">;</span> <span class="token comment">// 基类指针</span>
    Derived derivedObj<span class="token punctuation">;</span>

    basePtr <span class="token operator">=</span> <span class="token operator">&amp;</span>derivedObj<span class="token punctuation">;</span>
    basePtr<span class="token operator">-&gt;</span><span class="token function">show</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 调用 Derived 类的 show 函数（动态绑定）</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></li><li><p><strong>纯虚函数与抽象类</strong></p><ul><li>如果一个类中包含纯虚函数（<code>= 0</code>），则该类称为抽象类，不能直接实例化。</li><li>抽象类通常用作接口，派生类必须实现纯虚函数。</li></ul><pre><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">Shape</span> <span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">draw</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// 纯虚函数</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">Circle</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">Shape</span></span> <span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">void</span> <span class="token function">draw</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">override</span> <span class="token punctuation">{</span>
        cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;绘制圆形&quot;</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">Rectangle</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">Shape</span></span> <span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">void</span> <span class="token function">draw</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">override</span> <span class="token punctuation">{</span>
        cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;绘制矩形&quot;</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    Shape<span class="token operator">*</span> shape1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">Circle</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    Shape<span class="token operator">*</span> shape2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">Rectangle</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    shape1<span class="token operator">-&gt;</span><span class="token function">draw</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 调用 Circle 的 draw 函数</span>
    shape2<span class="token operator">-&gt;</span><span class="token function">draw</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 调用 Rectangle 的 draw 函数</span>

    <span class="token keyword">delete</span> shape1<span class="token punctuation">;</span>
    <span class="token keyword">delete</span> shape2<span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></li></ol><hr><h2 id="_3-多态的优点" tabindex="-1"><a class="header-anchor" href="#_3-多态的优点"><span>3 <strong>多态的优点</strong></span></a></h2><ul><li><strong>代码复用性</strong>：通过继承和虚函数，基类的接口可以被派生类复用。</li><li><strong>灵活性</strong>：可以通过基类指针或引用操作派生类对象，而无需了解具体的派生类。</li><li><strong>可扩展性</strong>：新增派生类时无需修改现有代码，只需实现基类的接口。</li></ul><hr><h2 id="_4-多态的实现机制" tabindex="-1"><a class="header-anchor" href="#_4-多态的实现机制"><span>4 <strong>多态的实现机制</strong></span></a></h2><p>运行时多态的实现依赖于<strong>虚函数表（vtable）<strong>和</strong>虚函数指针（vptr）</strong>：</p><ul><li>每个包含虚函数的类都有一个虚函数表，表中存储了该类的虚函数地址。</li><li>每个对象都有一个虚函数指针，指向所属类的虚函数表。</li><li>当通过基类指针或引用调用虚函数时，程序会根据虚函数指针查找虚函数表，从而调用正确的函数。</li></ul><hr><h2 id="_5-多态的限制" tabindex="-1"><a class="header-anchor" href="#_5-多态的限制"><span>5 <strong>多态的限制</strong></span></a></h2><ul><li>静态多态无法实现运行时的动态行为。</li><li>动态多态需要额外的内存和运行时开销。</li><li>构造函数和析构函数不能是虚函数，但析构函数通常需要声明为虚函数以避免内存泄漏。</li></ul><hr><h2 id="_6-总结" tabindex="-1"><a class="header-anchor" href="#_6-总结"><span>6 总结</span></a></h2><p>C++ 中的多态通过静态多态和动态多态提供了灵活的接口设计能力。静态多态通过函数重载和运算符重载实现，运行时多态通过继承和虚函数实现。多态是面向对象编程的核心特性之一，能够显著提高代码的可扩展性和可维护性。</p>`,30)])])}const u=s(o,[["render",e]]),i=JSON.parse('{"path":"/develop/CPP/6_polymorphism.html","title":"6. C++ 多态","lang":"zh-CN","frontmatter":{"category":"C++","tags":["Cpp"],"description":"6. C++ 多态 在 C++ 中，多态（Polymorphism） 是面向对象编程（OOP）的核心特性之一，它允许同一个接口在不同的场景下表现出不同的行为。多态的主要目的是通过统一的接口实现不同的功能，从而提高代码的灵活性和可扩展性。 C++ 中的多态分为两种类型：编译时多态（静态多态） 和 运行时多态（动态多态）。 1 编译时多态（静态多态） 编译...","head":[["meta",{"property":"og:url","content":"https://echo0d.github.io/DailyNotes/develop/CPP/6_polymorphism.html"}],["meta",{"property":"og:site_name","content":"echo0d-notes"}],["meta",{"property":"og:title","content":"6. C++ 多态"}],["meta",{"property":"og:description","content":"6. C++ 多态 在 C++ 中，多态（Polymorphism） 是面向对象编程（OOP）的核心特性之一，它允许同一个接口在不同的场景下表现出不同的行为。多态的主要目的是通过统一的接口实现不同的功能，从而提高代码的灵活性和可扩展性。 C++ 中的多态分为两种类型：编译时多态（静态多态） 和 运行时多态（动态多态）。 1 编译时多态（静态多态） 编译..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-05-07T01:17:50.000Z"}],["meta",{"property":"article:author","content":"echo0d"}],["meta",{"property":"article:tag","content":"Cpp"}],["meta",{"property":"article:modified_time","content":"2025-05-07T01:17:50.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"6. C++ 多态\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-05-07T01:17:50.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"echo0d\\",\\"url\\":\\"\\"}]}"]]},"headers":[{"level":2,"title":"1 编译时多态（静态多态）","slug":"_1-编译时多态-静态多态","link":"#_1-编译时多态-静态多态","children":[{"level":3,"title":"1.1 特点","slug":"_1-1-特点","link":"#_1-1-特点","children":[]},{"level":3,"title":"1.2 实现方式","slug":"_1-2-实现方式","link":"#_1-2-实现方式","children":[]}]},{"level":2,"title":"2 运行时多态（动态多态）","slug":"_2-运行时多态-动态多态","link":"#_2-运行时多态-动态多态","children":[{"level":3,"title":"2.1 特点","slug":"_2-1-特点","link":"#_2-1-特点","children":[]},{"level":3,"title":"2.2 实现方式","slug":"_2-2-实现方式","link":"#_2-2-实现方式","children":[]}]},{"level":2,"title":"3 多态的优点","slug":"_3-多态的优点","link":"#_3-多态的优点","children":[]},{"level":2,"title":"4 多态的实现机制","slug":"_4-多态的实现机制","link":"#_4-多态的实现机制","children":[]},{"level":2,"title":"5 多态的限制","slug":"_5-多态的限制","link":"#_5-多态的限制","children":[]},{"level":2,"title":"6 总结","slug":"_6-总结","link":"#_6-总结","children":[]}],"git":{"createdTime":1746580670000,"updatedTime":1746580670000,"contributors":[{"name":"echo0d","email":"echo0d@163.com","commits":1}]},"readingTime":{"minutes":3.84,"words":1151},"filePathRelative":"develop/CPP/6_polymorphism.md","localizedDate":"2025年5月7日","excerpt":"","autoDesc":true}');export{u as comp,i as data};
