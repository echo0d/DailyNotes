import{_ as s}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as a,b as c,o as e}from"./app-_WqHyd2I.js";const o={};function p(t,n){return e(),a("div",null,[...n[0]||(n[0]=[c(`<h1 id="_12-c语言-i-o-函数" tabindex="-1"><a class="header-anchor" href="#_12-c语言-i-o-函数"><span>12. C语言-I/O 函数</span></a></h1><h2 id="_1-缓存和字节流" tabindex="-1"><a class="header-anchor" href="#_1-缓存和字节流"><span>1 缓存和字节流</span></a></h2><p>严格地说，输入输出函数并不是直接与外部设备通信，而是通过缓存（buffer）进行间接通信。这个小节介绍缓存是什么。</p><p>普通文件一般都保存在磁盘上面，跟 CPU 相比，磁盘读取或写入数据是一个很慢的操作。所以，程序直接读写磁盘是不可行的，可能每执行一行命令，都必须等半天。C 语言的解决方案，就是只要打开一个文件，就在内存里面为这个文件设置一个缓存区。</p><p>程序向文件写入数据时，程序先把数据放入缓存，等到缓存满了，再把里面的数据会一次性写入磁盘文件。这时，缓存区就空了，程序再把新的数据放入缓存，重复整个过程。</p><p>程序从文件读取数据时，文件先把一部分数据放到缓存里面，然后程序从缓存获取数据，等到缓存空了，磁盘文件再把新的数据放入缓存，重复整个过程。</p><p>内存的读写速度比磁盘快得多，缓存的设计减少了读写磁盘的次数，大大提高了程序的执行效率。另外，一次性移动大块数据，要比多次移动小块数据快得多。</p><p>这种读写模式，对于程序来说，就有点像水流（stream），不是一次性读取或写入所有数据，而是一个持续不断的过程。先操作一部分数据，等到缓存吞吐完这部分数据，再操作下一部分数据。这个过程就叫做字节流操作。</p><p>由于缓存读完就空了，所以字节流读取都是只能读一次，第二次就读不到了。这跟读取文件很不一样。</p><p>C 语言的输入输出函数，凡是涉及读写文件，都是属于字节流操作。输入函数从文件获取数据，操作的是输入流；输出函数向文件写入数据，操作的是输出流。</p><h2 id="_2-printf" tabindex="-1"><a class="header-anchor" href="#_2-printf"><span>2 printf()</span></a></h2><p><code>printf()</code>是最常用的输出函数，用于屏幕输出，原型定义在头文件<code>stdio.h</code>，详见《基本语法》一章。</p><h2 id="_3-scanf" tabindex="-1"><a class="header-anchor" href="#_3-scanf"><span>3 scanf()</span></a></h2><h3 id="_3-1-基本用法" tabindex="-1"><a class="header-anchor" href="#_3-1-基本用法"><span>3.1 基本用法</span></a></h3><p><code>scanf()</code>函数用于读取用户的键盘输入。程序运行到这个语句时，会停下来，等待用户从键盘输入。用户输入数据、按下回车键后，<code>scanf()</code>就会处理用户的输入，将其存入变量。它的原型定义在头文件<code>stdio.h</code>。</p><p><code>scanf()</code>的语法跟<code>printf()</code>类似。</p><pre><code class="language-c"><span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">&quot;%d&quot;</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><p>它的第一个参数是一个格式字符串，里面会放置占位符（与<code>printf()</code>的占位符基本一致），告诉编译器如何解读用户的输入，需要提取的数据是什么类型。这是因为 C 语言的数据都是有类型的，<code>scanf()</code>必须提前知道用户输入的数据类型，才能处理数据。它的其余参数就是存放用户输入的变量，格式字符串里面有多少个占位符，就有多少个变量。</p><p>上面示例中，<code>scanf()</code>的第一个参数<code>%d</code>，表示用户输入的应该是一个整数。<code>%d</code>就是一个占位符，<code>%</code>是占位符的标志，<code>d</code>表示整数。第二个参数<code>&amp;i</code>表示，将用户从键盘输入的整数存入变量<code>i</code>。</p><p>注意，变量前面必须加上<code>&amp;</code>运算符（指针变量除外），因为<code>scanf()</code>传递的不是值，而是地址，即将变量<code>i</code>的地址指向用户输入的值。如果这里的变量是指针变量（比如字符串变量），那就不用加<code>&amp;</code>运算符。</p><p>下面是一次将键盘输入读入多个变量的例子。</p><pre><code class="language-c"><span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">&quot;%d%d%f%f&quot;</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>i<span class="token punctuation">,</span> <span class="token operator">&amp;</span>j<span class="token punctuation">,</span> <span class="token operator">&amp;</span>x<span class="token punctuation">,</span> <span class="token operator">&amp;</span>y<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><p>上面示例中，格式字符串<code>%d%d%f%f</code>，表示用户输入的前两个是整数，后两个是浮点数，比如<code>1 -20 3.4 -4.0e3</code>。这四个值依次放入<code>i</code>、<code>j</code>、<code>x</code>、<code>y</code>四个变量。</p><p><code>scanf()</code>处理数值占位符时，会自动过滤空白字符，包括空格、制表符、换行符等。所以，用户输入的数据之间，有一个或多个空格不影响<code>scanf()</code>解读数据。另外，用户使用回车键，将输入分成几行，也不影响解读。</p><pre><code class="language-c"><span class="token number">1</span>
<span class="token operator">-</span><span class="token number">20</span>
<span class="token number">3.4</span>
<span class="token operator">-</span><span class="token number">4.0e3</span>
</code></pre><p>上面示例中，用户分成四行输入，得到的结果与一行输入是完全一样的。每次按下回车键以后，<code>scanf()</code>就会开始解读，如果第一行匹配第一个占位符，那么下次按下回车键时，就会从第二个占位符开始解读。</p><p><code>scanf()</code>处理用户输入的原理是，用户的输入先放入缓存，等到按下回车键后，按照占位符对缓存进行解读。解读用户输入时，会从上一次解读遗留的第一个字符开始，直到读完缓存，或者遇到第一个不符合条件的字符为止。</p><pre><code class="language-c"><span class="token keyword">int</span> x<span class="token punctuation">;</span>
<span class="token keyword">float</span> y<span class="token punctuation">;</span>

<span class="token comment">// 用户输入 &quot;    -13.45e12# 0&quot;</span>
<span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">&quot;%d&quot;</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">&quot;%f&quot;</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>y<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><p>上面示例中，<code>scanf()</code>读取用户输入时，<code>%d</code>占位符会忽略起首的空格，从<code>-</code>处开始获取数据，读取到<code>-13</code>停下来，因为后面的<code>.</code>不属于整数的有效字符。这就是说，占位符<code>%d</code>会读到<code>-13</code>。</p><p>第二次调用<code>scanf()</code>时，就会从上一次停止解读的地方，继续往下读取。这一次读取的首字符是<code>.</code>，由于对应的占位符是<code>%f</code>，会读取到<code>.45e12</code>，这是采用科学计数法的浮点数格式。后面的<code>#</code>不属于浮点数的有效字符，所以会停在这里。</p><p>由于<code>scanf()</code>可以连续处理多个占位符，所以上面的例子也可以写成下面这样。</p><pre><code class="language-c"><span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">&quot;%d%f&quot;</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>x<span class="token punctuation">,</span> <span class="token operator">&amp;</span>y<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><p><code>scanf()</code>的返回值是一个整数，表示成功读取的变量个数。如果没有读取任何项，或者匹配失败，则返回<code>0</code>。如果读取到文件结尾，则返回常量 EOF。</p><h3 id="_3-2-占位符" tabindex="-1"><a class="header-anchor" href="#_3-2-占位符"><span>3.2 占位符</span></a></h3><p><code>scanf()</code>常用的占位符如下，与<code>printf()</code>的占位符基本一致。</p><ul><li><code>%c</code>：字符。</li><li><code>%d</code>：整数。</li><li><code>%f</code>：<code>float</code>类型浮点数。</li><li><code>%lf</code>：<code>double</code>类型浮点数。</li><li><code>%Lf</code>：<code>long double</code>类型浮点数。</li><li><code>%s</code>：字符串。</li><li><code>%[]</code>：在方括号中指定一组匹配的字符（比如<code>%[0-9]</code>），遇到不在集合之中的字符，匹配将会停止。</li></ul><p>上面所有占位符之中，除了<code>%c</code>以外，都会自动忽略起首的空白字符。<code>%c</code>不忽略空白字符，总是返回当前第一个字符，无论该字符是否为空格。如果要强制跳过字符前的空白字符，可以写成<code>scanf(&quot; %c&quot;, &amp;ch)</code>，即<code>%c</code>前加上一个空格，表示跳过零个或多个空白字符。</p><p>下面要特别说一下占位符<code>%s</code>，它其实不能简单地等同于字符串。它的规则是，从当前第一个非空白字符开始读起，直到遇到空白字符（即空格、换行符、制表符等）为止。因为<code>%s</code>不会包含空白字符，所以无法用来读取多个单词，除非多个<code>%s</code>一起使用。这也意味着，<code>scanf()</code>不适合读取可能包含空格的字符串，比如书名或歌曲名。另外，<code>scanf()</code>遇到<code>%s</code>占位符，会在字符串变量末尾存储一个空字符<code>\\0</code>。</p><p><code>scanf()</code>将字符串读入字符数组时，不会检测字符串是否超过了数组长度。所以，储存字符串时，很可能会超过数组的边界，导致预想不到的结果。为了防止这种情况，使用<code>%s</code>占位符时，应该指定读入字符串的最长长度，即写成<code>%[m]s</code>，其中的<code>[m]</code>是一个整数，表示读取字符串的最大长度，后面的字符将被丢弃。</p><pre><code class="language-c"><span class="token keyword">char</span> name<span class="token punctuation">[</span><span class="token number">11</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">&quot;%10s&quot;</span><span class="token punctuation">,</span> name<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><p>上面示例中，<code>name</code>是一个长度为11的字符数组，<code>scanf()</code>的占位符<code>%10s</code>表示最多读取用户输入的10个字符，后面的字符将被丢弃，这样就不会有数组溢出的风险了。</p><h3 id="_3-3-赋值忽略符" tabindex="-1"><a class="header-anchor" href="#_3-3-赋值忽略符"><span>3.3 赋值忽略符</span></a></h3><p>有时，用户的输入可能不符合预定的格式。</p><pre><code class="language-c"><span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">&quot;%d-%d-%d&quot;</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>year<span class="token punctuation">,</span> <span class="token operator">&amp;</span>month<span class="token punctuation">,</span> <span class="token operator">&amp;</span>day<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><p>上面示例中，如果用户输入<code>2020-01-01</code>，就会正确解读出年、月、日。问题是用户可能输入其他格式，比如<code>2020/01/01</code>，这种情况下，<code>scanf()</code>解析数据就会失败。</p><p>为了避免这种情况，<code>scanf()</code>提供了一个赋值忽略符（assignment suppression character）<code>*</code>。只要把<code>*</code>加在任何占位符的百分号后面，该占位符就不会返回值，解析后将被丢弃。</p><pre><code class="language-c"><span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">&quot;%d%*c%d%*c%d&quot;</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>year<span class="token punctuation">,</span> <span class="token operator">&amp;</span>month<span class="token punctuation">,</span> <span class="token operator">&amp;</span>day<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><p>上面示例中，<code>%*c</code>就是在占位符的百分号后面，加入了赋值忽略符<code>*</code>，表示这个占位符没有对应的变量，解读后不必返回。</p><h2 id="_4-sscanf" tabindex="-1"><a class="header-anchor" href="#_4-sscanf"><span>4 sscanf()</span></a></h2><p><code>sscanf()</code>函数与<code>scanf()</code>很类似，不同之处是<code>sscanf()</code>从字符串里面，而不是从用户输入获取数据。它的原型定义在头文件<code>stdio.h</code>里面。</p><pre><code class="language-c"><span class="token keyword">int</span> <span class="token function">sscanf</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> s<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> format<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><p><code>sscanf()</code>的第一个参数是一个字符串指针，用来从其中获取数据。其他参数都与<code>scanf()</code>相同。</p><p><code>sscanf()</code>主要用来处理其他输入函数读入的字符串，从其中提取数据。</p><pre><code class="language-c"><span class="token function">fgets</span><span class="token punctuation">(</span>str<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token constant">stdin</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">sscanf</span><span class="token punctuation">(</span>str<span class="token punctuation">,</span> <span class="token string">&quot;%d%d&quot;</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>i<span class="token punctuation">,</span> <span class="token operator">&amp;</span>j<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><p>上面示例中，<code>fgets()</code>先从标准输入获取了一行数据（<code>fgets()</code>的介绍详见下一章），存入字符数组<code>str</code>。然后，<code>sscanf()</code>再从字符串<code>str</code>里面提取两个整数，放入变量<code>i</code>和<code>j</code>。</p><p><code>sscanf()</code>的一个好处是，它的数据来源不是流数据，所以可以反复使用，不像<code>scanf()</code>的数据来源是流数据，只能读取一次。</p><p><code>sscanf()</code>的返回值是成功赋值的变量的数量，如果提取失败，返回常量 EOF。</p><h2 id="_5-getchar-putchar" tabindex="-1"><a class="header-anchor" href="#_5-getchar-putchar"><span>5 getchar()，putchar()</span></a></h2><p><strong>（1）getchar()</strong></p><p><code>getchar()</code>函数返回用户从键盘输入的一个字符，使用时不带有任何参数。程序运行到这个命令就会暂停，等待用户从键盘输入，等同于使用<code>scanf()</code>方法读取一个字符。它的原型定义在头文件<code>stdio.h</code>。</p><pre><code class="language-c"><span class="token keyword">char</span> ch<span class="token punctuation">;</span>
ch <span class="token operator">=</span> <span class="token function">getchar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 等同于</span>
<span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">&quot;%c&quot;</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>ch<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><p><code>getchar()</code>不会忽略起首的空白字符，总是返回当前读取的第一个字符，无论是否为空格。如果读取失败，返回常量 EOF，由于 EOF 通常是<code>-1</code>，所以返回值的类型要设为 int，而不是 char。</p><p>由于<code>getchar()</code>返回读取的字符，所以可以用在循环条件之中。</p><pre><code class="language-c"><span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token function">getchar</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token char">&#39;\\n&#39;</span><span class="token punctuation">)</span>
  <span class="token punctuation">;</span>
</code></pre><p>上面示例中，只有读到的字符等于换行符（<code>\\n</code>），才会退出循环，常用来跳过某行。<code>while</code>循环的循环体没有任何语句，表示对该行不执行任何操作。</p><p>下面的例子是计算某一行的字符长度。</p><pre><code class="language-c"><span class="token keyword">int</span> len <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token keyword">while</span><span class="token punctuation">(</span><span class="token function">getchar</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token char">&#39;\\n&#39;</span><span class="token punctuation">)</span>
  len<span class="token operator">++</span><span class="token punctuation">;</span>
</code></pre><p>上面示例中，<code>getchar()</code>每读取一个字符，长度变量<code>len</code>就会加1，直到读取到换行符为止，这时<code>len</code>就是该行的字符长度。</p><p>下面的例子是跳过空格字符。</p><pre><code class="language-c"><span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>ch <span class="token operator">=</span> <span class="token function">getchar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token char">&#39; &#39;</span><span class="token punctuation">)</span>
  <span class="token punctuation">;</span>
</code></pre><p>上面示例中，结束循环后，变量<code>ch</code>等于第一个非空格字符。</p><p><strong>（2）putchar()</strong></p><p><code>putchar()</code>函数将它的参数字符输出到屏幕，等同于使用<code>printf()</code>输出一个字符。它的原型定义在头文件<code>stdio.h</code>。</p><pre><code class="language-c"><span class="token function">putchar</span><span class="token punctuation">(</span>ch<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 等同于</span>
<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;%c&quot;</span><span class="token punctuation">,</span> ch<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><p>操作成功时，<code>putchar()</code>返回输出的字符，否则返回常量 EOF。</p><p><strong>（3）小结</strong></p><p>由于<code>getchar()</code>和<code>putchar()</code>这两个函数的用法，要比<code>scanf()</code>和<code>printf()</code>更简单，而且通常是用宏来实现，所以要比<code>scanf()</code>和<code>printf()</code>更快。如果操作单个字符，建议优先使用这两个函数。</p><h2 id="_6-puts" tabindex="-1"><a class="header-anchor" href="#_6-puts"><span>6 puts()</span></a></h2><p><code>puts()</code>函数用于将参数字符串显示在屏幕（stdout）上，并且自动在字符串末尾添加换行符。它的原型定义在头文件<code>stdio.h</code>。</p><pre><code class="language-c"><span class="token function">puts</span><span class="token punctuation">(</span><span class="token string">&quot;Here are some messages:&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">puts</span><span class="token punctuation">(</span><span class="token string">&quot;Hello World&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><p>上面示例中，<code>puts()</code>在屏幕上输出两行内容。</p><p>写入成功时，<code>puts()</code>返回一个非负整数，否则返回常量 EOF。</p><h2 id="_7-gets" tabindex="-1"><a class="header-anchor" href="#_7-gets"><span>7 gets()</span></a></h2><p><code>gets()</code>函数以前用于从<code>stdin</code>读取整行输入，现在已经被废除了，仍然放在这里介绍一下。</p><p>该函数读取用户的一行输入，不会跳过起始处的空白字符，直到遇到换行符为止。这个函数会丢弃换行符，将其余字符放入参数变量，并在这些字符的末尾添加一个空字符<code>\\0</code>，使其成为一个字符串。</p><p>它经常与<code>puts()</code>配合使用。</p><pre><code class="language-c"><span class="token keyword">char</span> words<span class="token punctuation">[</span><span class="token number">81</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

<span class="token function">puts</span><span class="token punctuation">(</span><span class="token string">&quot;Enter a string, please&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">gets</span><span class="token punctuation">(</span>words<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><p>上面示例使用<code>puts()</code>在屏幕上输出提示，然后使用<code>gets()</code>获取用户的输入。</p><p>由于<code>gets()</code>获取的字符串，可能超过字符数组变量的最大长度，有安全风险，建议不要使用，改为使用<code>fgets()</code>。</p>`,89)])])}const u=s(o,[["render",p]]),r=JSON.parse('{"path":"/develop/C/12_IO.html","title":"12. C语言-I/O 函数","lang":"zh-CN","frontmatter":{"category":"C","tags":["C"],"description":"12. C语言-I/O 函数 1 缓存和字节流 严格地说，输入输出函数并不是直接与外部设备通信，而是通过缓存（buffer）进行间接通信。这个小节介绍缓存是什么。 普通文件一般都保存在磁盘上面，跟 CPU 相比，磁盘读取或写入数据是一个很慢的操作。所以，程序直接读写磁盘是不可行的，可能每执行一行命令，都必须等半天。C 语言的解决方案，就是只要打开一个文...","head":[["meta",{"property":"og:url","content":"https://echo0d.github.io/DailyNotes/develop/C/12_IO.html"}],["meta",{"property":"og:site_name","content":"echo0d-notes"}],["meta",{"property":"og:title","content":"12. C语言-I/O 函数"}],["meta",{"property":"og:description","content":"12. C语言-I/O 函数 1 缓存和字节流 严格地说，输入输出函数并不是直接与外部设备通信，而是通过缓存（buffer）进行间接通信。这个小节介绍缓存是什么。 普通文件一般都保存在磁盘上面，跟 CPU 相比，磁盘读取或写入数据是一个很慢的操作。所以，程序直接读写磁盘是不可行的，可能每执行一行命令，都必须等半天。C 语言的解决方案，就是只要打开一个文..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-04-11T02:11:10.000Z"}],["meta",{"property":"article:author","content":"echo0d"}],["meta",{"property":"article:tag","content":"C"}],["meta",{"property":"article:modified_time","content":"2025-04-11T02:11:10.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"12. C语言-I/O 函数\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-04-11T02:11:10.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"echo0d\\",\\"url\\":\\"\\"}]}"]]},"headers":[{"level":2,"title":"1 缓存和字节流","slug":"_1-缓存和字节流","link":"#_1-缓存和字节流","children":[]},{"level":2,"title":"2 printf()","slug":"_2-printf","link":"#_2-printf","children":[]},{"level":2,"title":"3 scanf()","slug":"_3-scanf","link":"#_3-scanf","children":[{"level":3,"title":"3.1 基本用法","slug":"_3-1-基本用法","link":"#_3-1-基本用法","children":[]},{"level":3,"title":"3.2 占位符","slug":"_3-2-占位符","link":"#_3-2-占位符","children":[]},{"level":3,"title":"3.3 赋值忽略符","slug":"_3-3-赋值忽略符","link":"#_3-3-赋值忽略符","children":[]}]},{"level":2,"title":"4 sscanf()","slug":"_4-sscanf","link":"#_4-sscanf","children":[]},{"level":2,"title":"5 getchar()，putchar()","slug":"_5-getchar-putchar","link":"#_5-getchar-putchar","children":[]},{"level":2,"title":"6 puts()","slug":"_6-puts","link":"#_6-puts","children":[]},{"level":2,"title":"7 gets()","slug":"_7-gets","link":"#_7-gets","children":[]}],"git":{"createdTime":1743069738000,"updatedTime":1744337470000,"contributors":[{"name":"echo0d","email":"echo0d@163.com","commits":3}]},"readingTime":{"minutes":11.07,"words":3322},"filePathRelative":"develop/C/12_IO.md","localizedDate":"2025年3月27日","excerpt":"","autoDesc":true}');export{u as comp,r as data};
