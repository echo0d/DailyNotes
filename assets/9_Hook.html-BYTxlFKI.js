import{_ as a}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as s,b as t,o}from"./app-Bkx5eYAF.js";const e={};function p(c,n){return o(),s("div",null,[...n[0]||(n[0]=[t(`<h1 id="java-hook-方法整理" tabindex="-1"><a class="header-anchor" href="#java-hook-方法整理"><span>Java Hook 方法整理</span></a></h1><p>在 Java 中，Hook 技术主要用于在不修改原始代码的情况下，对程序的执行流程进行拦截和增强。根据 Hook 生效的时机，可以将其分为 <strong>静态 Hook (编译期/加载期)</strong> 和 <strong>动态 Hook (运行期)</strong>。</p><h2 id="_1-静态-hook-static-hook" tabindex="-1"><a class="header-anchor" href="#_1-静态-hook-static-hook"><span>1. 静态 Hook (Static Hook)</span></a></h2><p>静态 Hook 指在程序运行之前（编译阶段）或类加载阶段（Load Time）修改字节码。</p><h3 id="_1-1-aspectj-编译时织入-compile-time-weaving" tabindex="-1"><a class="header-anchor" href="#_1-1-aspectj-编译时织入-compile-time-weaving"><span>1.1 AspectJ (编译时织入 - Compile-Time Weaving)</span></a></h3><p>AspectJ 是最成熟的 AOP 框架，它可以在编译阶段将切面代码直接织入到目标类的 <code>.class</code> 文件中。</p><ul><li><strong>原理</strong>：使用 <code>ajc</code> 编译器代替 <code>javac</code>，在编译时修改字节码。</li><li><strong>优点</strong>： <ul><li>运行效率高（无运行时代理开销）。</li><li>功能最强（可 Hook 构造函数、静态方法、final 方法、私有方法）。</li></ul></li><li><strong>缺点</strong>：需要特定的编译工具链支持，配置相对复杂。</li><li><strong>示例</strong>：<pre><code class="language-java"><span class="token keyword">public</span> aspect <span class="token class-name">LogAspect</span> <span class="token punctuation">{</span>
    <span class="token comment">// 定义切点：所有 Service 结尾类的所有方法</span>
    pointcut <span class="token function">serviceMethods</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token function">execution</span><span class="token punctuation">(</span><span class="token operator">*</span> <span class="token operator">*</span><span class="token punctuation">.</span><span class="token punctuation">.</span>*<span class="token class-name">Service</span><span class="token punctuation">.</span>*<span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// 前置通知</span>
    <span class="token function">before</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token function">serviceMethods</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;Before method execution&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></li></ul><h3 id="_1-2-java-agent-premain-加载时织入" tabindex="-1"><a class="header-anchor" href="#_1-2-java-agent-premain-加载时织入"><span>1.2 Java Agent (Premain - 加载时织入)</span></a></h3><p>利用 JVM 的 <code>Instrumentation</code> API，在类加载（Class Loading）阶段修改字节码。</p><ul><li><strong>原理</strong>： <ol><li>编写一个包含 <code>premain</code> 方法的 Agent Jar。</li><li>启动应用时添加参数 <code>-javaagent:myagent.jar</code>。</li><li>JVM 启动时加载 Agent，调用 <code>premain</code>。</li><li>Agent 注册 <code>ClassFileTransformer</code>。</li><li>当类被加载时，Transformer 拦截字节码并进行修改（使用 ASM, Javassist, ByteBuddy 等库）。</li></ol></li><li><strong>示例</strong>：<pre><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">premain</span><span class="token punctuation">(</span><span class="token class-name">String</span> agentArgs<span class="token punctuation">,</span> <span class="token class-name">Instrumentation</span> inst<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    inst<span class="token punctuation">.</span><span class="token function">addTransformer</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">MyClassFileTransformer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></li><li><strong>场景</strong>：全链路监控（SkyWalking, Pinpoint）、全局日志埋点。</li></ul><hr><h2 id="_2-动态-hook-runtime-hook" tabindex="-1"><a class="header-anchor" href="#_2-动态-hook-runtime-hook"><span>2. 动态 Hook (Runtime Hook)</span></a></h2><p>动态 Hook 指在程序运行过程中，动态地创建代理对象或修改已加载的类。</p><h3 id="_2-1-动态代理-dynamic-proxy" tabindex="-1"><a class="header-anchor" href="#_2-1-动态代理-dynamic-proxy"><span>2.1 动态代理 (Dynamic Proxy)</span></a></h3><p>JDK 自带的动态代理机制，基于接口实现。</p><ul><li><strong>原理</strong>：利用 <code>java.lang.reflect.Proxy</code> 在内存中生成一个实现了目标接口的新类。</li><li><strong>限制</strong>：<strong>只能代理接口</strong>，无法代理未实现接口的类。</li><li><strong>示例</strong>：<pre><code class="language-java"><span class="token class-name">Service</span> proxy <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">Service</span><span class="token punctuation">)</span> <span class="token class-name">Proxy</span><span class="token punctuation">.</span><span class="token function">newProxyInstance</span><span class="token punctuation">(</span>loader<span class="token punctuation">,</span> interfaces<span class="token punctuation">,</span> handler<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></li></ul><h3 id="_2-2-cglib-bytebuddy-子类代理" tabindex="-1"><a class="header-anchor" href="#_2-2-cglib-bytebuddy-子类代理"><span>2.2 CGLIB / ByteBuddy (子类代理)</span></a></h3><p>通过生成目标类的子类来实现代理。</p><ul><li><strong>原理</strong>：在运行时动态生成目标类的子类，并重写非 <code>final</code> 方法，在子类中插入拦截逻辑。</li><li><strong>优点</strong>：无需接口，可代理普通类。</li><li><strong>限制</strong>：<strong>无法代理 final 类或 final 方法</strong>。</li><li><strong>场景</strong>：Spring AOP (无接口时默认使用 CGLIB)。</li><li><strong>示例 (CGLIB)</strong>：<pre><code class="language-java"><span class="token class-name">Enhancer</span> enhancer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Enhancer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
enhancer<span class="token punctuation">.</span><span class="token function">setSuperclass</span><span class="token punctuation">(</span><span class="token class-name">TargetClass</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
enhancer<span class="token punctuation">.</span><span class="token function">setCallback</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">MethodInterceptor</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>obj<span class="token punctuation">,</span> method<span class="token punctuation">,</span> args<span class="token punctuation">,</span> proxy<span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>
    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;Before &quot;</span> <span class="token operator">+</span> method<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">Object</span> result <span class="token operator">=</span> proxy<span class="token punctuation">.</span><span class="token function">invokeSuper</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 注意调用 invokeSuper</span>
    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;After &quot;</span> <span class="token operator">+</span> method<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> result<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">TargetClass</span> proxy <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">TargetClass</span><span class="token punctuation">)</span> enhancer<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></li></ul><h3 id="_2-3-java-agent-agentmain-运行时重定义" tabindex="-1"><a class="header-anchor" href="#_2-3-java-agent-agentmain-运行时重定义"><span>2.3 Java Agent (Agentmain - 运行时重定义)</span></a></h3><p>利用 JVM 的 Attach 机制，在 JVM 运行时动态注入 Agent。</p><ul><li><strong>原理</strong>： <ol><li>通过 <code>VirtualMachine.attach(pid)</code> 连接到目标 JVM 进程。</li><li>加载 Agent Jar，触发 <code>agentmain</code> 方法。</li><li>获取 <code>Instrumentation</code> 实例。</li><li>调用 <code>inst.retransformClasses(targetClass)</code> 触发类的重定义。</li></ol></li><li><strong>能力</strong>：可以在不重启应用的情况下修改类逻辑（热部署）。</li><li><strong>限制</strong>：运行时修改字节码有严格限制（如不能新增/删除字段或方法，只能修改方法体）。</li><li><strong>场景</strong>：Arthas (在线诊断), JRebel (热部署)。</li><li><strong>示例</strong>：<pre><code class="language-java"><span class="token comment">// Agentmain 入口</span>
<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">agentmain</span><span class="token punctuation">(</span><span class="token class-name">String</span> agentArgs<span class="token punctuation">,</span> <span class="token class-name">Instrumentation</span> inst<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    inst<span class="token punctuation">.</span><span class="token function">addTransformer</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">MyClassFileTransformer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">try</span> <span class="token punctuation">{</span>
        <span class="token comment">// 触发已加载类的重转换</span>
        inst<span class="token punctuation">.</span><span class="token function">retransformClasses</span><span class="token punctuation">(</span><span class="token class-name">TargetClass</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">UnmodifiableClassException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">// Attach 客户端代码 (通常在另一个进程运行)</span>
<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{</span>
    <span class="token class-name">String</span> pid <span class="token operator">=</span> <span class="token string">&quot;12345&quot;</span><span class="token punctuation">;</span> <span class="token comment">// 目标 JVM 进程 ID</span>
    <span class="token class-name">VirtualMachine</span> vm <span class="token operator">=</span> <span class="token class-name">VirtualMachine</span><span class="token punctuation">.</span><span class="token function">attach</span><span class="token punctuation">(</span>pid<span class="token punctuation">)</span><span class="token punctuation">;</span>
    vm<span class="token punctuation">.</span><span class="token function">loadAgent</span><span class="token punctuation">(</span><span class="token string">&quot;/path/to/agent.jar&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    vm<span class="token punctuation">.</span><span class="token function">detach</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></li></ul><h3 id="_2-4-native-hook-jni-jvmti" tabindex="-1"><a class="header-anchor" href="#_2-4-native-hook-jni-jvmti"><span>2.4 Native Hook (JNI / JVMTI)</span></a></h3><p>跳出 JVM 层面，直接在操作系统或 Native 层面进行 Hook。</p><ul><li><strong>原理</strong>：使用 JNI 调用 C/C++ 代码，利用操作系统的 Hook 技术（如 PLT Hook, Inline Hook）或 JVMTI (JVM Tool Interface) 事件回调。</li><li><strong>场景</strong>： <ul><li>JVM 自身性能分析（Profiler）。</li><li>深度调试。</li><li>系统级调用监控。</li></ul></li></ul><hr><h3 id="总结对比" tabindex="-1"><a class="header-anchor" href="#总结对比"><span>总结对比</span></a></h3><table><thead><tr><th style="text-align:left;">类别</th><th style="text-align:left;">技术方案</th><th style="text-align:left;">生效时机</th><th style="text-align:left;">核心特点</th><th style="text-align:left;">适用场景</th></tr></thead><tbody><tr><td style="text-align:left;"><strong>静态 Hook</strong></td><td style="text-align:left;"><strong>AspectJ (CTW)</strong></td><td style="text-align:left;">编译期</td><td style="text-align:left;">修改 .class 文件，性能最高，无限制</td><td style="text-align:left;">复杂切面，高性能要求</td></tr><tr><td style="text-align:left;"><strong>静态 Hook</strong></td><td style="text-align:left;"><strong>Java Agent (Premain)</strong></td><td style="text-align:left;">类加载期</td><td style="text-align:left;">修改字节码，无侵入</td><td style="text-align:left;">APM 监控，字节码增强</td></tr><tr><td style="text-align:left;"><strong>动态 Hook</strong></td><td style="text-align:left;"><strong>JDK 动态代理</strong></td><td style="text-align:left;">运行时</td><td style="text-align:left;">基于接口，生成代理对象</td><td style="text-align:left;">RPC, 简单 AOP</td></tr><tr><td style="text-align:left;"><strong>动态 Hook</strong></td><td style="text-align:left;"><strong>CGLIB/ByteBuddy</strong></td><td style="text-align:left;">运行时</td><td style="text-align:left;">基于子类，生成代理对象</td><td style="text-align:left;">Spring AOP</td></tr><tr><td style="text-align:left;"><strong>动态 Hook</strong></td><td style="text-align:left;"><strong>Java Agent (Attach)</strong></td><td style="text-align:left;">运行时</td><td style="text-align:left;">重定义已加载的类 (Retransform)</td><td style="text-align:left;">在线诊断 (Arthas)，热修复</td></tr></tbody></table>`,28)])])}const u=a(e,[["render",p]]),r=JSON.parse('{"path":"/develop/Java/9_Hook.html","title":"Java Hook 方法整理","lang":"zh-CN","frontmatter":{"description":"Java Hook 方法整理 在 Java 中，Hook 技术主要用于在不修改原始代码的情况下，对程序的执行流程进行拦截和增强。根据 Hook 生效的时机，可以将其分为 静态 Hook (编译期/加载期) 和 动态 Hook (运行期)。 1. 静态 Hook (Static Hook) 静态 Hook 指在程序运行之前（编译阶段）或类加载阶段（Loa...","head":[["meta",{"property":"og:url","content":"https://echo0d.github.io/DailyNotes/develop/Java/9_Hook.html"}],["meta",{"property":"og:site_name","content":"echo0d-notes"}],["meta",{"property":"og:title","content":"Java Hook 方法整理"}],["meta",{"property":"og:description","content":"Java Hook 方法整理 在 Java 中，Hook 技术主要用于在不修改原始代码的情况下，对程序的执行流程进行拦截和增强。根据 Hook 生效的时机，可以将其分为 静态 Hook (编译期/加载期) 和 动态 Hook (运行期)。 1. 静态 Hook (Static Hook) 静态 Hook 指在程序运行之前（编译阶段）或类加载阶段（Loa..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-11-21T09:57:45.000Z"}],["meta",{"property":"article:author","content":"echo0d"}],["meta",{"property":"article:modified_time","content":"2025-11-21T09:57:45.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Java Hook 方法整理\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-11-21T09:57:45.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"echo0d\\",\\"url\\":\\"\\"}]}"]]},"headers":[{"level":2,"title":"1. 静态 Hook (Static Hook)","slug":"_1-静态-hook-static-hook","link":"#_1-静态-hook-static-hook","children":[{"level":3,"title":"1.1 AspectJ (编译时织入 - Compile-Time Weaving)","slug":"_1-1-aspectj-编译时织入-compile-time-weaving","link":"#_1-1-aspectj-编译时织入-compile-time-weaving","children":[]},{"level":3,"title":"1.2 Java Agent (Premain - 加载时织入)","slug":"_1-2-java-agent-premain-加载时织入","link":"#_1-2-java-agent-premain-加载时织入","children":[]}]},{"level":2,"title":"2. 动态 Hook (Runtime Hook)","slug":"_2-动态-hook-runtime-hook","link":"#_2-动态-hook-runtime-hook","children":[{"level":3,"title":"2.1 动态代理 (Dynamic Proxy)","slug":"_2-1-动态代理-dynamic-proxy","link":"#_2-1-动态代理-dynamic-proxy","children":[]},{"level":3,"title":"2.2 CGLIB / ByteBuddy (子类代理)","slug":"_2-2-cglib-bytebuddy-子类代理","link":"#_2-2-cglib-bytebuddy-子类代理","children":[]},{"level":3,"title":"2.3 Java Agent (Agentmain - 运行时重定义)","slug":"_2-3-java-agent-agentmain-运行时重定义","link":"#_2-3-java-agent-agentmain-运行时重定义","children":[]},{"level":3,"title":"2.4 Native Hook (JNI / JVMTI)","slug":"_2-4-native-hook-jni-jvmti","link":"#_2-4-native-hook-jni-jvmti","children":[]},{"level":3,"title":"总结对比","slug":"总结对比","link":"#总结对比","children":[]}]}],"git":{"createdTime":1759203108000,"updatedTime":1763719065000,"contributors":[{"name":"echo0d","email":"echo0d@163.com","commits":2}]},"readingTime":{"minutes":3.6,"words":1079},"filePathRelative":"develop/Java/9_Hook.md","localizedDate":"2025年9月30日","excerpt":"","autoDesc":true}');export{u as comp,r as data};
