import{_ as o}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as t,b as s,o as r}from"./app-BDHo8HdU.js";const n="/DailyNotes/assets/file-20250507151507893-D4VkIhBw.png",i="/DailyNotes/assets/file-20250507151528478-B48IlQa9.png",d={};function l(c,e){return r(),t("div",null,[...e[0]||(e[0]=[s('<h1 id="windows-构架及进程创建总结" tabindex="-1"><a class="header-anchor" href="#windows-构架及进程创建总结"><span>Windows 构架及进程创建总结</span></a></h1><p>学习 Windows 基本架构及进程创建的原理。</p><h2 id="windows-构架" tabindex="-1"><a class="header-anchor" href="#windows-构架"><span>Windows 构架</span></a></h2><p>下面是现代操作系统的基本结构示意图，结合示图，可以更好地理解操作系统的作用。 <img src="'+n+'" alt="" loading="lazy"></p><p>由上图可知，对应的应用通过操作系统提供的系统服务来进行硬件的操作，例如打字，看电影，应用是不需要同硬件直接打交道的，这样可以节省大量的精力，而与硬件打交道的脏活累活由操作系统来做。同时，多个任务在“同时进行”中，操作系统需要保证对应的资源分配，让多个任务正常运行。</p><p>下图是 windows 系统结构图， <img src="'+i+'" alt="" loading="lazy"></p><p>我们可以看到 windows 是分为<strong>用户</strong>和<strong>内核</strong>这两种模式，顾名思义，这两种模式之间的主要区别是对系统数据访问权限的不同，内核模式有更高的权限，采取这种做法的一个原因是保护操作系统，避免应用程序错误影响到操作系统本身。操作系统核心运行在内核模式下，应用程序的代码运行在用户模式中下。当应用程序使需要使用系统内核或内核拓展模块(内核驱动程序)所提供的服务事，应用程序会通过硬件指令从用户模式切换到内核模式中，当系统内核完成了所请求的服务后，重新切换到用户模式下。所以，有时候多线程程序不一定高效，是因为线程切换，管理等需要由用户模式切换到内核模式，这类操作会占用很多 cpu 周期。</p><h3 id="用户模式" tabindex="-1"><a class="header-anchor" href="#用户模式"><span>用户模式</span></a></h3><p>由图可知，用户模式进程可以分为<strong>系统支持进程</strong>、 <strong>服务进程</strong>、 <strong>用户应用程序</strong>、 <strong>子系统</strong>四种基本类型：</p><ul><li>固定的<strong>系统支持进程</strong>(system support process), 比如登录进程和会话管理器(session manager)。</li><li><strong>服务进程</strong>(service process) windows 的服务, 例如，任务管理器。windows 服务一般独立于用户登录而运行。</li><li><strong>用户应用程序</strong>(user application),顾名思义，用户写的程序，例如 QQ，迅雷等等。</li><li><strong>子系统进程</strong>，子系统进程是运行在用户模式下的进程，用于支持特定类型的应用程序或提供特定功能。它们通过调用内核模块提供的服务来完成任务。</li></ul><p>Windows 支持的子系统涵盖了从传统的 Windows 应用到 Linux 和 Android 应用的运行环境，主要包括：</p><ul><li><p><strong>Win32 子系统</strong>（核心子系统）</p></li><li><p><strong>POSIX 子系统</strong>（历史支持）</p></li><li><p><strong>Windows Subsystem for Linux (WSL)</strong>（现代 Linux 支持）</p></li><li><p><strong>.NET 子系统</strong>（托管代码支持）</p></li><li><p><strong>Windows Subsystem for Android (WSA)</strong>（Android 支持）</p><ol><li>Win32 子系统：提供 Windows API，支持大多数 Windows 应用程序，是 Windows 的核心子系统，负责管理窗口、图形、输入设备、文件系统等，支持 32 位和 64 位应用程序，主要用于运行传统的 Windows 桌面应用程序。</li><li>POSIX 子系统：支持基于 POSIX 标准的应用程序，提供对 UNIX 风格应用程序的兼容性，在早期版本的 Windows（如 Windows NT）中较为常见，后续被 Windows Subsystem for Linux (WSL) 替代，主要用于运行符合 POSIX 标准的 UNIX 应用程序（较少使用）。</li><li>Windows Subsystem for Linux (WSL)：允许用户在 Windows 上运行原生的 Linux 二进制程序，提供一个完整的 Linux 用户模式环境，支持多种 Linux 发行版（如 Ubuntu、Debian、Fedora 等），WSL 2 引入了完整的 Linux 内核，性能更高，主要用于开发人员在 Windows 上运行 Linux 工具和脚本。</li><li>OS/2 子系统（已废弃）：支持运行 IBM OS/2 应用程序，在早期的 Windows NT 系列中提供支持，后续版本中逐渐被移除，主要用于运行 OS/2 应用程序（历史遗留功能）。</li><li>.NET 子系统：支持基于 .NET Framework 和 .NET Core 的托管代码应用程序，提供跨平台支持（通过 .NET Core 和 .NET 6+），支持多种语言（如 C#、VB.NET、F# 等），主要用于开发和运行现代化的 .NET 应用程序。</li><li>DOS 子系统 (NTVDM)：支持运行 16 位的 MS-DOS 应用程序，在 32 位版本的 Windows 中提供支持，但在 64 位版本的 Windows 中已被移除，主要用于运行旧的 DOS 程序（仅限 32 位系统）。</li><li>Windows Subsystem for Android (WSA)：支持运行 Android 应用程序，在 Windows 11 中引入，提供一个虚拟化环境运行 Android 应用，主要用于在 Windows 上运行 Android 应用程序。</li></ol></li></ul><p>这些子系统使 Windows 能够兼容多种应用程序环境，涵盖从传统的 Windows 应用到 Linux 和 Android 应用的运行支持。</p><p><code>ntdll.dll</code>  是 Windows 系统的核心动态链接库，位于  System32 文件夹，提供底层系统调用接口（Native API），用于用户模式程序与内核模式交互。它负责内存管理、线程管理、异常处理等功能，是许多系统组件和应用程序运行的基础。开发者通常通过更高级别的 API 间接使用它。</p><h3 id="内核模式" tabindex="-1"><a class="header-anchor" href="#内核模式"><span>内核模式</span></a></h3><p>内核模式的组成部分包括：</p><ul><li><strong>Windows 执行体</strong>：提供基本的操作系统服务，例如内存管理、进程和线程管理、安全性、I/O、网络和跨进程通信。</li><li><strong>Windows 内核</strong>：提供低层次的操作系统功能，例如线程调度、中断和异常分发、多处理器同步等，并为执行体提供基础支持。</li><li><strong>设备驱动程序 (Device Driver)</strong>：包括硬件设备驱动程序和非硬件设备驱动程序（如文件系统和网络驱动程序），将用户的 I/O 调用转换为硬件 I/O 请求。</li><li><strong>硬件抽象层 (HAL)</strong>：隔离内核、设备驱动程序和执行体与硬件的差异，使操作系统能够适配不同的硬件平台。</li></ul><p>执行体与内核的区别： Windows 内核负责实现操作系统的基本机制，而所有策略决定则留给执行体。执行体中的对象大多封装了一个或多个内核对象，并通过句柄等方式暴露给应用程序。这种设计体现了机制与策略分离的思想。我们在设计接口时也应考虑这一原则，尽量提供基础功能，具体的变化由这些功能组合实现，从而使接口能够灵活适应不断变化的需求。</p><h2 id="进程创建过程" tabindex="-1"><a class="header-anchor" href="#进程创建过程"><span>进程创建过程</span></a></h2><p>在 Windows 操作系统中，进程的创建确实可以在 <strong>Ring 3（用户模式）</strong> 和 <strong>Ring 0（内核模式）</strong> 下进行，具体如下：</p><ol><li><strong>Ring 3（用户模式）下的进程创建</strong></li></ol><ul><li><strong>方式</strong>：通过调用 Win32 API 函数 <code>CreateProcess</code> 或类似的高层次接口。</li><li><strong>过程</strong>： <ul><li>用户模式程序调用 <code>CreateProcess</code>。</li><li><code>CreateProcess</code> 会通过系统调用（如 <code>NtCreateProcess</code>）将请求传递到内核模式。</li><li>内核模式完成实际的进程创建工作（如分配资源、初始化进程对象等）。</li></ul></li><li><strong>特点</strong>： <ul><li>用户模式下的进程创建是通过高层次的 API 完成的，开发者无需直接处理底层细节。</li><li>这是大多数应用程序创建进程的常见方式。</li></ul></li></ul><p><strong>2. Ring 0（内核模式）下的进程创建</strong></p><ul><li><strong>方式</strong>：通过调用内核模式函数（如 <code>PsCreateSystemProcess</code> 或 <code>PsCreateProcess</code>）。</li><li><strong>过程</strong>： <ul><li>内核模式代码（如驱动程序或内核组件）直接调用内核函数来创建进程。</li><li>内核模式下的进程创建可以绕过用户模式的 API，直接操作内核数据结构。</li></ul></li><li><strong>特点</strong>： <ul><li>通常用于系统级任务，例如驱动程序创建辅助进程或系统服务。</li><li>需要更高的权限，且开发者需要对内核机制有深入了解。</li><li>如果操作不当，可能导致系统崩溃或安全问题。</li></ul></li></ul><p><strong>Ring 3 和 Ring 0 的区别</strong></p><table><thead><tr><th><strong>特性</strong></th><th><strong>Ring 3（用户模式）</strong></th><th><strong>Ring 0（内核模式）</strong></th></tr></thead><tbody><tr><td><strong>权限级别</strong></td><td>低权限，受内核保护</td><td>高权限，完全访问系统资源</td></tr><tr><td><strong>调用方式</strong></td><td>通过高层 API（如 <code>CreateProcess</code>）</td><td>直接调用内核函数（如 <code>PsCreateProcess</code>）</td></tr><tr><td><strong>适用场景</strong></td><td>普通应用程序</td><td>系统级任务或驱动程序</td></tr><tr><td><strong>安全性</strong></td><td>更安全，受内核保护</td><td>操作不当可能导致系统崩溃</td></tr></tbody></table><h3 id="进程创建流程" tabindex="-1"><a class="header-anchor" href="#进程创建流程"><span>进程创建流程</span></a></h3><p>当一个应用程序调用某个进程创建函数，比如<code>CreateProcess</code>、<code>CreateProcessAsUser</code>、<code>CreateProcessWithTokenW</code>、<code>CreateProcessWithLogonW</code>时，一个 windows 进程就被创建起来了。</p><p>创建一个 windows 进程的过程，是由操作系统的三个部分执行一些列步骤来完成的</p><ol><li>客户方的 windows 库 Kernel32.dll</li><li>windows 执行体</li><li>windows 子系统进程(Csrss.exe)</li></ol><p>由于 windows 是多环境子系统的体系结构，因此，创建一个 windows 执行体进程对象(其他的子系统也可以使用)，与创建一个 windows 进程的工作是分离的。</p><p>也就是说 windows 在创建进程的过程中有两大类的工作要做:</p><ol><li>windows 系统加入的语义</li><li>执行体/内核层对象等的创建</li></ol><p>下面概括了一下在利用 windows 的<code>CreateProcess</code>函数来创建一个进程时所涉及的主要阶段:</p><p><strong>1. 参数解析和验证</strong><br><code>CreateProcess</code> 函数首先验证传入的参数（如可执行文件路径、命令行参数、环境变量等），检查调用者是否具有足够的权限来创建进程。用户模式下调用 <code>CreateProcess</code>，最终通过 <code>ntdll.dll</code> 调用 <code>NtCreateUserProcess</code> 进入内核模式。</p><p><strong>2. 创建和初始化进程对象</strong><br> 内核分配并初始化一个新的进程对象。相关函数包括 <code>PsCreateProcess</code>，用于创建并初始化内核中的 <code>EPROCESS</code> 结构（进程对象）；<code>MmCreateProcessAddressSpace</code>，为新进程分配虚拟地址空间；<code>ObInsertObject</code>，将新创建的进程对象插入内核对象管理器，并分配句柄。</p><p><strong>3. 创建初始线程</strong><br> 为新进程创建一个主线程。相关函数包括 <code>PsCreateThread</code>，用于创建并初始化内核中的 <code>ETHREAD</code> 结构（线程对象）；<code>ObInsertObject</code>，将新线程对象插入内核对象管理器，并分配句柄。</p><p><strong>4. 加载可执行文件</strong><br> 加载器将目标可执行文件（如 <code>.exe</code> 文件）加载到新进程的虚拟地址空间。相关函数包括 <code>MmMapViewOfSection</code>，将可执行文件映射到新进程的地址空间；<code>IoCreateFile</code>（I/O 子系统），打开目标可执行文件并读取内容；<code>MmCreateProcessAddressSpace</code>，确保虚拟地址空间中正确加载了可执行文件和所需的动态链接库（如 <code>ntdll.dll</code>、<code>kernel32.dll</code>）。</p><p><strong>5. 初始化用户模式环境</strong><br> 初始化新进程的用户模式环境，包括堆、全局变量和线程本地存储（TLS）。相关函数包括 <code>MmMapViewOfSection</code>，用于加载动态链接库（如 <code>ntdll.dll</code>）；<code>PsCreateProcess</code>，设置进程的用户模式上下文。</p><p><strong>6. 通知父进程</strong><br> 如果调用者指定了同步选项（如 <code>CREATE_SUSPENDED</code>），新进程会被挂起，直到调用者显式恢复线程。如果未指定挂起选项，线程会立即进入调度队列。相关函数包括 <code>PsResumeThread</code>，用于恢复线程执行（如果未指定挂起标志）。</p><p><strong>7. 返回句柄</strong><br><code>CreateProcess</code> 函数返回新进程和主线程的句柄。调用者可以通过这些句柄与新进程交互（如等待进程结束、获取进程状态等）。相关函数包括 <code>ObInsertObject</code>，确保进程和线程对象的句柄正确返回给调用者。</p><p><strong>总结</strong></p><ol><li><strong>参数解析和验证</strong>：通过  <code>NtCreateUserProcess</code>  进入内核模式。</li><li><strong>创建和初始化进程对象</strong>：调用  <code>PsCreateProcess</code>  和  <code>MmCreateProcessAddressSpace</code>。</li><li><strong>创建初始线程</strong>：调用  <code>PsCreateThread</code>。</li><li><strong>加载可执行文件</strong>：调用  <code>MmMapViewOfSection</code>  和  <code>IoCreateFile</code>。</li><li><strong>初始化用户模式环境</strong>：调用  <code>MmMapViewOfSection</code>  加载动态链接库。</li><li><strong>通知父进程</strong>：调用  <code>PsResumeThread</code>  恢复线程执行。</li><li><strong>返回句柄</strong>：通过  <code>ObInsertObject</code>  返回进程和线程句柄。</li></ol><p>这些内核模式函数共同完成了进程的创建和初始化工作。</p>',44)])])}const p=o(d,[["render",l]]),w=JSON.parse('{"path":"/CyberSecurity/DefenseEvasion/WindowsArchitectureProcess.html","title":"Windows 构架及进程创建总结","lang":"zh-CN","frontmatter":{"tags":["防御规避","Windows"],"category":"网络安全","description":"Windows 构架及进程创建总结 学习 Windows 基本架构及进程创建的原理。 Windows 构架 下面是现代操作系统的基本结构示意图，结合示图，可以更好地理解操作系统的作用。 由上图可知，对应的应用通过操作系统提供的系统服务来进行硬件的操作，例如打字，看电影，应用是不需要同硬件直接打交道的，这样可以节省大量的精力，而与硬件打交道的脏活累活由操...","head":[["meta",{"property":"og:url","content":"https://echo0d.github.io/DailyNotes/CyberSecurity/DefenseEvasion/WindowsArchitectureProcess.html"}],["meta",{"property":"og:site_name","content":"echo0d-notes"}],["meta",{"property":"og:title","content":"Windows 构架及进程创建总结"}],["meta",{"property":"og:description","content":"Windows 构架及进程创建总结 学习 Windows 基本架构及进程创建的原理。 Windows 构架 下面是现代操作系统的基本结构示意图，结合示图，可以更好地理解操作系统的作用。 由上图可知，对应的应用通过操作系统提供的系统服务来进行硬件的操作，例如打字，看电影，应用是不需要同硬件直接打交道的，这样可以节省大量的精力，而与硬件打交道的脏活累活由操..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-06-04T09:27:16.000Z"}],["meta",{"property":"article:author","content":"echo0d"}],["meta",{"property":"article:tag","content":"防御规避"}],["meta",{"property":"article:tag","content":"Windows"}],["meta",{"property":"article:modified_time","content":"2025-06-04T09:27:16.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Windows 构架及进程创建总结\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-06-04T09:27:16.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"echo0d\\",\\"url\\":\\"\\"}]}"]]},"headers":[{"level":2,"title":"Windows 构架","slug":"windows-构架","link":"#windows-构架","children":[{"level":3,"title":"用户模式","slug":"用户模式","link":"#用户模式","children":[]},{"level":3,"title":"内核模式","slug":"内核模式","link":"#内核模式","children":[]}]},{"level":2,"title":"进程创建过程","slug":"进程创建过程","link":"#进程创建过程","children":[{"level":3,"title":"进程创建流程","slug":"进程创建流程","link":"#进程创建流程","children":[]}]}],"git":{"createdTime":1746612383000,"updatedTime":1749029236000,"contributors":[{"name":"echo0d","email":"echo0d@163.com","commits":2}]},"readingTime":{"minutes":10.24,"words":3073},"filePathRelative":"CyberSecurity/DefenseEvasion/WindowsArchitectureProcess.md","localizedDate":"2025年5月7日","excerpt":"\\n<p>学习 Windows 基本架构及进程创建的原理。</p>\\n","autoDesc":true}');export{p as comp,w as data};
